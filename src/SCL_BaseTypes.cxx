// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "SCL_BaseTypes.hxx"

namespace SCL
{
  // tBaseElement
  // 

  const tBaseElement::Text_optional& tBaseElement::
  Text () const
  {
    return this->Text_;
  }

  tBaseElement::Text_optional& tBaseElement::
  Text ()
  {
    return this->Text_;
  }

  void tBaseElement::
  Text (const Text_type& x)
  {
    this->Text_.set (x);
  }

  void tBaseElement::
  Text (const Text_optional& x)
  {
    this->Text_ = x;
  }

  void tBaseElement::
  Text (::std::auto_ptr< Text_type > x)
  {
    this->Text_.set (x);
  }

  const tBaseElement::Private_sequence& tBaseElement::
  Private () const
  {
    return this->Private_;
  }

  tBaseElement::Private_sequence& tBaseElement::
  Private ()
  {
    return this->Private_;
  }

  void tBaseElement::
  Private (const Private_sequence& s)
  {
    this->Private_ = s;
  }


  // tUnNaming
  // 

  const tUnNaming::desc_optional& tUnNaming::
  desc () const
  {
    return this->desc_;
  }

  tUnNaming::desc_optional& tUnNaming::
  desc ()
  {
    return this->desc_;
  }

  void tUnNaming::
  desc (const desc_type& x)
  {
    this->desc_.set (x);
  }

  void tUnNaming::
  desc (const desc_optional& x)
  {
    this->desc_ = x;
  }

  void tUnNaming::
  desc (::std::auto_ptr< desc_type > x)
  {
    this->desc_.set (x);
  }


  // tNaming
  // 

  const tNaming::name_type& tNaming::
  name () const
  {
    return this->name_.get ();
  }

  tNaming::name_type& tNaming::
  name ()
  {
    return this->name_.get ();
  }

  void tNaming::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void tNaming::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const tNaming::desc_optional& tNaming::
  desc () const
  {
    return this->desc_;
  }

  tNaming::desc_optional& tNaming::
  desc ()
  {
    return this->desc_;
  }

  void tNaming::
  desc (const desc_type& x)
  {
    this->desc_.set (x);
  }

  void tNaming::
  desc (const desc_optional& x)
  {
    this->desc_ = x;
  }

  void tNaming::
  desc (::std::auto_ptr< desc_type > x)
  {
    this->desc_.set (x);
  }


  // tIDNaming
  // 

  const tIDNaming::id_type& tIDNaming::
  id () const
  {
    return this->id_.get ();
  }

  tIDNaming::id_type& tIDNaming::
  id ()
  {
    return this->id_.get ();
  }

  void tIDNaming::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void tIDNaming::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }

  const tIDNaming::desc_optional& tIDNaming::
  desc () const
  {
    return this->desc_;
  }

  tIDNaming::desc_optional& tIDNaming::
  desc ()
  {
    return this->desc_;
  }

  void tIDNaming::
  desc (const desc_type& x)
  {
    this->desc_.set (x);
  }

  void tIDNaming::
  desc (const desc_optional& x)
  {
    this->desc_ = x;
  }

  void tIDNaming::
  desc (::std::auto_ptr< desc_type > x)
  {
    this->desc_.set (x);
  }


  // tAnyContentFromOtherNamespace
  // 


  // tText
  // 

  const tText::source_optional& tText::
  source () const
  {
    return this->source_;
  }

  tText::source_optional& tText::
  source ()
  {
    return this->source_;
  }

  void tText::
  source (const source_type& x)
  {
    this->source_.set (x);
  }

  void tText::
  source (const source_optional& x)
  {
    this->source_ = x;
  }

  void tText::
  source (::std::auto_ptr< source_type > x)
  {
    this->source_.set (x);
  }


  // tPrivate
  // 

  const tPrivate::type_optional& tPrivate::
  type () const
  {
    return this->type_;
  }

  tPrivate::type_optional& tPrivate::
  type ()
  {
    return this->type_;
  }

  void tPrivate::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void tPrivate::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void tPrivate::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const tPrivate::source_optional& tPrivate::
  source () const
  {
    return this->source_;
  }

  tPrivate::source_optional& tPrivate::
  source ()
  {
    return this->source_;
  }

  void tPrivate::
  source (const source_type& x)
  {
    this->source_.set (x);
  }

  void tPrivate::
  source (const source_optional& x)
  {
    this->source_ = x;
  }

  void tPrivate::
  source (::std::auto_ptr< source_type > x)
  {
    this->source_.set (x);
  }


  // tHeader
  // 

  const tHeader::Text_optional& tHeader::
  Text () const
  {
    return this->Text_;
  }

  tHeader::Text_optional& tHeader::
  Text ()
  {
    return this->Text_;
  }

  void tHeader::
  Text (const Text_type& x)
  {
    this->Text_.set (x);
  }

  void tHeader::
  Text (const Text_optional& x)
  {
    this->Text_ = x;
  }

  void tHeader::
  Text (::std::auto_ptr< Text_type > x)
  {
    this->Text_.set (x);
  }

  const tHeader::History_optional& tHeader::
  History () const
  {
    return this->History_;
  }

  tHeader::History_optional& tHeader::
  History ()
  {
    return this->History_;
  }

  void tHeader::
  History (const History_type& x)
  {
    this->History_.set (x);
  }

  void tHeader::
  History (const History_optional& x)
  {
    this->History_ = x;
  }

  void tHeader::
  History (::std::auto_ptr< History_type > x)
  {
    this->History_.set (x);
  }

  const tHeader::id_type& tHeader::
  id () const
  {
    return this->id_.get ();
  }

  tHeader::id_type& tHeader::
  id ()
  {
    return this->id_.get ();
  }

  void tHeader::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void tHeader::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }

  const tHeader::version_optional& tHeader::
  version () const
  {
    return this->version_;
  }

  tHeader::version_optional& tHeader::
  version ()
  {
    return this->version_;
  }

  void tHeader::
  version (const version_type& x)
  {
    this->version_.set (x);
  }

  void tHeader::
  version (const version_optional& x)
  {
    this->version_ = x;
  }

  void tHeader::
  version (::std::auto_ptr< version_type > x)
  {
    this->version_.set (x);
  }

  const tHeader::revision_type& tHeader::
  revision () const
  {
    return this->revision_.get ();
  }

  tHeader::revision_type& tHeader::
  revision ()
  {
    return this->revision_.get ();
  }

  void tHeader::
  revision (const revision_type& x)
  {
    this->revision_.set (x);
  }

  void tHeader::
  revision (::std::auto_ptr< revision_type > x)
  {
    this->revision_.set (x);
  }

  const tHeader::revision_type& tHeader::
  revision_default_value ()
  {
    return revision_default_value_;
  }

  const tHeader::toolID_optional& tHeader::
  toolID () const
  {
    return this->toolID_;
  }

  tHeader::toolID_optional& tHeader::
  toolID ()
  {
    return this->toolID_;
  }

  void tHeader::
  toolID (const toolID_type& x)
  {
    this->toolID_.set (x);
  }

  void tHeader::
  toolID (const toolID_optional& x)
  {
    this->toolID_ = x;
  }

  void tHeader::
  toolID (::std::auto_ptr< toolID_type > x)
  {
    this->toolID_.set (x);
  }

  const tHeader::nameStructure_type& tHeader::
  nameStructure () const
  {
    return this->nameStructure_.get ();
  }

  tHeader::nameStructure_type& tHeader::
  nameStructure ()
  {
    return this->nameStructure_.get ();
  }

  void tHeader::
  nameStructure (const nameStructure_type& x)
  {
    this->nameStructure_.set (x);
  }

  void tHeader::
  nameStructure (::std::auto_ptr< nameStructure_type > x)
  {
    this->nameStructure_.set (x);
  }

  const tHeader::nameStructure_type& tHeader::
  nameStructure_default_value ()
  {
    return nameStructure_default_value_;
  }


  // tHitem
  // 

  const tHitem::version_type& tHitem::
  version () const
  {
    return this->version_.get ();
  }

  tHitem::version_type& tHitem::
  version ()
  {
    return this->version_.get ();
  }

  void tHitem::
  version (const version_type& x)
  {
    this->version_.set (x);
  }

  void tHitem::
  version (::std::auto_ptr< version_type > x)
  {
    this->version_.set (x);
  }

  const tHitem::revision_type& tHitem::
  revision () const
  {
    return this->revision_.get ();
  }

  tHitem::revision_type& tHitem::
  revision ()
  {
    return this->revision_.get ();
  }

  void tHitem::
  revision (const revision_type& x)
  {
    this->revision_.set (x);
  }

  void tHitem::
  revision (::std::auto_ptr< revision_type > x)
  {
    this->revision_.set (x);
  }

  const tHitem::when_type& tHitem::
  when () const
  {
    return this->when_.get ();
  }

  tHitem::when_type& tHitem::
  when ()
  {
    return this->when_.get ();
  }

  void tHitem::
  when (const when_type& x)
  {
    this->when_.set (x);
  }

  void tHitem::
  when (::std::auto_ptr< when_type > x)
  {
    this->when_.set (x);
  }

  const tHitem::who_optional& tHitem::
  who () const
  {
    return this->who_;
  }

  tHitem::who_optional& tHitem::
  who ()
  {
    return this->who_;
  }

  void tHitem::
  who (const who_type& x)
  {
    this->who_.set (x);
  }

  void tHitem::
  who (const who_optional& x)
  {
    this->who_ = x;
  }

  void tHitem::
  who (::std::auto_ptr< who_type > x)
  {
    this->who_.set (x);
  }

  const tHitem::what_optional& tHitem::
  what () const
  {
    return this->what_;
  }

  tHitem::what_optional& tHitem::
  what ()
  {
    return this->what_;
  }

  void tHitem::
  what (const what_type& x)
  {
    this->what_.set (x);
  }

  void tHitem::
  what (const what_optional& x)
  {
    this->what_ = x;
  }

  void tHitem::
  what (::std::auto_ptr< what_type > x)
  {
    this->what_.set (x);
  }

  const tHitem::why_optional& tHitem::
  why () const
  {
    return this->why_;
  }

  tHitem::why_optional& tHitem::
  why ()
  {
    return this->why_;
  }

  void tHitem::
  why (const why_type& x)
  {
    this->why_.set (x);
  }

  void tHitem::
  why (const why_optional& x)
  {
    this->why_ = x;
  }

  void tHitem::
  why (::std::auto_ptr< why_type > x)
  {
    this->why_.set (x);
  }


  // tVal
  // 

  const tVal::sGroup_optional& tVal::
  sGroup () const
  {
    return this->sGroup_;
  }

  tVal::sGroup_optional& tVal::
  sGroup ()
  {
    return this->sGroup_;
  }

  void tVal::
  sGroup (const sGroup_type& x)
  {
    this->sGroup_.set (x);
  }

  void tVal::
  sGroup (const sGroup_optional& x)
  {
    this->sGroup_ = x;
  }


  // tValueWithUnit
  // 

  const tValueWithUnit::unit_type& tValueWithUnit::
  unit () const
  {
    return this->unit_.get ();
  }

  tValueWithUnit::unit_type& tValueWithUnit::
  unit ()
  {
    return this->unit_.get ();
  }

  void tValueWithUnit::
  unit (const unit_type& x)
  {
    this->unit_.set (x);
  }

  void tValueWithUnit::
  unit (::std::auto_ptr< unit_type > x)
  {
    this->unit_.set (x);
  }

  const tValueWithUnit::multiplier_type& tValueWithUnit::
  multiplier () const
  {
    return this->multiplier_.get ();
  }

  tValueWithUnit::multiplier_type& tValueWithUnit::
  multiplier ()
  {
    return this->multiplier_.get ();
  }

  void tValueWithUnit::
  multiplier (const multiplier_type& x)
  {
    this->multiplier_.set (x);
  }

  void tValueWithUnit::
  multiplier (::std::auto_ptr< multiplier_type > x)
  {
    this->multiplier_.set (x);
  }

  const tValueWithUnit::multiplier_type& tValueWithUnit::
  multiplier_default_value ()
  {
    return multiplier_default_value_;
  }


  // tVoltage
  // 


  // tBitRateInMbPerSec
  // 


  // tDurationInSec
  // 


  // tDurationInMilliSec
  // 


  // History
  // 

  const History::Hitem_sequence& History::
  Hitem () const
  {
    return this->Hitem_;
  }

  History::Hitem_sequence& History::
  Hitem ()
  {
    return this->Hitem_;
  }

  void History::
  Hitem (const Hitem_sequence& s)
  {
    this->Hitem_ = s;
  }


  // nameStructure
  // 

  nameStructure::
  nameStructure (value v)
  : ::xml_schema::name (_xsd_nameStructure_literals_[v])
  {
  }

  nameStructure::
  nameStructure (const char* v)
  : ::xml_schema::name (v)
  {
  }

  nameStructure::
  nameStructure (const ::std::string& v)
  : ::xml_schema::name (v)
  {
  }

  nameStructure::
  nameStructure (const ::xml_schema::name& v)
  : ::xml_schema::name (v)
  {
  }

  nameStructure::
  nameStructure (const nameStructure& v,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::name (v, f, c)
  {
  }

  nameStructure& nameStructure::
  operator= (value v)
  {
    static_cast< ::xml_schema::name& > (*this) = 
    ::xml_schema::name (_xsd_nameStructure_literals_[v]);

    return *this;
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace SCL
{
  // tBaseElement
  //

  tBaseElement::
  tBaseElement ()
  : ::xml_schema::type (),
    Text_ (this),
    Private_ (this)
  {
  }

  tBaseElement::
  tBaseElement (const tBaseElement& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Text_ (x.Text_, f, this),
    Private_ (x.Private_, f, this)
  {
  }

  tBaseElement::
  tBaseElement (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Text_ (this),
    Private_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void tBaseElement::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Text
      //
      if (n.name () == "Text" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< Text_type > r (
          Text_traits::create (i, f, this));

        if (!this->Text_)
        {
          this->Text_.set (r);
          continue;
        }
      }

      // Private
      //
      if (n.name () == "Private" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< Private_type > r (
          Private_traits::create (i, f, this));

        this->Private_.push_back (r);
        continue;
      }

      break;
    }
  }

  tBaseElement* tBaseElement::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tBaseElement (*this, f, c);
  }

  tBaseElement& tBaseElement::
  operator= (const tBaseElement& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Text_ = x.Text_;
      this->Private_ = x.Private_;
    }

    return *this;
  }

  tBaseElement::
  ~tBaseElement ()
  {
  }

  // tUnNaming
  //

  tUnNaming::
  tUnNaming ()
  : ::SCL::tBaseElement (),
    desc_ (this)
  {
  }

  tUnNaming::
  tUnNaming (const tUnNaming& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::SCL::tBaseElement (x, f, c),
    desc_ (x.desc_, f, this)
  {
  }

  tUnNaming::
  tUnNaming (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::SCL::tBaseElement (e, f | ::xml_schema::flags::base, c),
    desc_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tUnNaming::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tBaseElement::parse (p, f);

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "desc" && n.namespace_ ().empty ())
      {
        this->desc_.set (desc_traits::create (i, f, this));
        continue;
      }
    }
  }

  tUnNaming* tUnNaming::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tUnNaming (*this, f, c);
  }

  tUnNaming& tUnNaming::
  operator= (const tUnNaming& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tBaseElement& > (*this) = x;
      this->desc_ = x.desc_;
    }

    return *this;
  }

  tUnNaming::
  ~tUnNaming ()
  {
  }

  // tNaming
  //

  tNaming::
  tNaming (const name_type& name)
  : ::SCL::tBaseElement (),
    name_ (name, this),
    desc_ (this)
  {
  }

  tNaming::
  tNaming (const tNaming& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::SCL::tBaseElement (x, f, c),
    name_ (x.name_, f, this),
    desc_ (x.desc_, f, this)
  {
  }

  tNaming::
  tNaming (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::SCL::tBaseElement (e, f | ::xml_schema::flags::base, c),
    name_ (this),
    desc_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tNaming::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tBaseElement::parse (p, f);

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "desc" && n.namespace_ ().empty ())
      {
        this->desc_.set (desc_traits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  tNaming* tNaming::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tNaming (*this, f, c);
  }

  tNaming& tNaming::
  operator= (const tNaming& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tBaseElement& > (*this) = x;
      this->name_ = x.name_;
      this->desc_ = x.desc_;
    }

    return *this;
  }

  tNaming::
  ~tNaming ()
  {
  }

  // tIDNaming
  //

  tIDNaming::
  tIDNaming (const id_type& id)
  : ::SCL::tBaseElement (),
    id_ (id, this),
    desc_ (this)
  {
  }

  tIDNaming::
  tIDNaming (const tIDNaming& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::SCL::tBaseElement (x, f, c),
    id_ (x.id_, f, this),
    desc_ (x.desc_, f, this)
  {
  }

  tIDNaming::
  tIDNaming (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::SCL::tBaseElement (e, f | ::xml_schema::flags::base, c),
    id_ (this),
    desc_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tIDNaming::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tBaseElement::parse (p, f);

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "desc" && n.namespace_ ().empty ())
      {
        this->desc_.set (desc_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  tIDNaming* tIDNaming::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tIDNaming (*this, f, c);
  }

  tIDNaming& tIDNaming::
  operator= (const tIDNaming& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tBaseElement& > (*this) = x;
      this->id_ = x.id_;
      this->desc_ = x.desc_;
    }

    return *this;
  }

  tIDNaming::
  ~tIDNaming ()
  {
  }

  // tAnyContentFromOtherNamespace
  //

  tAnyContentFromOtherNamespace::
  tAnyContentFromOtherNamespace ()
  : ::xml_schema::type ()
  {
  }

  tAnyContentFromOtherNamespace::
  tAnyContentFromOtherNamespace (const tAnyContentFromOtherNamespace& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c)
  {
  }

  tAnyContentFromOtherNamespace::
  tAnyContentFromOtherNamespace (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void tAnyContentFromOtherNamespace::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      break;
    }
  }

  tAnyContentFromOtherNamespace* tAnyContentFromOtherNamespace::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tAnyContentFromOtherNamespace (*this, f, c);
  }

  tAnyContentFromOtherNamespace::
  ~tAnyContentFromOtherNamespace ()
  {
  }

  // tText
  //

  tText::
  tText ()
  : ::SCL::tAnyContentFromOtherNamespace (),
    source_ (this)
  {
  }

  tText::
  tText (const tText& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::SCL::tAnyContentFromOtherNamespace (x, f, c),
    source_ (x.source_, f, this)
  {
  }

  tText::
  tText (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::SCL::tAnyContentFromOtherNamespace (e, f | ::xml_schema::flags::base, c),
    source_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tText::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tAnyContentFromOtherNamespace::parse (p, f);

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "source" && n.namespace_ ().empty ())
      {
        this->source_.set (source_traits::create (i, f, this));
        continue;
      }
    }
  }

  tText* tText::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tText (*this, f, c);
  }

  tText& tText::
  operator= (const tText& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tAnyContentFromOtherNamespace& > (*this) = x;
      this->source_ = x.source_;
    }

    return *this;
  }

  tText::
  ~tText ()
  {
  }

  // tPrivate
  //

  tPrivate::
  tPrivate ()
  : ::SCL::tAnyContentFromOtherNamespace (),
    type_ (this),
    source_ (this)
  {
  }

  tPrivate::
  tPrivate (const tPrivate& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::SCL::tAnyContentFromOtherNamespace (x, f, c),
    type_ (x.type_, f, this),
    source_ (x.source_, f, this)
  {
  }

  tPrivate::
  tPrivate (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::SCL::tAnyContentFromOtherNamespace (e, f | ::xml_schema::flags::base, c),
    type_ (this),
    source_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tPrivate::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tAnyContentFromOtherNamespace::parse (p, f);

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "source" && n.namespace_ ().empty ())
      {
        this->source_.set (source_traits::create (i, f, this));
        continue;
      }
    }
  }

  tPrivate* tPrivate::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tPrivate (*this, f, c);
  }

  tPrivate& tPrivate::
  operator= (const tPrivate& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tAnyContentFromOtherNamespace& > (*this) = x;
      this->type_ = x.type_;
      this->source_ = x.source_;
    }

    return *this;
  }

  tPrivate::
  ~tPrivate ()
  {
  }

  // tHeader
  //

  const tHeader::revision_type tHeader::revision_default_value_ (
    "");

  const tHeader::nameStructure_type tHeader::nameStructure_default_value_ (
    "IEDName");

  tHeader::
  tHeader (const id_type& id)
  : ::xml_schema::type (),
    Text_ (this),
    History_ (this),
    id_ (id, this),
    version_ (this),
    revision_ (revision_default_value (), this),
    toolID_ (this),
    nameStructure_ (nameStructure_default_value (), this)
  {
  }

  tHeader::
  tHeader (const tHeader& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Text_ (x.Text_, f, this),
    History_ (x.History_, f, this),
    id_ (x.id_, f, this),
    version_ (x.version_, f, this),
    revision_ (x.revision_, f, this),
    toolID_ (x.toolID_, f, this),
    nameStructure_ (x.nameStructure_, f, this)
  {
  }

  tHeader::
  tHeader (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Text_ (this),
    History_ (this),
    id_ (this),
    version_ (this),
    revision_ (this),
    toolID_ (this),
    nameStructure_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tHeader::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Text
      //
      if (n.name () == "Text" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< Text_type > r (
          Text_traits::create (i, f, this));

        if (!this->Text_)
        {
          this->Text_.set (r);
          continue;
        }
      }

      // History
      //
      if (n.name () == "History" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< History_type > r (
          History_traits::create (i, f, this));

        if (!this->History_)
        {
          this->History_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "version" && n.namespace_ ().empty ())
      {
        this->version_.set (version_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "revision" && n.namespace_ ().empty ())
      {
        this->revision_.set (revision_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "toolID" && n.namespace_ ().empty ())
      {
        this->toolID_.set (toolID_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "nameStructure" && n.namespace_ ().empty ())
      {
        this->nameStructure_.set (nameStructure_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }

    if (!revision_.present ())
    {
      this->revision_.set (revision_default_value ());
    }

    if (!nameStructure_.present ())
    {
      this->nameStructure_.set (nameStructure_default_value ());
    }
  }

  tHeader* tHeader::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tHeader (*this, f, c);
  }

  tHeader& tHeader::
  operator= (const tHeader& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Text_ = x.Text_;
      this->History_ = x.History_;
      this->id_ = x.id_;
      this->version_ = x.version_;
      this->revision_ = x.revision_;
      this->toolID_ = x.toolID_;
      this->nameStructure_ = x.nameStructure_;
    }

    return *this;
  }

  tHeader::
  ~tHeader ()
  {
  }

  // tHitem
  //

  tHitem::
  tHitem (const version_type& version,
          const revision_type& revision,
          const when_type& when)
  : ::SCL::tAnyContentFromOtherNamespace (),
    version_ (version, this),
    revision_ (revision, this),
    when_ (when, this),
    who_ (this),
    what_ (this),
    why_ (this)
  {
  }

  tHitem::
  tHitem (const tHitem& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::SCL::tAnyContentFromOtherNamespace (x, f, c),
    version_ (x.version_, f, this),
    revision_ (x.revision_, f, this),
    when_ (x.when_, f, this),
    who_ (x.who_, f, this),
    what_ (x.what_, f, this),
    why_ (x.why_, f, this)
  {
  }

  tHitem::
  tHitem (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::SCL::tAnyContentFromOtherNamespace (e, f | ::xml_schema::flags::base, c),
    version_ (this),
    revision_ (this),
    when_ (this),
    who_ (this),
    what_ (this),
    why_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tHitem::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tAnyContentFromOtherNamespace::parse (p, f);

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "version" && n.namespace_ ().empty ())
      {
        this->version_.set (version_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "revision" && n.namespace_ ().empty ())
      {
        this->revision_.set (revision_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "when" && n.namespace_ ().empty ())
      {
        this->when_.set (when_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "who" && n.namespace_ ().empty ())
      {
        this->who_.set (who_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "what" && n.namespace_ ().empty ())
      {
        this->what_.set (what_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "why" && n.namespace_ ().empty ())
      {
        this->why_.set (why_traits::create (i, f, this));
        continue;
      }
    }

    if (!version_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "version",
        "");
    }

    if (!revision_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "revision",
        "");
    }

    if (!when_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "when",
        "");
    }
  }

  tHitem* tHitem::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tHitem (*this, f, c);
  }

  tHitem& tHitem::
  operator= (const tHitem& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tAnyContentFromOtherNamespace& > (*this) = x;
      this->version_ = x.version_;
      this->revision_ = x.revision_;
      this->when_ = x.when_;
      this->who_ = x.who_;
      this->what_ = x.what_;
      this->why_ = x.why_;
    }

    return *this;
  }

  tHitem::
  ~tHitem ()
  {
  }

  // tVal
  //

  tVal::
  tVal ()
  : ::xml_schema::normalized_string (),
    sGroup_ (this)
  {
  }

  tVal::
  tVal (const char* _xsd_normalized_string_base)
  : ::xml_schema::normalized_string (_xsd_normalized_string_base),
    sGroup_ (this)
  {
  }

  tVal::
  tVal (const ::std::string& _xsd_normalized_string_base)
  : ::xml_schema::normalized_string (_xsd_normalized_string_base),
    sGroup_ (this)
  {
  }

  tVal::
  tVal (const ::xml_schema::normalized_string& _xsd_normalized_string_base)
  : ::xml_schema::normalized_string (_xsd_normalized_string_base),
    sGroup_ (this)
  {
  }

  tVal::
  tVal (const tVal& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::normalized_string (x, f, c),
    sGroup_ (x.sGroup_, f, this)
  {
  }

  tVal::
  tVal (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::normalized_string (e, f | ::xml_schema::flags::base, c),
    sGroup_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void tVal::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "sGroup" && n.namespace_ ().empty ())
      {
        this->sGroup_.set (sGroup_traits::create (i, f, this));
        continue;
      }
    }
  }

  tVal* tVal::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tVal (*this, f, c);
  }

  tVal& tVal::
  operator= (const tVal& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::normalized_string& > (*this) = x;
      this->sGroup_ = x.sGroup_;
    }

    return *this;
  }

  tVal::
  ~tVal ()
  {
  }

  // tValueWithUnit
  //

  const tValueWithUnit::multiplier_type tValueWithUnit::multiplier_default_value_ (
    "");

  tValueWithUnit::
  tValueWithUnit (const ::xml_schema::decimal& _xsd_decimal_base,
                  const unit_type& unit)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base),
    unit_ (unit, this),
    multiplier_ (multiplier_default_value (), this)
  {
  }

  tValueWithUnit::
  tValueWithUnit (const tValueWithUnit& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c),
    unit_ (x.unit_, f, this),
    multiplier_ (x.multiplier_, f, this)
  {
  }

  tValueWithUnit::
  tValueWithUnit (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f | ::xml_schema::flags::base, c),
    unit_ (this),
    multiplier_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void tValueWithUnit::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "unit" && n.namespace_ ().empty ())
      {
        this->unit_.set (unit_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "multiplier" && n.namespace_ ().empty ())
      {
        this->multiplier_.set (multiplier_traits::create (i, f, this));
        continue;
      }
    }

    if (!unit_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "unit",
        "");
    }

    if (!multiplier_.present ())
    {
      this->multiplier_.set (multiplier_default_value ());
    }
  }

  tValueWithUnit* tValueWithUnit::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tValueWithUnit (*this, f, c);
  }

  tValueWithUnit& tValueWithUnit::
  operator= (const tValueWithUnit& x)
  {
    if (this != &x)
    {
      static_cast< ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (*this) = x;
      this->unit_ = x.unit_;
      this->multiplier_ = x.multiplier_;
    }

    return *this;
  }

  tValueWithUnit::
  ~tValueWithUnit ()
  {
  }

  // tVoltage
  //

  tVoltage::
  tVoltage (const ::xml_schema::decimal& _xsd_decimal_base,
            const unit_type& unit)
  : ::SCL::tValueWithUnit (_xsd_decimal_base,
                           unit)
  {
  }

  tVoltage::
  tVoltage (const tVoltage& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::SCL::tValueWithUnit (x, f, c)
  {
  }

  tVoltage::
  tVoltage (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::SCL::tValueWithUnit (e, f, c)
  {
  }

  tVoltage* tVoltage::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tVoltage (*this, f, c);
  }

  tVoltage::
  ~tVoltage ()
  {
  }

  // tBitRateInMbPerSec
  //

  tBitRateInMbPerSec::
  tBitRateInMbPerSec (const ::xml_schema::decimal& _xsd_decimal_base,
                      const unit_type& unit)
  : ::SCL::tValueWithUnit (_xsd_decimal_base,
                           unit)
  {
  }

  tBitRateInMbPerSec::
  tBitRateInMbPerSec (const tBitRateInMbPerSec& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::SCL::tValueWithUnit (x, f, c)
  {
  }

  tBitRateInMbPerSec::
  tBitRateInMbPerSec (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::SCL::tValueWithUnit (e, f, c)
  {
  }

  tBitRateInMbPerSec* tBitRateInMbPerSec::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tBitRateInMbPerSec (*this, f, c);
  }

  tBitRateInMbPerSec::
  ~tBitRateInMbPerSec ()
  {
  }

  // tDurationInSec
  //

  tDurationInSec::
  tDurationInSec (const ::xml_schema::decimal& _xsd_decimal_base,
                  const unit_type& unit)
  : ::SCL::tValueWithUnit (_xsd_decimal_base,
                           unit)
  {
  }

  tDurationInSec::
  tDurationInSec (const tDurationInSec& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::SCL::tValueWithUnit (x, f, c)
  {
  }

  tDurationInSec::
  tDurationInSec (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::SCL::tValueWithUnit (e, f, c)
  {
  }

  tDurationInSec* tDurationInSec::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tDurationInSec (*this, f, c);
  }

  tDurationInSec::
  ~tDurationInSec ()
  {
  }

  // tDurationInMilliSec
  //

  tDurationInMilliSec::
  tDurationInMilliSec (const ::xml_schema::decimal& _xsd_decimal_base,
                       const unit_type& unit)
  : ::SCL::tValueWithUnit (_xsd_decimal_base,
                           unit)
  {
  }

  tDurationInMilliSec::
  tDurationInMilliSec (const tDurationInMilliSec& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::SCL::tValueWithUnit (x, f, c)
  {
  }

  tDurationInMilliSec::
  tDurationInMilliSec (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::SCL::tValueWithUnit (e, f, c)
  {
  }

  tDurationInMilliSec* tDurationInMilliSec::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tDurationInMilliSec (*this, f, c);
  }

  tDurationInMilliSec::
  ~tDurationInMilliSec ()
  {
  }

  // History
  //

  History::
  History ()
  : ::xml_schema::type (),
    Hitem_ (this)
  {
  }

  History::
  History (const History& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Hitem_ (x.Hitem_, f, this)
  {
  }

  History::
  History (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Hitem_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void History::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Hitem
      //
      if (n.name () == "Hitem" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< Hitem_type > r (
          Hitem_traits::create (i, f, this));

        this->Hitem_.push_back (r);
        continue;
      }

      break;
    }
  }

  History* History::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class History (*this, f, c);
  }

  History& History::
  operator= (const History& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Hitem_ = x.Hitem_;
    }

    return *this;
  }

  History::
  ~History ()
  {
  }

  // nameStructure
  //

  nameStructure::
  nameStructure (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::name (e, f, c)
  {
    _xsd_nameStructure_convert ();
  }

  nameStructure::
  nameStructure (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::name (a, f, c)
  {
    _xsd_nameStructure_convert ();
  }

  nameStructure::
  nameStructure (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::name (s, e, f, c)
  {
    _xsd_nameStructure_convert ();
  }

  nameStructure* nameStructure::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class nameStructure (*this, f, c);
  }

  nameStructure::value nameStructure::
  _xsd_nameStructure_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_nameStructure_literals_);
    const value* i (::std::lower_bound (
                      _xsd_nameStructure_indexes_,
                      _xsd_nameStructure_indexes_ + 1,
                      *this,
                      c));

    if (i == _xsd_nameStructure_indexes_ + 1 || _xsd_nameStructure_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const nameStructure::
  _xsd_nameStructure_literals_[1] =
  {
    "IEDName"
  };

  const nameStructure::value nameStructure::
  _xsd_nameStructure_indexes_[1] =
  {
    ::SCL::nameStructure::IEDName
  };
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace SCL
{
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

