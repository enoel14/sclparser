// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "SCL_IED.hxx"

namespace SCL
{
  // tIED
  // 

  const tIED::Services_optional& tIED::
  Services () const
  {
    return this->Services_;
  }

  tIED::Services_optional& tIED::
  Services ()
  {
    return this->Services_;
  }

  void tIED::
  Services (const Services_type& x)
  {
    this->Services_.set (x);
  }

  void tIED::
  Services (const Services_optional& x)
  {
    this->Services_ = x;
  }

  void tIED::
  Services (::std::auto_ptr< Services_type > x)
  {
    this->Services_.set (x);
  }

  const tIED::AccessPoint_sequence& tIED::
  AccessPoint () const
  {
    return this->AccessPoint_;
  }

  tIED::AccessPoint_sequence& tIED::
  AccessPoint ()
  {
    return this->AccessPoint_;
  }

  void tIED::
  AccessPoint (const AccessPoint_sequence& s)
  {
    this->AccessPoint_ = s;
  }

  const tIED::type_optional& tIED::
  type () const
  {
    return this->type_;
  }

  tIED::type_optional& tIED::
  type ()
  {
    return this->type_;
  }

  void tIED::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void tIED::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void tIED::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const tIED::manufacturer_optional& tIED::
  manufacturer () const
  {
    return this->manufacturer_;
  }

  tIED::manufacturer_optional& tIED::
  manufacturer ()
  {
    return this->manufacturer_;
  }

  void tIED::
  manufacturer (const manufacturer_type& x)
  {
    this->manufacturer_.set (x);
  }

  void tIED::
  manufacturer (const manufacturer_optional& x)
  {
    this->manufacturer_ = x;
  }

  void tIED::
  manufacturer (::std::auto_ptr< manufacturer_type > x)
  {
    this->manufacturer_.set (x);
  }

  const tIED::configVersion_optional& tIED::
  configVersion () const
  {
    return this->configVersion_;
  }

  tIED::configVersion_optional& tIED::
  configVersion ()
  {
    return this->configVersion_;
  }

  void tIED::
  configVersion (const configVersion_type& x)
  {
    this->configVersion_.set (x);
  }

  void tIED::
  configVersion (const configVersion_optional& x)
  {
    this->configVersion_ = x;
  }

  void tIED::
  configVersion (::std::auto_ptr< configVersion_type > x)
  {
    this->configVersion_.set (x);
  }


  // tServices
  // 

  const tServices::DynAssociation_optional& tServices::
  DynAssociation () const
  {
    return this->DynAssociation_;
  }

  tServices::DynAssociation_optional& tServices::
  DynAssociation ()
  {
    return this->DynAssociation_;
  }

  void tServices::
  DynAssociation (const DynAssociation_type& x)
  {
    this->DynAssociation_.set (x);
  }

  void tServices::
  DynAssociation (const DynAssociation_optional& x)
  {
    this->DynAssociation_ = x;
  }

  void tServices::
  DynAssociation (::std::auto_ptr< DynAssociation_type > x)
  {
    this->DynAssociation_.set (x);
  }

  const tServices::SettingGroups_optional& tServices::
  SettingGroups () const
  {
    return this->SettingGroups_;
  }

  tServices::SettingGroups_optional& tServices::
  SettingGroups ()
  {
    return this->SettingGroups_;
  }

  void tServices::
  SettingGroups (const SettingGroups_type& x)
  {
    this->SettingGroups_.set (x);
  }

  void tServices::
  SettingGroups (const SettingGroups_optional& x)
  {
    this->SettingGroups_ = x;
  }

  void tServices::
  SettingGroups (::std::auto_ptr< SettingGroups_type > x)
  {
    this->SettingGroups_.set (x);
  }

  const tServices::GetDirectory_optional& tServices::
  GetDirectory () const
  {
    return this->GetDirectory_;
  }

  tServices::GetDirectory_optional& tServices::
  GetDirectory ()
  {
    return this->GetDirectory_;
  }

  void tServices::
  GetDirectory (const GetDirectory_type& x)
  {
    this->GetDirectory_.set (x);
  }

  void tServices::
  GetDirectory (const GetDirectory_optional& x)
  {
    this->GetDirectory_ = x;
  }

  void tServices::
  GetDirectory (::std::auto_ptr< GetDirectory_type > x)
  {
    this->GetDirectory_.set (x);
  }

  const tServices::GetDataObjectDefinition_optional& tServices::
  GetDataObjectDefinition () const
  {
    return this->GetDataObjectDefinition_;
  }

  tServices::GetDataObjectDefinition_optional& tServices::
  GetDataObjectDefinition ()
  {
    return this->GetDataObjectDefinition_;
  }

  void tServices::
  GetDataObjectDefinition (const GetDataObjectDefinition_type& x)
  {
    this->GetDataObjectDefinition_.set (x);
  }

  void tServices::
  GetDataObjectDefinition (const GetDataObjectDefinition_optional& x)
  {
    this->GetDataObjectDefinition_ = x;
  }

  void tServices::
  GetDataObjectDefinition (::std::auto_ptr< GetDataObjectDefinition_type > x)
  {
    this->GetDataObjectDefinition_.set (x);
  }

  const tServices::DataObjectDirectory_optional& tServices::
  DataObjectDirectory () const
  {
    return this->DataObjectDirectory_;
  }

  tServices::DataObjectDirectory_optional& tServices::
  DataObjectDirectory ()
  {
    return this->DataObjectDirectory_;
  }

  void tServices::
  DataObjectDirectory (const DataObjectDirectory_type& x)
  {
    this->DataObjectDirectory_.set (x);
  }

  void tServices::
  DataObjectDirectory (const DataObjectDirectory_optional& x)
  {
    this->DataObjectDirectory_ = x;
  }

  void tServices::
  DataObjectDirectory (::std::auto_ptr< DataObjectDirectory_type > x)
  {
    this->DataObjectDirectory_.set (x);
  }

  const tServices::GetDataSetValue_optional& tServices::
  GetDataSetValue () const
  {
    return this->GetDataSetValue_;
  }

  tServices::GetDataSetValue_optional& tServices::
  GetDataSetValue ()
  {
    return this->GetDataSetValue_;
  }

  void tServices::
  GetDataSetValue (const GetDataSetValue_type& x)
  {
    this->GetDataSetValue_.set (x);
  }

  void tServices::
  GetDataSetValue (const GetDataSetValue_optional& x)
  {
    this->GetDataSetValue_ = x;
  }

  void tServices::
  GetDataSetValue (::std::auto_ptr< GetDataSetValue_type > x)
  {
    this->GetDataSetValue_.set (x);
  }

  const tServices::SetDataSetValue_optional& tServices::
  SetDataSetValue () const
  {
    return this->SetDataSetValue_;
  }

  tServices::SetDataSetValue_optional& tServices::
  SetDataSetValue ()
  {
    return this->SetDataSetValue_;
  }

  void tServices::
  SetDataSetValue (const SetDataSetValue_type& x)
  {
    this->SetDataSetValue_.set (x);
  }

  void tServices::
  SetDataSetValue (const SetDataSetValue_optional& x)
  {
    this->SetDataSetValue_ = x;
  }

  void tServices::
  SetDataSetValue (::std::auto_ptr< SetDataSetValue_type > x)
  {
    this->SetDataSetValue_.set (x);
  }

  const tServices::DataSetDirectory_optional& tServices::
  DataSetDirectory () const
  {
    return this->DataSetDirectory_;
  }

  tServices::DataSetDirectory_optional& tServices::
  DataSetDirectory ()
  {
    return this->DataSetDirectory_;
  }

  void tServices::
  DataSetDirectory (const DataSetDirectory_type& x)
  {
    this->DataSetDirectory_.set (x);
  }

  void tServices::
  DataSetDirectory (const DataSetDirectory_optional& x)
  {
    this->DataSetDirectory_ = x;
  }

  void tServices::
  DataSetDirectory (::std::auto_ptr< DataSetDirectory_type > x)
  {
    this->DataSetDirectory_.set (x);
  }

  const tServices::ConfDataSet_optional& tServices::
  ConfDataSet () const
  {
    return this->ConfDataSet_;
  }

  tServices::ConfDataSet_optional& tServices::
  ConfDataSet ()
  {
    return this->ConfDataSet_;
  }

  void tServices::
  ConfDataSet (const ConfDataSet_type& x)
  {
    this->ConfDataSet_.set (x);
  }

  void tServices::
  ConfDataSet (const ConfDataSet_optional& x)
  {
    this->ConfDataSet_ = x;
  }

  void tServices::
  ConfDataSet (::std::auto_ptr< ConfDataSet_type > x)
  {
    this->ConfDataSet_.set (x);
  }

  const tServices::DynDataSet_optional& tServices::
  DynDataSet () const
  {
    return this->DynDataSet_;
  }

  tServices::DynDataSet_optional& tServices::
  DynDataSet ()
  {
    return this->DynDataSet_;
  }

  void tServices::
  DynDataSet (const DynDataSet_type& x)
  {
    this->DynDataSet_.set (x);
  }

  void tServices::
  DynDataSet (const DynDataSet_optional& x)
  {
    this->DynDataSet_ = x;
  }

  void tServices::
  DynDataSet (::std::auto_ptr< DynDataSet_type > x)
  {
    this->DynDataSet_.set (x);
  }

  const tServices::ReadWrite_optional& tServices::
  ReadWrite () const
  {
    return this->ReadWrite_;
  }

  tServices::ReadWrite_optional& tServices::
  ReadWrite ()
  {
    return this->ReadWrite_;
  }

  void tServices::
  ReadWrite (const ReadWrite_type& x)
  {
    this->ReadWrite_.set (x);
  }

  void tServices::
  ReadWrite (const ReadWrite_optional& x)
  {
    this->ReadWrite_ = x;
  }

  void tServices::
  ReadWrite (::std::auto_ptr< ReadWrite_type > x)
  {
    this->ReadWrite_.set (x);
  }

  const tServices::TimerActivatedControl_optional& tServices::
  TimerActivatedControl () const
  {
    return this->TimerActivatedControl_;
  }

  tServices::TimerActivatedControl_optional& tServices::
  TimerActivatedControl ()
  {
    return this->TimerActivatedControl_;
  }

  void tServices::
  TimerActivatedControl (const TimerActivatedControl_type& x)
  {
    this->TimerActivatedControl_.set (x);
  }

  void tServices::
  TimerActivatedControl (const TimerActivatedControl_optional& x)
  {
    this->TimerActivatedControl_ = x;
  }

  void tServices::
  TimerActivatedControl (::std::auto_ptr< TimerActivatedControl_type > x)
  {
    this->TimerActivatedControl_.set (x);
  }

  const tServices::ConfReportControl_optional& tServices::
  ConfReportControl () const
  {
    return this->ConfReportControl_;
  }

  tServices::ConfReportControl_optional& tServices::
  ConfReportControl ()
  {
    return this->ConfReportControl_;
  }

  void tServices::
  ConfReportControl (const ConfReportControl_type& x)
  {
    this->ConfReportControl_.set (x);
  }

  void tServices::
  ConfReportControl (const ConfReportControl_optional& x)
  {
    this->ConfReportControl_ = x;
  }

  void tServices::
  ConfReportControl (::std::auto_ptr< ConfReportControl_type > x)
  {
    this->ConfReportControl_.set (x);
  }

  const tServices::GetCBValues_optional& tServices::
  GetCBValues () const
  {
    return this->GetCBValues_;
  }

  tServices::GetCBValues_optional& tServices::
  GetCBValues ()
  {
    return this->GetCBValues_;
  }

  void tServices::
  GetCBValues (const GetCBValues_type& x)
  {
    this->GetCBValues_.set (x);
  }

  void tServices::
  GetCBValues (const GetCBValues_optional& x)
  {
    this->GetCBValues_ = x;
  }

  void tServices::
  GetCBValues (::std::auto_ptr< GetCBValues_type > x)
  {
    this->GetCBValues_.set (x);
  }

  const tServices::ConfLogControl_optional& tServices::
  ConfLogControl () const
  {
    return this->ConfLogControl_;
  }

  tServices::ConfLogControl_optional& tServices::
  ConfLogControl ()
  {
    return this->ConfLogControl_;
  }

  void tServices::
  ConfLogControl (const ConfLogControl_type& x)
  {
    this->ConfLogControl_.set (x);
  }

  void tServices::
  ConfLogControl (const ConfLogControl_optional& x)
  {
    this->ConfLogControl_ = x;
  }

  void tServices::
  ConfLogControl (::std::auto_ptr< ConfLogControl_type > x)
  {
    this->ConfLogControl_.set (x);
  }

  const tServices::ReportSettings_optional& tServices::
  ReportSettings () const
  {
    return this->ReportSettings_;
  }

  tServices::ReportSettings_optional& tServices::
  ReportSettings ()
  {
    return this->ReportSettings_;
  }

  void tServices::
  ReportSettings (const ReportSettings_type& x)
  {
    this->ReportSettings_.set (x);
  }

  void tServices::
  ReportSettings (const ReportSettings_optional& x)
  {
    this->ReportSettings_ = x;
  }

  void tServices::
  ReportSettings (::std::auto_ptr< ReportSettings_type > x)
  {
    this->ReportSettings_.set (x);
  }

  const tServices::LogSettings_optional& tServices::
  LogSettings () const
  {
    return this->LogSettings_;
  }

  tServices::LogSettings_optional& tServices::
  LogSettings ()
  {
    return this->LogSettings_;
  }

  void tServices::
  LogSettings (const LogSettings_type& x)
  {
    this->LogSettings_.set (x);
  }

  void tServices::
  LogSettings (const LogSettings_optional& x)
  {
    this->LogSettings_ = x;
  }

  void tServices::
  LogSettings (::std::auto_ptr< LogSettings_type > x)
  {
    this->LogSettings_.set (x);
  }

  const tServices::GSESettings_optional& tServices::
  GSESettings () const
  {
    return this->GSESettings_;
  }

  tServices::GSESettings_optional& tServices::
  GSESettings ()
  {
    return this->GSESettings_;
  }

  void tServices::
  GSESettings (const GSESettings_type& x)
  {
    this->GSESettings_.set (x);
  }

  void tServices::
  GSESettings (const GSESettings_optional& x)
  {
    this->GSESettings_ = x;
  }

  void tServices::
  GSESettings (::std::auto_ptr< GSESettings_type > x)
  {
    this->GSESettings_.set (x);
  }

  const tServices::SMVSettings_optional& tServices::
  SMVSettings () const
  {
    return this->SMVSettings_;
  }

  tServices::SMVSettings_optional& tServices::
  SMVSettings ()
  {
    return this->SMVSettings_;
  }

  void tServices::
  SMVSettings (const SMVSettings_type& x)
  {
    this->SMVSettings_.set (x);
  }

  void tServices::
  SMVSettings (const SMVSettings_optional& x)
  {
    this->SMVSettings_ = x;
  }

  void tServices::
  SMVSettings (::std::auto_ptr< SMVSettings_type > x)
  {
    this->SMVSettings_.set (x);
  }

  const tServices::GSEDir_optional& tServices::
  GSEDir () const
  {
    return this->GSEDir_;
  }

  tServices::GSEDir_optional& tServices::
  GSEDir ()
  {
    return this->GSEDir_;
  }

  void tServices::
  GSEDir (const GSEDir_type& x)
  {
    this->GSEDir_.set (x);
  }

  void tServices::
  GSEDir (const GSEDir_optional& x)
  {
    this->GSEDir_ = x;
  }

  void tServices::
  GSEDir (::std::auto_ptr< GSEDir_type > x)
  {
    this->GSEDir_.set (x);
  }

  const tServices::GOOSE_optional& tServices::
  GOOSE () const
  {
    return this->GOOSE_;
  }

  tServices::GOOSE_optional& tServices::
  GOOSE ()
  {
    return this->GOOSE_;
  }

  void tServices::
  GOOSE (const GOOSE_type& x)
  {
    this->GOOSE_.set (x);
  }

  void tServices::
  GOOSE (const GOOSE_optional& x)
  {
    this->GOOSE_ = x;
  }

  void tServices::
  GOOSE (::std::auto_ptr< GOOSE_type > x)
  {
    this->GOOSE_.set (x);
  }

  const tServices::GSSE_optional& tServices::
  GSSE () const
  {
    return this->GSSE_;
  }

  tServices::GSSE_optional& tServices::
  GSSE ()
  {
    return this->GSSE_;
  }

  void tServices::
  GSSE (const GSSE_type& x)
  {
    this->GSSE_.set (x);
  }

  void tServices::
  GSSE (const GSSE_optional& x)
  {
    this->GSSE_ = x;
  }

  void tServices::
  GSSE (::std::auto_ptr< GSSE_type > x)
  {
    this->GSSE_.set (x);
  }

  const tServices::FileHandling_optional& tServices::
  FileHandling () const
  {
    return this->FileHandling_;
  }

  tServices::FileHandling_optional& tServices::
  FileHandling ()
  {
    return this->FileHandling_;
  }

  void tServices::
  FileHandling (const FileHandling_type& x)
  {
    this->FileHandling_.set (x);
  }

  void tServices::
  FileHandling (const FileHandling_optional& x)
  {
    this->FileHandling_ = x;
  }

  void tServices::
  FileHandling (::std::auto_ptr< FileHandling_type > x)
  {
    this->FileHandling_.set (x);
  }

  const tServices::ConfLNs_optional& tServices::
  ConfLNs () const
  {
    return this->ConfLNs_;
  }

  tServices::ConfLNs_optional& tServices::
  ConfLNs ()
  {
    return this->ConfLNs_;
  }

  void tServices::
  ConfLNs (const ConfLNs_type& x)
  {
    this->ConfLNs_.set (x);
  }

  void tServices::
  ConfLNs (const ConfLNs_optional& x)
  {
    this->ConfLNs_ = x;
  }

  void tServices::
  ConfLNs (::std::auto_ptr< ConfLNs_type > x)
  {
    this->ConfLNs_.set (x);
  }

  const tServices::ClientServices_optional& tServices::
  ClientServices () const
  {
    return this->ClientServices_;
  }

  tServices::ClientServices_optional& tServices::
  ClientServices ()
  {
    return this->ClientServices_;
  }

  void tServices::
  ClientServices (const ClientServices_type& x)
  {
    this->ClientServices_.set (x);
  }

  void tServices::
  ClientServices (const ClientServices_optional& x)
  {
    this->ClientServices_ = x;
  }

  void tServices::
  ClientServices (::std::auto_ptr< ClientServices_type > x)
  {
    this->ClientServices_.set (x);
  }


  // tAccessPoint
  // 

  const tAccessPoint::Server_optional& tAccessPoint::
  Server () const
  {
    return this->Server_;
  }

  tAccessPoint::Server_optional& tAccessPoint::
  Server ()
  {
    return this->Server_;
  }

  void tAccessPoint::
  Server (const Server_type& x)
  {
    this->Server_.set (x);
  }

  void tAccessPoint::
  Server (const Server_optional& x)
  {
    this->Server_ = x;
  }

  void tAccessPoint::
  Server (::std::auto_ptr< Server_type > x)
  {
    this->Server_.set (x);
  }

  const tAccessPoint::LN_sequence& tAccessPoint::
  LN () const
  {
    return this->LN_;
  }

  tAccessPoint::LN_sequence& tAccessPoint::
  LN ()
  {
    return this->LN_;
  }

  void tAccessPoint::
  LN (const LN_sequence& s)
  {
    this->LN_ = s;
  }

  const tAccessPoint::router_type& tAccessPoint::
  router () const
  {
    return this->router_.get ();
  }

  tAccessPoint::router_type& tAccessPoint::
  router ()
  {
    return this->router_.get ();
  }

  void tAccessPoint::
  router (const router_type& x)
  {
    this->router_.set (x);
  }

  tAccessPoint::router_type tAccessPoint::
  router_default_value ()
  {
    return router_type (false);
  }

  const tAccessPoint::clock_type& tAccessPoint::
  clock () const
  {
    return this->clock_.get ();
  }

  tAccessPoint::clock_type& tAccessPoint::
  clock ()
  {
    return this->clock_.get ();
  }

  void tAccessPoint::
  clock (const clock_type& x)
  {
    this->clock_.set (x);
  }

  tAccessPoint::clock_type tAccessPoint::
  clock_default_value ()
  {
    return clock_type (false);
  }


  // tServer
  // 

  const tServer::Authentication_type& tServer::
  Authentication () const
  {
    return this->Authentication_.get ();
  }

  tServer::Authentication_type& tServer::
  Authentication ()
  {
    return this->Authentication_.get ();
  }

  void tServer::
  Authentication (const Authentication_type& x)
  {
    this->Authentication_.set (x);
  }

  void tServer::
  Authentication (::std::auto_ptr< Authentication_type > x)
  {
    this->Authentication_.set (x);
  }

  const tServer::LDevice_sequence& tServer::
  LDevice () const
  {
    return this->LDevice_;
  }

  tServer::LDevice_sequence& tServer::
  LDevice ()
  {
    return this->LDevice_;
  }

  void tServer::
  LDevice (const LDevice_sequence& s)
  {
    this->LDevice_ = s;
  }

  const tServer::Association_sequence& tServer::
  Association () const
  {
    return this->Association_;
  }

  tServer::Association_sequence& tServer::
  Association ()
  {
    return this->Association_;
  }

  void tServer::
  Association (const Association_sequence& s)
  {
    this->Association_ = s;
  }

  const tServer::timeout_type& tServer::
  timeout () const
  {
    return this->timeout_.get ();
  }

  tServer::timeout_type& tServer::
  timeout ()
  {
    return this->timeout_.get ();
  }

  void tServer::
  timeout (const timeout_type& x)
  {
    this->timeout_.set (x);
  }

  tServer::timeout_type tServer::
  timeout_default_value ()
  {
    return timeout_type (30U);
  }


  // tLDevice
  // 

  const tLDevice::LN0_type& tLDevice::
  LN0 () const
  {
    return this->LN0_.get ();
  }

  tLDevice::LN0_type& tLDevice::
  LN0 ()
  {
    return this->LN0_.get ();
  }

  void tLDevice::
  LN0 (const LN0_type& x)
  {
    this->LN0_.set (x);
  }

  void tLDevice::
  LN0 (::std::auto_ptr< LN0_type > x)
  {
    this->LN0_.set (x);
  }

  const tLDevice::LN_sequence& tLDevice::
  LN () const
  {
    return this->LN_;
  }

  tLDevice::LN_sequence& tLDevice::
  LN ()
  {
    return this->LN_;
  }

  void tLDevice::
  LN (const LN_sequence& s)
  {
    this->LN_ = s;
  }

  const tLDevice::AccessControl_optional& tLDevice::
  AccessControl () const
  {
    return this->AccessControl_;
  }

  tLDevice::AccessControl_optional& tLDevice::
  AccessControl ()
  {
    return this->AccessControl_;
  }

  void tLDevice::
  AccessControl (const AccessControl_type& x)
  {
    this->AccessControl_.set (x);
  }

  void tLDevice::
  AccessControl (const AccessControl_optional& x)
  {
    this->AccessControl_ = x;
  }

  void tLDevice::
  AccessControl (::std::auto_ptr< AccessControl_type > x)
  {
    this->AccessControl_.set (x);
  }

  const tLDevice::inst_type& tLDevice::
  inst () const
  {
    return this->inst_.get ();
  }

  tLDevice::inst_type& tLDevice::
  inst ()
  {
    return this->inst_.get ();
  }

  void tLDevice::
  inst (const inst_type& x)
  {
    this->inst_.set (x);
  }

  void tLDevice::
  inst (::std::auto_ptr< inst_type > x)
  {
    this->inst_.set (x);
  }

  const tLDevice::ldName_optional& tLDevice::
  ldName () const
  {
    return this->ldName_;
  }

  tLDevice::ldName_optional& tLDevice::
  ldName ()
  {
    return this->ldName_;
  }

  void tLDevice::
  ldName (const ldName_type& x)
  {
    this->ldName_.set (x);
  }

  void tLDevice::
  ldName (const ldName_optional& x)
  {
    this->ldName_ = x;
  }

  void tLDevice::
  ldName (::std::auto_ptr< ldName_type > x)
  {
    this->ldName_.set (x);
  }


  // tAccessControl
  // 


  // tAssociation
  // 

  const tAssociation::kind_type& tAssociation::
  kind () const
  {
    return this->kind_.get ();
  }

  tAssociation::kind_type& tAssociation::
  kind ()
  {
    return this->kind_.get ();
  }

  void tAssociation::
  kind (const kind_type& x)
  {
    this->kind_.set (x);
  }

  void tAssociation::
  kind (::std::auto_ptr< kind_type > x)
  {
    this->kind_.set (x);
  }

  const tAssociation::associationID_optional& tAssociation::
  associationID () const
  {
    return this->associationID_;
  }

  tAssociation::associationID_optional& tAssociation::
  associationID ()
  {
    return this->associationID_;
  }

  void tAssociation::
  associationID (const associationID_type& x)
  {
    this->associationID_.set (x);
  }

  void tAssociation::
  associationID (const associationID_optional& x)
  {
    this->associationID_ = x;
  }

  void tAssociation::
  associationID (::std::auto_ptr< associationID_type > x)
  {
    this->associationID_.set (x);
  }

  const tAssociation::iedName_type& tAssociation::
  iedName () const
  {
    return this->iedName_.get ();
  }

  tAssociation::iedName_type& tAssociation::
  iedName ()
  {
    return this->iedName_.get ();
  }

  void tAssociation::
  iedName (const iedName_type& x)
  {
    this->iedName_.set (x);
  }

  void tAssociation::
  iedName (::std::auto_ptr< iedName_type > x)
  {
    this->iedName_.set (x);
  }

  const tAssociation::ldInst_type& tAssociation::
  ldInst () const
  {
    return this->ldInst_.get ();
  }

  tAssociation::ldInst_type& tAssociation::
  ldInst ()
  {
    return this->ldInst_.get ();
  }

  void tAssociation::
  ldInst (const ldInst_type& x)
  {
    this->ldInst_.set (x);
  }

  void tAssociation::
  ldInst (::std::auto_ptr< ldInst_type > x)
  {
    this->ldInst_.set (x);
  }

  const tAssociation::prefix_optional& tAssociation::
  prefix () const
  {
    return this->prefix_;
  }

  tAssociation::prefix_optional& tAssociation::
  prefix ()
  {
    return this->prefix_;
  }

  void tAssociation::
  prefix (const prefix_type& x)
  {
    this->prefix_.set (x);
  }

  void tAssociation::
  prefix (const prefix_optional& x)
  {
    this->prefix_ = x;
  }

  void tAssociation::
  prefix (::std::auto_ptr< prefix_type > x)
  {
    this->prefix_.set (x);
  }

  const tAssociation::lnClass_type& tAssociation::
  lnClass () const
  {
    return this->lnClass_.get ();
  }

  tAssociation::lnClass_type& tAssociation::
  lnClass ()
  {
    return this->lnClass_.get ();
  }

  void tAssociation::
  lnClass (const lnClass_type& x)
  {
    this->lnClass_.set (x);
  }

  void tAssociation::
  lnClass (::std::auto_ptr< lnClass_type > x)
  {
    this->lnClass_.set (x);
  }

  const tAssociation::lnInst_type& tAssociation::
  lnInst () const
  {
    return this->lnInst_.get ();
  }

  tAssociation::lnInst_type& tAssociation::
  lnInst ()
  {
    return this->lnInst_.get ();
  }

  void tAssociation::
  lnInst (const lnInst_type& x)
  {
    this->lnInst_.set (x);
  }

  void tAssociation::
  lnInst (::std::auto_ptr< lnInst_type > x)
  {
    this->lnInst_.set (x);
  }


  // tAnyLN
  // 

  const tAnyLN::DataSet_sequence& tAnyLN::
  DataSet () const
  {
    return this->DataSet_;
  }

  tAnyLN::DataSet_sequence& tAnyLN::
  DataSet ()
  {
    return this->DataSet_;
  }

  void tAnyLN::
  DataSet (const DataSet_sequence& s)
  {
    this->DataSet_ = s;
  }

  const tAnyLN::ReportControl_sequence& tAnyLN::
  ReportControl () const
  {
    return this->ReportControl_;
  }

  tAnyLN::ReportControl_sequence& tAnyLN::
  ReportControl ()
  {
    return this->ReportControl_;
  }

  void tAnyLN::
  ReportControl (const ReportControl_sequence& s)
  {
    this->ReportControl_ = s;
  }

  const tAnyLN::LogControl_sequence& tAnyLN::
  LogControl () const
  {
    return this->LogControl_;
  }

  tAnyLN::LogControl_sequence& tAnyLN::
  LogControl ()
  {
    return this->LogControl_;
  }

  void tAnyLN::
  LogControl (const LogControl_sequence& s)
  {
    this->LogControl_ = s;
  }

  const tAnyLN::DOI_sequence& tAnyLN::
  DOI () const
  {
    return this->DOI_;
  }

  tAnyLN::DOI_sequence& tAnyLN::
  DOI ()
  {
    return this->DOI_;
  }

  void tAnyLN::
  DOI (const DOI_sequence& s)
  {
    this->DOI_ = s;
  }

  const tAnyLN::Inputs_optional& tAnyLN::
  Inputs () const
  {
    return this->Inputs_;
  }

  tAnyLN::Inputs_optional& tAnyLN::
  Inputs ()
  {
    return this->Inputs_;
  }

  void tAnyLN::
  Inputs (const Inputs_type& x)
  {
    this->Inputs_.set (x);
  }

  void tAnyLN::
  Inputs (const Inputs_optional& x)
  {
    this->Inputs_ = x;
  }

  void tAnyLN::
  Inputs (::std::auto_ptr< Inputs_type > x)
  {
    this->Inputs_.set (x);
  }

  const tAnyLN::lnType_type& tAnyLN::
  lnType () const
  {
    return this->lnType_.get ();
  }

  tAnyLN::lnType_type& tAnyLN::
  lnType ()
  {
    return this->lnType_.get ();
  }

  void tAnyLN::
  lnType (const lnType_type& x)
  {
    this->lnType_.set (x);
  }

  void tAnyLN::
  lnType (::std::auto_ptr< lnType_type > x)
  {
    this->lnType_.set (x);
  }


  // tLN
  // 

  const tLN::lnClass_type& tLN::
  lnClass () const
  {
    return this->lnClass_.get ();
  }

  tLN::lnClass_type& tLN::
  lnClass ()
  {
    return this->lnClass_.get ();
  }

  void tLN::
  lnClass (const lnClass_type& x)
  {
    this->lnClass_.set (x);
  }

  void tLN::
  lnClass (::std::auto_ptr< lnClass_type > x)
  {
    this->lnClass_.set (x);
  }

  const tLN::inst_type& tLN::
  inst () const
  {
    return this->inst_.get ();
  }

  tLN::inst_type& tLN::
  inst ()
  {
    return this->inst_.get ();
  }

  void tLN::
  inst (const inst_type& x)
  {
    this->inst_.set (x);
  }

  const tLN::prefix_optional& tLN::
  prefix () const
  {
    return this->prefix_;
  }

  tLN::prefix_optional& tLN::
  prefix ()
  {
    return this->prefix_;
  }

  void tLN::
  prefix (const prefix_type& x)
  {
    this->prefix_.set (x);
  }

  void tLN::
  prefix (const prefix_optional& x)
  {
    this->prefix_ = x;
  }

  void tLN::
  prefix (::std::auto_ptr< prefix_type > x)
  {
    this->prefix_.set (x);
  }


  // tLN0
  // 

  const tLN0::GSEControl_sequence& tLN0::
  GSEControl () const
  {
    return this->GSEControl_;
  }

  tLN0::GSEControl_sequence& tLN0::
  GSEControl ()
  {
    return this->GSEControl_;
  }

  void tLN0::
  GSEControl (const GSEControl_sequence& s)
  {
    this->GSEControl_ = s;
  }

  const tLN0::SampledValueControl_sequence& tLN0::
  SampledValueControl () const
  {
    return this->SampledValueControl_;
  }

  tLN0::SampledValueControl_sequence& tLN0::
  SampledValueControl ()
  {
    return this->SampledValueControl_;
  }

  void tLN0::
  SampledValueControl (const SampledValueControl_sequence& s)
  {
    this->SampledValueControl_ = s;
  }

  const tLN0::SettingControl_optional& tLN0::
  SettingControl () const
  {
    return this->SettingControl_;
  }

  tLN0::SettingControl_optional& tLN0::
  SettingControl ()
  {
    return this->SettingControl_;
  }

  void tLN0::
  SettingControl (const SettingControl_type& x)
  {
    this->SettingControl_.set (x);
  }

  void tLN0::
  SettingControl (const SettingControl_optional& x)
  {
    this->SettingControl_ = x;
  }

  void tLN0::
  SettingControl (::std::auto_ptr< SettingControl_type > x)
  {
    this->SettingControl_.set (x);
  }

  const tLN0::SCLControl_optional& tLN0::
  SCLControl () const
  {
    return this->SCLControl_;
  }

  tLN0::SCLControl_optional& tLN0::
  SCLControl ()
  {
    return this->SCLControl_;
  }

  void tLN0::
  SCLControl (const SCLControl_type& x)
  {
    this->SCLControl_.set (x);
  }

  void tLN0::
  SCLControl (const SCLControl_optional& x)
  {
    this->SCLControl_ = x;
  }

  void tLN0::
  SCLControl (::std::auto_ptr< SCLControl_type > x)
  {
    this->SCLControl_.set (x);
  }

  const tLN0::Log_optional& tLN0::
  Log () const
  {
    return this->Log_;
  }

  tLN0::Log_optional& tLN0::
  Log ()
  {
    return this->Log_;
  }

  void tLN0::
  Log (const Log_type& x)
  {
    this->Log_.set (x);
  }

  void tLN0::
  Log (const Log_optional& x)
  {
    this->Log_ = x;
  }

  void tLN0::
  Log (::std::auto_ptr< Log_type > x)
  {
    this->Log_.set (x);
  }

  const tLN0::lnClass_type& tLN0::
  lnClass () const
  {
    return this->lnClass_.get ();
  }

  const tLN0::lnClass_type& tLN0::
  lnClass_default_value ()
  {
    return lnClass_default_value_;
  }

  const tLN0::inst_type& tLN0::
  inst () const
  {
    return this->inst_.get ();
  }

  const tLN0::inst_type& tLN0::
  inst_default_value ()
  {
    return inst_default_value_;
  }


  // tDataSet
  // 

  const tDataSet::FCDA_sequence& tDataSet::
  FCDA () const
  {
    return this->FCDA_;
  }

  tDataSet::FCDA_sequence& tDataSet::
  FCDA ()
  {
    return this->FCDA_;
  }

  void tDataSet::
  FCDA (const FCDA_sequence& s)
  {
    this->FCDA_ = s;
  }

  const tDataSet::FCCB_sequence& tDataSet::
  FCCB () const
  {
    return this->FCCB_;
  }

  tDataSet::FCCB_sequence& tDataSet::
  FCCB ()
  {
    return this->FCCB_;
  }

  void tDataSet::
  FCCB (const FCCB_sequence& s)
  {
    this->FCCB_ = s;
  }


  // tFCDA
  // 

  const tFCDA::ldInst_optional& tFCDA::
  ldInst () const
  {
    return this->ldInst_;
  }

  tFCDA::ldInst_optional& tFCDA::
  ldInst ()
  {
    return this->ldInst_;
  }

  void tFCDA::
  ldInst (const ldInst_type& x)
  {
    this->ldInst_.set (x);
  }

  void tFCDA::
  ldInst (const ldInst_optional& x)
  {
    this->ldInst_ = x;
  }

  void tFCDA::
  ldInst (::std::auto_ptr< ldInst_type > x)
  {
    this->ldInst_.set (x);
  }

  const tFCDA::prefix_optional& tFCDA::
  prefix () const
  {
    return this->prefix_;
  }

  tFCDA::prefix_optional& tFCDA::
  prefix ()
  {
    return this->prefix_;
  }

  void tFCDA::
  prefix (const prefix_type& x)
  {
    this->prefix_.set (x);
  }

  void tFCDA::
  prefix (const prefix_optional& x)
  {
    this->prefix_ = x;
  }

  void tFCDA::
  prefix (::std::auto_ptr< prefix_type > x)
  {
    this->prefix_.set (x);
  }

  const tFCDA::lnClass_optional& tFCDA::
  lnClass () const
  {
    return this->lnClass_;
  }

  tFCDA::lnClass_optional& tFCDA::
  lnClass ()
  {
    return this->lnClass_;
  }

  void tFCDA::
  lnClass (const lnClass_type& x)
  {
    this->lnClass_.set (x);
  }

  void tFCDA::
  lnClass (const lnClass_optional& x)
  {
    this->lnClass_ = x;
  }

  void tFCDA::
  lnClass (::std::auto_ptr< lnClass_type > x)
  {
    this->lnClass_.set (x);
  }

  const tFCDA::lnInst_optional& tFCDA::
  lnInst () const
  {
    return this->lnInst_;
  }

  tFCDA::lnInst_optional& tFCDA::
  lnInst ()
  {
    return this->lnInst_;
  }

  void tFCDA::
  lnInst (const lnInst_type& x)
  {
    this->lnInst_.set (x);
  }

  void tFCDA::
  lnInst (const lnInst_optional& x)
  {
    this->lnInst_ = x;
  }

  void tFCDA::
  lnInst (::std::auto_ptr< lnInst_type > x)
  {
    this->lnInst_.set (x);
  }

  const tFCDA::doName_optional& tFCDA::
  doName () const
  {
    return this->doName_;
  }

  tFCDA::doName_optional& tFCDA::
  doName ()
  {
    return this->doName_;
  }

  void tFCDA::
  doName (const doName_type& x)
  {
    this->doName_.set (x);
  }

  void tFCDA::
  doName (const doName_optional& x)
  {
    this->doName_ = x;
  }

  void tFCDA::
  doName (::std::auto_ptr< doName_type > x)
  {
    this->doName_.set (x);
  }

  const tFCDA::daName_optional& tFCDA::
  daName () const
  {
    return this->daName_;
  }

  tFCDA::daName_optional& tFCDA::
  daName ()
  {
    return this->daName_;
  }

  void tFCDA::
  daName (const daName_type& x)
  {
    this->daName_.set (x);
  }

  void tFCDA::
  daName (const daName_optional& x)
  {
    this->daName_ = x;
  }

  void tFCDA::
  daName (::std::auto_ptr< daName_type > x)
  {
    this->daName_.set (x);
  }

  const tFCDA::fc_type& tFCDA::
  fc () const
  {
    return this->fc_.get ();
  }

  tFCDA::fc_type& tFCDA::
  fc ()
  {
    return this->fc_.get ();
  }

  void tFCDA::
  fc (const fc_type& x)
  {
    this->fc_.set (x);
  }

  void tFCDA::
  fc (::std::auto_ptr< fc_type > x)
  {
    this->fc_.set (x);
  }


  // tFCCB
  // 

  const tFCCB::ldInst_type& tFCCB::
  ldInst () const
  {
    return this->ldInst_.get ();
  }

  tFCCB::ldInst_type& tFCCB::
  ldInst ()
  {
    return this->ldInst_.get ();
  }

  void tFCCB::
  ldInst (const ldInst_type& x)
  {
    this->ldInst_.set (x);
  }

  void tFCCB::
  ldInst (::std::auto_ptr< ldInst_type > x)
  {
    this->ldInst_.set (x);
  }

  const tFCCB::prefix_optional& tFCCB::
  prefix () const
  {
    return this->prefix_;
  }

  tFCCB::prefix_optional& tFCCB::
  prefix ()
  {
    return this->prefix_;
  }

  void tFCCB::
  prefix (const prefix_type& x)
  {
    this->prefix_.set (x);
  }

  void tFCCB::
  prefix (const prefix_optional& x)
  {
    this->prefix_ = x;
  }

  void tFCCB::
  prefix (::std::auto_ptr< prefix_type > x)
  {
    this->prefix_.set (x);
  }

  const tFCCB::lnClass_type& tFCCB::
  lnClass () const
  {
    return this->lnClass_.get ();
  }

  tFCCB::lnClass_type& tFCCB::
  lnClass ()
  {
    return this->lnClass_.get ();
  }

  void tFCCB::
  lnClass (const lnClass_type& x)
  {
    this->lnClass_.set (x);
  }

  void tFCCB::
  lnClass (::std::auto_ptr< lnClass_type > x)
  {
    this->lnClass_.set (x);
  }

  const tFCCB::lnInst_optional& tFCCB::
  lnInst () const
  {
    return this->lnInst_;
  }

  tFCCB::lnInst_optional& tFCCB::
  lnInst ()
  {
    return this->lnInst_;
  }

  void tFCCB::
  lnInst (const lnInst_type& x)
  {
    this->lnInst_.set (x);
  }

  void tFCCB::
  lnInst (const lnInst_optional& x)
  {
    this->lnInst_ = x;
  }

  void tFCCB::
  lnInst (::std::auto_ptr< lnInst_type > x)
  {
    this->lnInst_.set (x);
  }

  const tFCCB::cbName_type& tFCCB::
  cbName () const
  {
    return this->cbName_.get ();
  }

  tFCCB::cbName_type& tFCCB::
  cbName ()
  {
    return this->cbName_.get ();
  }

  void tFCCB::
  cbName (const cbName_type& x)
  {
    this->cbName_.set (x);
  }

  void tFCCB::
  cbName (::std::auto_ptr< cbName_type > x)
  {
    this->cbName_.set (x);
  }

  const tFCCB::daName_optional& tFCCB::
  daName () const
  {
    return this->daName_;
  }

  tFCCB::daName_optional& tFCCB::
  daName ()
  {
    return this->daName_;
  }

  void tFCCB::
  daName (const daName_type& x)
  {
    this->daName_.set (x);
  }

  void tFCCB::
  daName (const daName_optional& x)
  {
    this->daName_ = x;
  }

  void tFCCB::
  daName (::std::auto_ptr< daName_type > x)
  {
    this->daName_.set (x);
  }

  const tFCCB::fc_type& tFCCB::
  fc () const
  {
    return this->fc_.get ();
  }

  tFCCB::fc_type& tFCCB::
  fc ()
  {
    return this->fc_.get ();
  }

  void tFCCB::
  fc (const fc_type& x)
  {
    this->fc_.set (x);
  }

  void tFCCB::
  fc (::std::auto_ptr< fc_type > x)
  {
    this->fc_.set (x);
  }


  // tControl
  // 

  const tControl::datSet_optional& tControl::
  datSet () const
  {
    return this->datSet_;
  }

  tControl::datSet_optional& tControl::
  datSet ()
  {
    return this->datSet_;
  }

  void tControl::
  datSet (const datSet_type& x)
  {
    this->datSet_.set (x);
  }

  void tControl::
  datSet (const datSet_optional& x)
  {
    this->datSet_ = x;
  }

  void tControl::
  datSet (::std::auto_ptr< datSet_type > x)
  {
    this->datSet_.set (x);
  }


  // tControlWithTriggerOpt
  // 

  const tControlWithTriggerOpt::TrgOps_optional& tControlWithTriggerOpt::
  TrgOps () const
  {
    return this->TrgOps_;
  }

  tControlWithTriggerOpt::TrgOps_optional& tControlWithTriggerOpt::
  TrgOps ()
  {
    return this->TrgOps_;
  }

  void tControlWithTriggerOpt::
  TrgOps (const TrgOps_type& x)
  {
    this->TrgOps_.set (x);
  }

  void tControlWithTriggerOpt::
  TrgOps (const TrgOps_optional& x)
  {
    this->TrgOps_ = x;
  }

  void tControlWithTriggerOpt::
  TrgOps (::std::auto_ptr< TrgOps_type > x)
  {
    this->TrgOps_.set (x);
  }

  const tControlWithTriggerOpt::intgPd_type& tControlWithTriggerOpt::
  intgPd () const
  {
    return this->intgPd_.get ();
  }

  tControlWithTriggerOpt::intgPd_type& tControlWithTriggerOpt::
  intgPd ()
  {
    return this->intgPd_.get ();
  }

  void tControlWithTriggerOpt::
  intgPd (const intgPd_type& x)
  {
    this->intgPd_.set (x);
  }

  tControlWithTriggerOpt::intgPd_type tControlWithTriggerOpt::
  intgPd_default_value ()
  {
    return intgPd_type (0U);
  }


  // tTrgOps
  // 

  const tTrgOps::dchg_type& tTrgOps::
  dchg () const
  {
    return this->dchg_.get ();
  }

  tTrgOps::dchg_type& tTrgOps::
  dchg ()
  {
    return this->dchg_.get ();
  }

  void tTrgOps::
  dchg (const dchg_type& x)
  {
    this->dchg_.set (x);
  }

  tTrgOps::dchg_type tTrgOps::
  dchg_default_value ()
  {
    return dchg_type (false);
  }

  const tTrgOps::qchg_type& tTrgOps::
  qchg () const
  {
    return this->qchg_.get ();
  }

  tTrgOps::qchg_type& tTrgOps::
  qchg ()
  {
    return this->qchg_.get ();
  }

  void tTrgOps::
  qchg (const qchg_type& x)
  {
    this->qchg_.set (x);
  }

  tTrgOps::qchg_type tTrgOps::
  qchg_default_value ()
  {
    return qchg_type (false);
  }

  const tTrgOps::dupd_type& tTrgOps::
  dupd () const
  {
    return this->dupd_.get ();
  }

  tTrgOps::dupd_type& tTrgOps::
  dupd ()
  {
    return this->dupd_.get ();
  }

  void tTrgOps::
  dupd (const dupd_type& x)
  {
    this->dupd_.set (x);
  }

  tTrgOps::dupd_type tTrgOps::
  dupd_default_value ()
  {
    return dupd_type (false);
  }

  const tTrgOps::period_type& tTrgOps::
  period () const
  {
    return this->period_.get ();
  }

  tTrgOps::period_type& tTrgOps::
  period ()
  {
    return this->period_.get ();
  }

  void tTrgOps::
  period (const period_type& x)
  {
    this->period_.set (x);
  }

  tTrgOps::period_type tTrgOps::
  period_default_value ()
  {
    return period_type (false);
  }


  // tReportControl
  // 

  const tReportControl::OptFields_type& tReportControl::
  OptFields () const
  {
    return this->OptFields_.get ();
  }

  tReportControl::OptFields_type& tReportControl::
  OptFields ()
  {
    return this->OptFields_.get ();
  }

  void tReportControl::
  OptFields (const OptFields_type& x)
  {
    this->OptFields_.set (x);
  }

  void tReportControl::
  OptFields (::std::auto_ptr< OptFields_type > x)
  {
    this->OptFields_.set (x);
  }

  const tReportControl::RptEnabled_optional& tReportControl::
  RptEnabled () const
  {
    return this->RptEnabled_;
  }

  tReportControl::RptEnabled_optional& tReportControl::
  RptEnabled ()
  {
    return this->RptEnabled_;
  }

  void tReportControl::
  RptEnabled (const RptEnabled_type& x)
  {
    this->RptEnabled_.set (x);
  }

  void tReportControl::
  RptEnabled (const RptEnabled_optional& x)
  {
    this->RptEnabled_ = x;
  }

  void tReportControl::
  RptEnabled (::std::auto_ptr< RptEnabled_type > x)
  {
    this->RptEnabled_.set (x);
  }

  const tReportControl::rptID_type& tReportControl::
  rptID () const
  {
    return this->rptID_.get ();
  }

  tReportControl::rptID_type& tReportControl::
  rptID ()
  {
    return this->rptID_.get ();
  }

  void tReportControl::
  rptID (const rptID_type& x)
  {
    this->rptID_.set (x);
  }

  void tReportControl::
  rptID (::std::auto_ptr< rptID_type > x)
  {
    this->rptID_.set (x);
  }

  const tReportControl::confRev_type& tReportControl::
  confRev () const
  {
    return this->confRev_.get ();
  }

  tReportControl::confRev_type& tReportControl::
  confRev ()
  {
    return this->confRev_.get ();
  }

  void tReportControl::
  confRev (const confRev_type& x)
  {
    this->confRev_.set (x);
  }

  const tReportControl::buffered_type& tReportControl::
  buffered () const
  {
    return this->buffered_.get ();
  }

  tReportControl::buffered_type& tReportControl::
  buffered ()
  {
    return this->buffered_.get ();
  }

  void tReportControl::
  buffered (const buffered_type& x)
  {
    this->buffered_.set (x);
  }

  tReportControl::buffered_type tReportControl::
  buffered_default_value ()
  {
    return buffered_type (false);
  }

  const tReportControl::bufTime_type& tReportControl::
  bufTime () const
  {
    return this->bufTime_.get ();
  }

  tReportControl::bufTime_type& tReportControl::
  bufTime ()
  {
    return this->bufTime_.get ();
  }

  void tReportControl::
  bufTime (const bufTime_type& x)
  {
    this->bufTime_.set (x);
  }

  tReportControl::bufTime_type tReportControl::
  bufTime_default_value ()
  {
    return bufTime_type (0U);
  }


  // tRptEnabled
  // 

  const tRptEnabled::ClientLN_sequence& tRptEnabled::
  ClientLN () const
  {
    return this->ClientLN_;
  }

  tRptEnabled::ClientLN_sequence& tRptEnabled::
  ClientLN ()
  {
    return this->ClientLN_;
  }

  void tRptEnabled::
  ClientLN (const ClientLN_sequence& s)
  {
    this->ClientLN_ = s;
  }

  const tRptEnabled::max_type& tRptEnabled::
  max () const
  {
    return this->max_.get ();
  }

  tRptEnabled::max_type& tRptEnabled::
  max ()
  {
    return this->max_.get ();
  }

  void tRptEnabled::
  max (const max_type& x)
  {
    this->max_.set (x);
  }

  tRptEnabled::max_type tRptEnabled::
  max_default_value ()
  {
    return max_type (1U);
  }


  // tClientLN
  // 

  const tClientLN::iedName_type& tClientLN::
  iedName () const
  {
    return this->iedName_.get ();
  }

  tClientLN::iedName_type& tClientLN::
  iedName ()
  {
    return this->iedName_.get ();
  }

  void tClientLN::
  iedName (const iedName_type& x)
  {
    this->iedName_.set (x);
  }

  void tClientLN::
  iedName (::std::auto_ptr< iedName_type > x)
  {
    this->iedName_.set (x);
  }

  const tClientLN::ldInst_type& tClientLN::
  ldInst () const
  {
    return this->ldInst_.get ();
  }

  tClientLN::ldInst_type& tClientLN::
  ldInst ()
  {
    return this->ldInst_.get ();
  }

  void tClientLN::
  ldInst (const ldInst_type& x)
  {
    this->ldInst_.set (x);
  }

  void tClientLN::
  ldInst (::std::auto_ptr< ldInst_type > x)
  {
    this->ldInst_.set (x);
  }

  const tClientLN::prefix_optional& tClientLN::
  prefix () const
  {
    return this->prefix_;
  }

  tClientLN::prefix_optional& tClientLN::
  prefix ()
  {
    return this->prefix_;
  }

  void tClientLN::
  prefix (const prefix_type& x)
  {
    this->prefix_.set (x);
  }

  void tClientLN::
  prefix (const prefix_optional& x)
  {
    this->prefix_ = x;
  }

  void tClientLN::
  prefix (::std::auto_ptr< prefix_type > x)
  {
    this->prefix_.set (x);
  }

  const tClientLN::lnClass_type& tClientLN::
  lnClass () const
  {
    return this->lnClass_.get ();
  }

  tClientLN::lnClass_type& tClientLN::
  lnClass ()
  {
    return this->lnClass_.get ();
  }

  void tClientLN::
  lnClass (const lnClass_type& x)
  {
    this->lnClass_.set (x);
  }

  void tClientLN::
  lnClass (::std::auto_ptr< lnClass_type > x)
  {
    this->lnClass_.set (x);
  }

  const tClientLN::lnInst_type& tClientLN::
  lnInst () const
  {
    return this->lnInst_.get ();
  }

  tClientLN::lnInst_type& tClientLN::
  lnInst ()
  {
    return this->lnInst_.get ();
  }

  void tClientLN::
  lnInst (const lnInst_type& x)
  {
    this->lnInst_.set (x);
  }

  void tClientLN::
  lnInst (::std::auto_ptr< lnInst_type > x)
  {
    this->lnInst_.set (x);
  }


  // tLogControl
  // 

  const tLogControl::logName_type& tLogControl::
  logName () const
  {
    return this->logName_.get ();
  }

  tLogControl::logName_type& tLogControl::
  logName ()
  {
    return this->logName_.get ();
  }

  void tLogControl::
  logName (const logName_type& x)
  {
    this->logName_.set (x);
  }

  void tLogControl::
  logName (::std::auto_ptr< logName_type > x)
  {
    this->logName_.set (x);
  }

  const tLogControl::logEna_type& tLogControl::
  logEna () const
  {
    return this->logEna_.get ();
  }

  tLogControl::logEna_type& tLogControl::
  logEna ()
  {
    return this->logEna_.get ();
  }

  void tLogControl::
  logEna (const logEna_type& x)
  {
    this->logEna_.set (x);
  }

  tLogControl::logEna_type tLogControl::
  logEna_default_value ()
  {
    return logEna_type (true);
  }

  const tLogControl::reasonCode_type& tLogControl::
  reasonCode () const
  {
    return this->reasonCode_.get ();
  }

  tLogControl::reasonCode_type& tLogControl::
  reasonCode ()
  {
    return this->reasonCode_.get ();
  }

  void tLogControl::
  reasonCode (const reasonCode_type& x)
  {
    this->reasonCode_.set (x);
  }

  tLogControl::reasonCode_type tLogControl::
  reasonCode_default_value ()
  {
    return reasonCode_type (true);
  }


  // tInputs
  // 

  const tInputs::ExtRef_sequence& tInputs::
  ExtRef () const
  {
    return this->ExtRef_;
  }

  tInputs::ExtRef_sequence& tInputs::
  ExtRef ()
  {
    return this->ExtRef_;
  }

  void tInputs::
  ExtRef (const ExtRef_sequence& s)
  {
    this->ExtRef_ = s;
  }


  // tExtRef
  // 

  const tExtRef::iedName_type& tExtRef::
  iedName () const
  {
    return this->iedName_.get ();
  }

  tExtRef::iedName_type& tExtRef::
  iedName ()
  {
    return this->iedName_.get ();
  }

  void tExtRef::
  iedName (const iedName_type& x)
  {
    this->iedName_.set (x);
  }

  void tExtRef::
  iedName (::std::auto_ptr< iedName_type > x)
  {
    this->iedName_.set (x);
  }

  const tExtRef::ldInst_type& tExtRef::
  ldInst () const
  {
    return this->ldInst_.get ();
  }

  tExtRef::ldInst_type& tExtRef::
  ldInst ()
  {
    return this->ldInst_.get ();
  }

  void tExtRef::
  ldInst (const ldInst_type& x)
  {
    this->ldInst_.set (x);
  }

  void tExtRef::
  ldInst (::std::auto_ptr< ldInst_type > x)
  {
    this->ldInst_.set (x);
  }

  const tExtRef::prefix_optional& tExtRef::
  prefix () const
  {
    return this->prefix_;
  }

  tExtRef::prefix_optional& tExtRef::
  prefix ()
  {
    return this->prefix_;
  }

  void tExtRef::
  prefix (const prefix_type& x)
  {
    this->prefix_.set (x);
  }

  void tExtRef::
  prefix (const prefix_optional& x)
  {
    this->prefix_ = x;
  }

  void tExtRef::
  prefix (::std::auto_ptr< prefix_type > x)
  {
    this->prefix_.set (x);
  }

  const tExtRef::lnClass_type& tExtRef::
  lnClass () const
  {
    return this->lnClass_.get ();
  }

  tExtRef::lnClass_type& tExtRef::
  lnClass ()
  {
    return this->lnClass_.get ();
  }

  void tExtRef::
  lnClass (const lnClass_type& x)
  {
    this->lnClass_.set (x);
  }

  void tExtRef::
  lnClass (::std::auto_ptr< lnClass_type > x)
  {
    this->lnClass_.set (x);
  }

  const tExtRef::lnInst_type& tExtRef::
  lnInst () const
  {
    return this->lnInst_.get ();
  }

  tExtRef::lnInst_type& tExtRef::
  lnInst ()
  {
    return this->lnInst_.get ();
  }

  void tExtRef::
  lnInst (const lnInst_type& x)
  {
    this->lnInst_.set (x);
  }

  void tExtRef::
  lnInst (::std::auto_ptr< lnInst_type > x)
  {
    this->lnInst_.set (x);
  }

  const tExtRef::doName_type& tExtRef::
  doName () const
  {
    return this->doName_.get ();
  }

  tExtRef::doName_type& tExtRef::
  doName ()
  {
    return this->doName_.get ();
  }

  void tExtRef::
  doName (const doName_type& x)
  {
    this->doName_.set (x);
  }

  void tExtRef::
  doName (::std::auto_ptr< doName_type > x)
  {
    this->doName_.set (x);
  }

  const tExtRef::daName_optional& tExtRef::
  daName () const
  {
    return this->daName_;
  }

  tExtRef::daName_optional& tExtRef::
  daName ()
  {
    return this->daName_;
  }

  void tExtRef::
  daName (const daName_type& x)
  {
    this->daName_.set (x);
  }

  void tExtRef::
  daName (const daName_optional& x)
  {
    this->daName_ = x;
  }

  void tExtRef::
  daName (::std::auto_ptr< daName_type > x)
  {
    this->daName_.set (x);
  }

  const tExtRef::intAddr_optional& tExtRef::
  intAddr () const
  {
    return this->intAddr_;
  }

  tExtRef::intAddr_optional& tExtRef::
  intAddr ()
  {
    return this->intAddr_;
  }

  void tExtRef::
  intAddr (const intAddr_type& x)
  {
    this->intAddr_.set (x);
  }

  void tExtRef::
  intAddr (const intAddr_optional& x)
  {
    this->intAddr_ = x;
  }

  void tExtRef::
  intAddr (::std::auto_ptr< intAddr_type > x)
  {
    this->intAddr_.set (x);
  }


  // tLog
  // 


  // tControlWithIEDName
  // 

  const tControlWithIEDName::IEDName_sequence& tControlWithIEDName::
  IEDName () const
  {
    return this->IEDName_;
  }

  tControlWithIEDName::IEDName_sequence& tControlWithIEDName::
  IEDName ()
  {
    return this->IEDName_;
  }

  void tControlWithIEDName::
  IEDName (const IEDName_sequence& s)
  {
    this->IEDName_ = s;
  }

  const tControlWithIEDName::confRev_optional& tControlWithIEDName::
  confRev () const
  {
    return this->confRev_;
  }

  tControlWithIEDName::confRev_optional& tControlWithIEDName::
  confRev ()
  {
    return this->confRev_;
  }

  void tControlWithIEDName::
  confRev (const confRev_type& x)
  {
    this->confRev_.set (x);
  }

  void tControlWithIEDName::
  confRev (const confRev_optional& x)
  {
    this->confRev_ = x;
  }


  // tGSEControl
  // 

  const tGSEControl::type_type& tGSEControl::
  type () const
  {
    return this->type_.get ();
  }

  tGSEControl::type_type& tGSEControl::
  type ()
  {
    return this->type_.get ();
  }

  void tGSEControl::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void tGSEControl::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const tGSEControl::type_type& tGSEControl::
  type_default_value ()
  {
    return type_default_value_;
  }

  const tGSEControl::appID_type& tGSEControl::
  appID () const
  {
    return this->appID_.get ();
  }

  tGSEControl::appID_type& tGSEControl::
  appID ()
  {
    return this->appID_.get ();
  }

  void tGSEControl::
  appID (const appID_type& x)
  {
    this->appID_.set (x);
  }

  void tGSEControl::
  appID (::std::auto_ptr< appID_type > x)
  {
    this->appID_.set (x);
  }


  // tSampledValueControl
  // 

  const tSampledValueControl::SmvOpts_type& tSampledValueControl::
  SmvOpts () const
  {
    return this->SmvOpts_.get ();
  }

  tSampledValueControl::SmvOpts_type& tSampledValueControl::
  SmvOpts ()
  {
    return this->SmvOpts_.get ();
  }

  void tSampledValueControl::
  SmvOpts (const SmvOpts_type& x)
  {
    this->SmvOpts_.set (x);
  }

  void tSampledValueControl::
  SmvOpts (::std::auto_ptr< SmvOpts_type > x)
  {
    this->SmvOpts_.set (x);
  }

  const tSampledValueControl::smvID_type& tSampledValueControl::
  smvID () const
  {
    return this->smvID_.get ();
  }

  tSampledValueControl::smvID_type& tSampledValueControl::
  smvID ()
  {
    return this->smvID_.get ();
  }

  void tSampledValueControl::
  smvID (const smvID_type& x)
  {
    this->smvID_.set (x);
  }

  void tSampledValueControl::
  smvID (::std::auto_ptr< smvID_type > x)
  {
    this->smvID_.set (x);
  }

  const tSampledValueControl::multicast_type& tSampledValueControl::
  multicast () const
  {
    return this->multicast_.get ();
  }

  tSampledValueControl::multicast_type& tSampledValueControl::
  multicast ()
  {
    return this->multicast_.get ();
  }

  void tSampledValueControl::
  multicast (const multicast_type& x)
  {
    this->multicast_.set (x);
  }

  tSampledValueControl::multicast_type tSampledValueControl::
  multicast_default_value ()
  {
    return multicast_type (true);
  }

  const tSampledValueControl::smpRate_type& tSampledValueControl::
  smpRate () const
  {
    return this->smpRate_.get ();
  }

  tSampledValueControl::smpRate_type& tSampledValueControl::
  smpRate ()
  {
    return this->smpRate_.get ();
  }

  void tSampledValueControl::
  smpRate (const smpRate_type& x)
  {
    this->smpRate_.set (x);
  }

  const tSampledValueControl::nofASDU_type& tSampledValueControl::
  nofASDU () const
  {
    return this->nofASDU_.get ();
  }

  tSampledValueControl::nofASDU_type& tSampledValueControl::
  nofASDU ()
  {
    return this->nofASDU_.get ();
  }

  void tSampledValueControl::
  nofASDU (const nofASDU_type& x)
  {
    this->nofASDU_.set (x);
  }


  // tSettingControl
  // 

  const tSettingControl::numOfSGs_type& tSettingControl::
  numOfSGs () const
  {
    return this->numOfSGs_.get ();
  }

  tSettingControl::numOfSGs_type& tSettingControl::
  numOfSGs ()
  {
    return this->numOfSGs_.get ();
  }

  void tSettingControl::
  numOfSGs (const numOfSGs_type& x)
  {
    this->numOfSGs_.set (x);
  }

  const tSettingControl::actSG_type& tSettingControl::
  actSG () const
  {
    return this->actSG_.get ();
  }

  tSettingControl::actSG_type& tSettingControl::
  actSG ()
  {
    return this->actSG_.get ();
  }

  void tSettingControl::
  actSG (const actSG_type& x)
  {
    this->actSG_.set (x);
  }

  tSettingControl::actSG_type tSettingControl::
  actSG_default_value ()
  {
    return actSG_type (1U);
  }


  // tSCLControl
  // 


  // tDOI
  // 

  const tDOI::SDI_sequence& tDOI::
  SDI () const
  {
    return this->SDI_;
  }

  tDOI::SDI_sequence& tDOI::
  SDI ()
  {
    return this->SDI_;
  }

  void tDOI::
  SDI (const SDI_sequence& s)
  {
    this->SDI_ = s;
  }

  const tDOI::DAI_sequence& tDOI::
  DAI () const
  {
    return this->DAI_;
  }

  tDOI::DAI_sequence& tDOI::
  DAI ()
  {
    return this->DAI_;
  }

  void tDOI::
  DAI (const DAI_sequence& s)
  {
    this->DAI_ = s;
  }

  const tDOI::name_type& tDOI::
  name () const
  {
    return this->name_.get ();
  }

  tDOI::name_type& tDOI::
  name ()
  {
    return this->name_.get ();
  }

  void tDOI::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void tDOI::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const tDOI::ix_optional& tDOI::
  ix () const
  {
    return this->ix_;
  }

  tDOI::ix_optional& tDOI::
  ix ()
  {
    return this->ix_;
  }

  void tDOI::
  ix (const ix_type& x)
  {
    this->ix_.set (x);
  }

  void tDOI::
  ix (const ix_optional& x)
  {
    this->ix_ = x;
  }

  const tDOI::accessControl_optional& tDOI::
  accessControl () const
  {
    return this->accessControl_;
  }

  tDOI::accessControl_optional& tDOI::
  accessControl ()
  {
    return this->accessControl_;
  }

  void tDOI::
  accessControl (const accessControl_type& x)
  {
    this->accessControl_.set (x);
  }

  void tDOI::
  accessControl (const accessControl_optional& x)
  {
    this->accessControl_ = x;
  }

  void tDOI::
  accessControl (::std::auto_ptr< accessControl_type > x)
  {
    this->accessControl_.set (x);
  }


  // tSDI
  // 

  const tSDI::SDI_sequence& tSDI::
  SDI () const
  {
    return this->SDI_;
  }

  tSDI::SDI_sequence& tSDI::
  SDI ()
  {
    return this->SDI_;
  }

  void tSDI::
  SDI (const SDI_sequence& s)
  {
    this->SDI_ = s;
  }

  const tSDI::DAI_sequence& tSDI::
  DAI () const
  {
    return this->DAI_;
  }

  tSDI::DAI_sequence& tSDI::
  DAI ()
  {
    return this->DAI_;
  }

  void tSDI::
  DAI (const DAI_sequence& s)
  {
    this->DAI_ = s;
  }

  const tSDI::name_type& tSDI::
  name () const
  {
    return this->name_.get ();
  }

  tSDI::name_type& tSDI::
  name ()
  {
    return this->name_.get ();
  }

  void tSDI::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void tSDI::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const tSDI::ix_optional& tSDI::
  ix () const
  {
    return this->ix_;
  }

  tSDI::ix_optional& tSDI::
  ix ()
  {
    return this->ix_;
  }

  void tSDI::
  ix (const ix_type& x)
  {
    this->ix_.set (x);
  }

  void tSDI::
  ix (const ix_optional& x)
  {
    this->ix_ = x;
  }


  // tDAI
  // 

  const tDAI::Val_sequence& tDAI::
  Val () const
  {
    return this->Val_;
  }

  tDAI::Val_sequence& tDAI::
  Val ()
  {
    return this->Val_;
  }

  void tDAI::
  Val (const Val_sequence& s)
  {
    this->Val_ = s;
  }

  const tDAI::name_type& tDAI::
  name () const
  {
    return this->name_.get ();
  }

  tDAI::name_type& tDAI::
  name ()
  {
    return this->name_.get ();
  }

  void tDAI::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void tDAI::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const tDAI::sAddr_optional& tDAI::
  sAddr () const
  {
    return this->sAddr_;
  }

  tDAI::sAddr_optional& tDAI::
  sAddr ()
  {
    return this->sAddr_;
  }

  void tDAI::
  sAddr (const sAddr_type& x)
  {
    this->sAddr_.set (x);
  }

  void tDAI::
  sAddr (const sAddr_optional& x)
  {
    this->sAddr_ = x;
  }

  void tDAI::
  sAddr (::std::auto_ptr< sAddr_type > x)
  {
    this->sAddr_.set (x);
  }

  const tDAI::valKind_type& tDAI::
  valKind () const
  {
    return this->valKind_.get ();
  }

  tDAI::valKind_type& tDAI::
  valKind ()
  {
    return this->valKind_.get ();
  }

  void tDAI::
  valKind (const valKind_type& x)
  {
    this->valKind_.set (x);
  }

  void tDAI::
  valKind (::std::auto_ptr< valKind_type > x)
  {
    this->valKind_.set (x);
  }

  const tDAI::valKind_type& tDAI::
  valKind_default_value ()
  {
    return valKind_default_value_;
  }

  const tDAI::ix_optional& tDAI::
  ix () const
  {
    return this->ix_;
  }

  tDAI::ix_optional& tDAI::
  ix ()
  {
    return this->ix_;
  }

  void tDAI::
  ix (const ix_type& x)
  {
    this->ix_.set (x);
  }

  void tDAI::
  ix (const ix_optional& x)
  {
    this->ix_ = x;
  }


  // tServiceYesNo
  // 


  // tServiceWithMax
  // 

  const tServiceWithMax::max_type& tServiceWithMax::
  max () const
  {
    return this->max_.get ();
  }

  tServiceWithMax::max_type& tServiceWithMax::
  max ()
  {
    return this->max_.get ();
  }

  void tServiceWithMax::
  max (const max_type& x)
  {
    this->max_.set (x);
  }


  // tServiceWithMaxAndMaxAttributes
  // 

  const tServiceWithMaxAndMaxAttributes::maxAttributes_optional& tServiceWithMaxAndMaxAttributes::
  maxAttributes () const
  {
    return this->maxAttributes_;
  }

  tServiceWithMaxAndMaxAttributes::maxAttributes_optional& tServiceWithMaxAndMaxAttributes::
  maxAttributes ()
  {
    return this->maxAttributes_;
  }

  void tServiceWithMaxAndMaxAttributes::
  maxAttributes (const maxAttributes_type& x)
  {
    this->maxAttributes_.set (x);
  }

  void tServiceWithMaxAndMaxAttributes::
  maxAttributes (const maxAttributes_optional& x)
  {
    this->maxAttributes_ = x;
  }


  // tServiceWithMaxAndModify
  // 

  const tServiceWithMaxAndModify::modify_type& tServiceWithMaxAndModify::
  modify () const
  {
    return this->modify_.get ();
  }

  tServiceWithMaxAndModify::modify_type& tServiceWithMaxAndModify::
  modify ()
  {
    return this->modify_.get ();
  }

  void tServiceWithMaxAndModify::
  modify (const modify_type& x)
  {
    this->modify_.set (x);
  }

  tServiceWithMaxAndModify::modify_type tServiceWithMaxAndModify::
  modify_default_value ()
  {
    return modify_type (true);
  }


  // tServiceWithMaxAndMaxAttributesAndModify
  // 

  const tServiceWithMaxAndMaxAttributesAndModify::modify_type& tServiceWithMaxAndMaxAttributesAndModify::
  modify () const
  {
    return this->modify_.get ();
  }

  tServiceWithMaxAndMaxAttributesAndModify::modify_type& tServiceWithMaxAndMaxAttributesAndModify::
  modify ()
  {
    return this->modify_.get ();
  }

  void tServiceWithMaxAndMaxAttributesAndModify::
  modify (const modify_type& x)
  {
    this->modify_.set (x);
  }

  tServiceWithMaxAndMaxAttributesAndModify::modify_type tServiceWithMaxAndMaxAttributesAndModify::
  modify_default_value ()
  {
    return modify_type (true);
  }


  // tClientServices
  // 

  const tClientServices::goose_type& tClientServices::
  goose () const
  {
    return this->goose_.get ();
  }

  tClientServices::goose_type& tClientServices::
  goose ()
  {
    return this->goose_.get ();
  }

  void tClientServices::
  goose (const goose_type& x)
  {
    this->goose_.set (x);
  }

  tClientServices::goose_type tClientServices::
  goose_default_value ()
  {
    return goose_type (false);
  }

  const tClientServices::gsse_type& tClientServices::
  gsse () const
  {
    return this->gsse_.get ();
  }

  tClientServices::gsse_type& tClientServices::
  gsse ()
  {
    return this->gsse_.get ();
  }

  void tClientServices::
  gsse (const gsse_type& x)
  {
    this->gsse_.set (x);
  }

  tClientServices::gsse_type tClientServices::
  gsse_default_value ()
  {
    return gsse_type (false);
  }

  const tClientServices::bufReport_type& tClientServices::
  bufReport () const
  {
    return this->bufReport_.get ();
  }

  tClientServices::bufReport_type& tClientServices::
  bufReport ()
  {
    return this->bufReport_.get ();
  }

  void tClientServices::
  bufReport (const bufReport_type& x)
  {
    this->bufReport_.set (x);
  }

  tClientServices::bufReport_type tClientServices::
  bufReport_default_value ()
  {
    return bufReport_type (false);
  }

  const tClientServices::unbufReport_type& tClientServices::
  unbufReport () const
  {
    return this->unbufReport_.get ();
  }

  tClientServices::unbufReport_type& tClientServices::
  unbufReport ()
  {
    return this->unbufReport_.get ();
  }

  void tClientServices::
  unbufReport (const unbufReport_type& x)
  {
    this->unbufReport_.set (x);
  }

  tClientServices::unbufReport_type tClientServices::
  unbufReport_default_value ()
  {
    return unbufReport_type (false);
  }

  const tClientServices::readLog_type& tClientServices::
  readLog () const
  {
    return this->readLog_.get ();
  }

  tClientServices::readLog_type& tClientServices::
  readLog ()
  {
    return this->readLog_.get ();
  }

  void tClientServices::
  readLog (const readLog_type& x)
  {
    this->readLog_.set (x);
  }

  tClientServices::readLog_type tClientServices::
  readLog_default_value ()
  {
    return readLog_type (false);
  }


  // tServiceSettings
  // 

  const tServiceSettings::cbName_type& tServiceSettings::
  cbName () const
  {
    return this->cbName_.get ();
  }

  tServiceSettings::cbName_type& tServiceSettings::
  cbName ()
  {
    return this->cbName_.get ();
  }

  void tServiceSettings::
  cbName (const cbName_type& x)
  {
    this->cbName_.set (x);
  }

  void tServiceSettings::
  cbName (::std::auto_ptr< cbName_type > x)
  {
    this->cbName_.set (x);
  }

  const tServiceSettings::cbName_type& tServiceSettings::
  cbName_default_value ()
  {
    return cbName_default_value_;
  }

  const tServiceSettings::datSet_type& tServiceSettings::
  datSet () const
  {
    return this->datSet_.get ();
  }

  tServiceSettings::datSet_type& tServiceSettings::
  datSet ()
  {
    return this->datSet_.get ();
  }

  void tServiceSettings::
  datSet (const datSet_type& x)
  {
    this->datSet_.set (x);
  }

  void tServiceSettings::
  datSet (::std::auto_ptr< datSet_type > x)
  {
    this->datSet_.set (x);
  }

  const tServiceSettings::datSet_type& tServiceSettings::
  datSet_default_value ()
  {
    return datSet_default_value_;
  }


  // tReportSettings
  // 

  const tReportSettings::rptID_type& tReportSettings::
  rptID () const
  {
    return this->rptID_.get ();
  }

  tReportSettings::rptID_type& tReportSettings::
  rptID ()
  {
    return this->rptID_.get ();
  }

  void tReportSettings::
  rptID (const rptID_type& x)
  {
    this->rptID_.set (x);
  }

  void tReportSettings::
  rptID (::std::auto_ptr< rptID_type > x)
  {
    this->rptID_.set (x);
  }

  const tReportSettings::rptID_type& tReportSettings::
  rptID_default_value ()
  {
    return rptID_default_value_;
  }

  const tReportSettings::optFields_type& tReportSettings::
  optFields () const
  {
    return this->optFields_.get ();
  }

  tReportSettings::optFields_type& tReportSettings::
  optFields ()
  {
    return this->optFields_.get ();
  }

  void tReportSettings::
  optFields (const optFields_type& x)
  {
    this->optFields_.set (x);
  }

  void tReportSettings::
  optFields (::std::auto_ptr< optFields_type > x)
  {
    this->optFields_.set (x);
  }

  const tReportSettings::optFields_type& tReportSettings::
  optFields_default_value ()
  {
    return optFields_default_value_;
  }

  const tReportSettings::bufTime_type& tReportSettings::
  bufTime () const
  {
    return this->bufTime_.get ();
  }

  tReportSettings::bufTime_type& tReportSettings::
  bufTime ()
  {
    return this->bufTime_.get ();
  }

  void tReportSettings::
  bufTime (const bufTime_type& x)
  {
    this->bufTime_.set (x);
  }

  void tReportSettings::
  bufTime (::std::auto_ptr< bufTime_type > x)
  {
    this->bufTime_.set (x);
  }

  const tReportSettings::bufTime_type& tReportSettings::
  bufTime_default_value ()
  {
    return bufTime_default_value_;
  }

  const tReportSettings::trgOps_type& tReportSettings::
  trgOps () const
  {
    return this->trgOps_.get ();
  }

  tReportSettings::trgOps_type& tReportSettings::
  trgOps ()
  {
    return this->trgOps_.get ();
  }

  void tReportSettings::
  trgOps (const trgOps_type& x)
  {
    this->trgOps_.set (x);
  }

  void tReportSettings::
  trgOps (::std::auto_ptr< trgOps_type > x)
  {
    this->trgOps_.set (x);
  }

  const tReportSettings::trgOps_type& tReportSettings::
  trgOps_default_value ()
  {
    return trgOps_default_value_;
  }

  const tReportSettings::intgPd_type& tReportSettings::
  intgPd () const
  {
    return this->intgPd_.get ();
  }

  tReportSettings::intgPd_type& tReportSettings::
  intgPd ()
  {
    return this->intgPd_.get ();
  }

  void tReportSettings::
  intgPd (const intgPd_type& x)
  {
    this->intgPd_.set (x);
  }

  void tReportSettings::
  intgPd (::std::auto_ptr< intgPd_type > x)
  {
    this->intgPd_.set (x);
  }

  const tReportSettings::intgPd_type& tReportSettings::
  intgPd_default_value ()
  {
    return intgPd_default_value_;
  }


  // tLogSettings
  // 

  const tLogSettings::logEna_type& tLogSettings::
  logEna () const
  {
    return this->logEna_.get ();
  }

  tLogSettings::logEna_type& tLogSettings::
  logEna ()
  {
    return this->logEna_.get ();
  }

  void tLogSettings::
  logEna (const logEna_type& x)
  {
    this->logEna_.set (x);
  }

  void tLogSettings::
  logEna (::std::auto_ptr< logEna_type > x)
  {
    this->logEna_.set (x);
  }

  const tLogSettings::logEna_type& tLogSettings::
  logEna_default_value ()
  {
    return logEna_default_value_;
  }

  const tLogSettings::trgOps_type& tLogSettings::
  trgOps () const
  {
    return this->trgOps_.get ();
  }

  tLogSettings::trgOps_type& tLogSettings::
  trgOps ()
  {
    return this->trgOps_.get ();
  }

  void tLogSettings::
  trgOps (const trgOps_type& x)
  {
    this->trgOps_.set (x);
  }

  void tLogSettings::
  trgOps (::std::auto_ptr< trgOps_type > x)
  {
    this->trgOps_.set (x);
  }

  const tLogSettings::trgOps_type& tLogSettings::
  trgOps_default_value ()
  {
    return trgOps_default_value_;
  }

  const tLogSettings::intgPd_type& tLogSettings::
  intgPd () const
  {
    return this->intgPd_.get ();
  }

  tLogSettings::intgPd_type& tLogSettings::
  intgPd ()
  {
    return this->intgPd_.get ();
  }

  void tLogSettings::
  intgPd (const intgPd_type& x)
  {
    this->intgPd_.set (x);
  }

  void tLogSettings::
  intgPd (::std::auto_ptr< intgPd_type > x)
  {
    this->intgPd_.set (x);
  }

  const tLogSettings::intgPd_type& tLogSettings::
  intgPd_default_value ()
  {
    return intgPd_default_value_;
  }


  // tGSESettings
  // 

  const tGSESettings::appID_type& tGSESettings::
  appID () const
  {
    return this->appID_.get ();
  }

  tGSESettings::appID_type& tGSESettings::
  appID ()
  {
    return this->appID_.get ();
  }

  void tGSESettings::
  appID (const appID_type& x)
  {
    this->appID_.set (x);
  }

  void tGSESettings::
  appID (::std::auto_ptr< appID_type > x)
  {
    this->appID_.set (x);
  }

  const tGSESettings::appID_type& tGSESettings::
  appID_default_value ()
  {
    return appID_default_value_;
  }

  const tGSESettings::dataLabel_type& tGSESettings::
  dataLabel () const
  {
    return this->dataLabel_.get ();
  }

  tGSESettings::dataLabel_type& tGSESettings::
  dataLabel ()
  {
    return this->dataLabel_.get ();
  }

  void tGSESettings::
  dataLabel (const dataLabel_type& x)
  {
    this->dataLabel_.set (x);
  }

  void tGSESettings::
  dataLabel (::std::auto_ptr< dataLabel_type > x)
  {
    this->dataLabel_.set (x);
  }

  const tGSESettings::dataLabel_type& tGSESettings::
  dataLabel_default_value ()
  {
    return dataLabel_default_value_;
  }


  // tSMVSettings
  // 

  const tSMVSettings::SmpRate1_sequence& tSMVSettings::
  SmpRate1 () const
  {
    return this->SmpRate1_;
  }

  tSMVSettings::SmpRate1_sequence& tSMVSettings::
  SmpRate1 ()
  {
    return this->SmpRate1_;
  }

  void tSMVSettings::
  SmpRate1 (const SmpRate1_sequence& s)
  {
    this->SmpRate1_ = s;
  }

  const tSMVSettings::svID_type& tSMVSettings::
  svID () const
  {
    return this->svID_.get ();
  }

  tSMVSettings::svID_type& tSMVSettings::
  svID ()
  {
    return this->svID_.get ();
  }

  void tSMVSettings::
  svID (const svID_type& x)
  {
    this->svID_.set (x);
  }

  void tSMVSettings::
  svID (::std::auto_ptr< svID_type > x)
  {
    this->svID_.set (x);
  }

  const tSMVSettings::svID_type& tSMVSettings::
  svID_default_value ()
  {
    return svID_default_value_;
  }

  const tSMVSettings::optFields_type& tSMVSettings::
  optFields () const
  {
    return this->optFields_.get ();
  }

  tSMVSettings::optFields_type& tSMVSettings::
  optFields ()
  {
    return this->optFields_.get ();
  }

  void tSMVSettings::
  optFields (const optFields_type& x)
  {
    this->optFields_.set (x);
  }

  void tSMVSettings::
  optFields (::std::auto_ptr< optFields_type > x)
  {
    this->optFields_.set (x);
  }

  const tSMVSettings::optFields_type& tSMVSettings::
  optFields_default_value ()
  {
    return optFields_default_value_;
  }

  const tSMVSettings::smpRate2_type& tSMVSettings::
  smpRate2 () const
  {
    return this->smpRate2_.get ();
  }

  tSMVSettings::smpRate2_type& tSMVSettings::
  smpRate2 ()
  {
    return this->smpRate2_.get ();
  }

  void tSMVSettings::
  smpRate2 (const smpRate2_type& x)
  {
    this->smpRate2_.set (x);
  }

  void tSMVSettings::
  smpRate2 (::std::auto_ptr< smpRate2_type > x)
  {
    this->smpRate2_.set (x);
  }

  const tSMVSettings::smpRate2_type& tSMVSettings::
  smpRate2_default_value ()
  {
    return smpRate2_default_value_;
  }


  // tConfLNs
  // 

  const tConfLNs::fixPrefix_type& tConfLNs::
  fixPrefix () const
  {
    return this->fixPrefix_.get ();
  }

  tConfLNs::fixPrefix_type& tConfLNs::
  fixPrefix ()
  {
    return this->fixPrefix_.get ();
  }

  void tConfLNs::
  fixPrefix (const fixPrefix_type& x)
  {
    this->fixPrefix_.set (x);
  }

  tConfLNs::fixPrefix_type tConfLNs::
  fixPrefix_default_value ()
  {
    return fixPrefix_type (false);
  }

  const tConfLNs::fixLnInst_type& tConfLNs::
  fixLnInst () const
  {
    return this->fixLnInst_.get ();
  }

  tConfLNs::fixLnInst_type& tConfLNs::
  fixLnInst ()
  {
    return this->fixLnInst_.get ();
  }

  void tConfLNs::
  fixLnInst (const fixLnInst_type& x)
  {
    this->fixLnInst_.set (x);
  }

  tConfLNs::fixLnInst_type tConfLNs::
  fixLnInst_default_value ()
  {
    return fixLnInst_type (false);
  }


  // SettingGroups
  // 

  const SettingGroups::SGEdit_optional& SettingGroups::
  SGEdit () const
  {
    return this->SGEdit_;
  }

  SettingGroups::SGEdit_optional& SettingGroups::
  SGEdit ()
  {
    return this->SGEdit_;
  }

  void SettingGroups::
  SGEdit (const SGEdit_type& x)
  {
    this->SGEdit_.set (x);
  }

  void SettingGroups::
  SGEdit (const SGEdit_optional& x)
  {
    this->SGEdit_ = x;
  }

  void SettingGroups::
  SGEdit (::std::auto_ptr< SGEdit_type > x)
  {
    this->SGEdit_.set (x);
  }

  const SettingGroups::ConfSG_optional& SettingGroups::
  ConfSG () const
  {
    return this->ConfSG_;
  }

  SettingGroups::ConfSG_optional& SettingGroups::
  ConfSG ()
  {
    return this->ConfSG_;
  }

  void SettingGroups::
  ConfSG (const ConfSG_type& x)
  {
    this->ConfSG_.set (x);
  }

  void SettingGroups::
  ConfSG (const ConfSG_optional& x)
  {
    this->ConfSG_ = x;
  }

  void SettingGroups::
  ConfSG (::std::auto_ptr< ConfSG_type > x)
  {
    this->ConfSG_.set (x);
  }


  // Authentication
  // 

  const Authentication::none_type& Authentication::
  none () const
  {
    return this->none_.get ();
  }

  Authentication::none_type& Authentication::
  none ()
  {
    return this->none_.get ();
  }

  void Authentication::
  none (const none_type& x)
  {
    this->none_.set (x);
  }

  Authentication::none_type Authentication::
  none_default_value ()
  {
    return none_type (true);
  }

  const Authentication::password_type& Authentication::
  password () const
  {
    return this->password_.get ();
  }

  Authentication::password_type& Authentication::
  password ()
  {
    return this->password_.get ();
  }

  void Authentication::
  password (const password_type& x)
  {
    this->password_.set (x);
  }

  Authentication::password_type Authentication::
  password_default_value ()
  {
    return password_type (false);
  }

  const Authentication::weak_type& Authentication::
  weak () const
  {
    return this->weak_.get ();
  }

  Authentication::weak_type& Authentication::
  weak ()
  {
    return this->weak_.get ();
  }

  void Authentication::
  weak (const weak_type& x)
  {
    this->weak_.set (x);
  }

  Authentication::weak_type Authentication::
  weak_default_value ()
  {
    return weak_type (false);
  }

  const Authentication::strong_type& Authentication::
  strong () const
  {
    return this->strong_.get ();
  }

  Authentication::strong_type& Authentication::
  strong ()
  {
    return this->strong_.get ();
  }

  void Authentication::
  strong (const strong_type& x)
  {
    this->strong_.set (x);
  }

  Authentication::strong_type Authentication::
  strong_default_value ()
  {
    return strong_type (false);
  }

  const Authentication::certificate_type& Authentication::
  certificate () const
  {
    return this->certificate_.get ();
  }

  Authentication::certificate_type& Authentication::
  certificate ()
  {
    return this->certificate_.get ();
  }

  void Authentication::
  certificate (const certificate_type& x)
  {
    this->certificate_.set (x);
  }

  Authentication::certificate_type Authentication::
  certificate_default_value ()
  {
    return certificate_type (false);
  }


  // LN0
  // 


  // OptFields
  // 

  const OptFields::seqNum_type& OptFields::
  seqNum () const
  {
    return this->seqNum_.get ();
  }

  OptFields::seqNum_type& OptFields::
  seqNum ()
  {
    return this->seqNum_.get ();
  }

  void OptFields::
  seqNum (const seqNum_type& x)
  {
    this->seqNum_.set (x);
  }

  OptFields::seqNum_type OptFields::
  seqNum_default_value ()
  {
    return seqNum_type (false);
  }

  const OptFields::timeStamp_type& OptFields::
  timeStamp () const
  {
    return this->timeStamp_.get ();
  }

  OptFields::timeStamp_type& OptFields::
  timeStamp ()
  {
    return this->timeStamp_.get ();
  }

  void OptFields::
  timeStamp (const timeStamp_type& x)
  {
    this->timeStamp_.set (x);
  }

  OptFields::timeStamp_type OptFields::
  timeStamp_default_value ()
  {
    return timeStamp_type (false);
  }

  const OptFields::dataSet_type& OptFields::
  dataSet () const
  {
    return this->dataSet_.get ();
  }

  OptFields::dataSet_type& OptFields::
  dataSet ()
  {
    return this->dataSet_.get ();
  }

  void OptFields::
  dataSet (const dataSet_type& x)
  {
    this->dataSet_.set (x);
  }

  OptFields::dataSet_type OptFields::
  dataSet_default_value ()
  {
    return dataSet_type (false);
  }

  const OptFields::reasonCode_type& OptFields::
  reasonCode () const
  {
    return this->reasonCode_.get ();
  }

  OptFields::reasonCode_type& OptFields::
  reasonCode ()
  {
    return this->reasonCode_.get ();
  }

  void OptFields::
  reasonCode (const reasonCode_type& x)
  {
    this->reasonCode_.set (x);
  }

  OptFields::reasonCode_type OptFields::
  reasonCode_default_value ()
  {
    return reasonCode_type (false);
  }

  const OptFields::dataRef_type& OptFields::
  dataRef () const
  {
    return this->dataRef_.get ();
  }

  OptFields::dataRef_type& OptFields::
  dataRef ()
  {
    return this->dataRef_.get ();
  }

  void OptFields::
  dataRef (const dataRef_type& x)
  {
    this->dataRef_.set (x);
  }

  OptFields::dataRef_type OptFields::
  dataRef_default_value ()
  {
    return dataRef_type (false);
  }

  const OptFields::bufOvfl_type& OptFields::
  bufOvfl () const
  {
    return this->bufOvfl_.get ();
  }

  OptFields::bufOvfl_type& OptFields::
  bufOvfl ()
  {
    return this->bufOvfl_.get ();
  }

  void OptFields::
  bufOvfl (const bufOvfl_type& x)
  {
    this->bufOvfl_.set (x);
  }

  OptFields::bufOvfl_type OptFields::
  bufOvfl_default_value ()
  {
    return bufOvfl_type (false);
  }

  const OptFields::entryID_type& OptFields::
  entryID () const
  {
    return this->entryID_.get ();
  }

  OptFields::entryID_type& OptFields::
  entryID ()
  {
    return this->entryID_.get ();
  }

  void OptFields::
  entryID (const entryID_type& x)
  {
    this->entryID_.set (x);
  }

  OptFields::entryID_type OptFields::
  entryID_default_value ()
  {
    return entryID_type (false);
  }

  const OptFields::configRef_type& OptFields::
  configRef () const
  {
    return this->configRef_.get ();
  }

  OptFields::configRef_type& OptFields::
  configRef ()
  {
    return this->configRef_.get ();
  }

  void OptFields::
  configRef (const configRef_type& x)
  {
    this->configRef_.set (x);
  }

  OptFields::configRef_type OptFields::
  configRef_default_value ()
  {
    return configRef_type (false);
  }


  // SmvOpts
  // 

  const SmvOpts::refreshTime_type& SmvOpts::
  refreshTime () const
  {
    return this->refreshTime_.get ();
  }

  SmvOpts::refreshTime_type& SmvOpts::
  refreshTime ()
  {
    return this->refreshTime_.get ();
  }

  void SmvOpts::
  refreshTime (const refreshTime_type& x)
  {
    this->refreshTime_.set (x);
  }

  SmvOpts::refreshTime_type SmvOpts::
  refreshTime_default_value ()
  {
    return refreshTime_type (false);
  }

  const SmvOpts::sampleSynchronized_type& SmvOpts::
  sampleSynchronized () const
  {
    return this->sampleSynchronized_.get ();
  }

  SmvOpts::sampleSynchronized_type SmvOpts::
  sampleSynchronized_default_value ()
  {
    return sampleSynchronized_type (true);
  }

  const SmvOpts::sampleRate_type& SmvOpts::
  sampleRate () const
  {
    return this->sampleRate_.get ();
  }

  SmvOpts::sampleRate_type& SmvOpts::
  sampleRate ()
  {
    return this->sampleRate_.get ();
  }

  void SmvOpts::
  sampleRate (const sampleRate_type& x)
  {
    this->sampleRate_.set (x);
  }

  SmvOpts::sampleRate_type SmvOpts::
  sampleRate_default_value ()
  {
    return sampleRate_type (false);
  }

  const SmvOpts::dataSet_type& SmvOpts::
  dataSet () const
  {
    return this->dataSet_.get ();
  }

  SmvOpts::dataSet_type& SmvOpts::
  dataSet ()
  {
    return this->dataSet_.get ();
  }

  void SmvOpts::
  dataSet (const dataSet_type& x)
  {
    this->dataSet_.set (x);
  }

  SmvOpts::dataSet_type SmvOpts::
  dataSet_default_value ()
  {
    return dataSet_type (false);
  }

  const SmvOpts::security_type& SmvOpts::
  security () const
  {
    return this->security_.get ();
  }

  SmvOpts::security_type& SmvOpts::
  security ()
  {
    return this->security_.get ();
  }

  void SmvOpts::
  security (const security_type& x)
  {
    this->security_.set (x);
  }

  SmvOpts::security_type SmvOpts::
  security_default_value ()
  {
    return security_type (false);
  }


  // SmpRate1
  // 
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace SCL
{
  // tIED
  //

  tIED::
  tIED (const name_type& name)
  : ::SCL::tNaming (name),
    Services_ (this),
    AccessPoint_ (this),
    type_ (this),
    manufacturer_ (this),
    configVersion_ (this)
  {
  }

  tIED::
  tIED (const tIED& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::SCL::tNaming (x, f, c),
    Services_ (x.Services_, f, this),
    AccessPoint_ (x.AccessPoint_, f, this),
    type_ (x.type_, f, this),
    manufacturer_ (x.manufacturer_, f, this),
    configVersion_ (x.configVersion_, f, this)
  {
  }

  tIED::
  tIED (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::SCL::tNaming (e, f | ::xml_schema::flags::base, c),
    Services_ (this),
    AccessPoint_ (this),
    type_ (this),
    manufacturer_ (this),
    configVersion_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tIED::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tNaming::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Services
      //
      if (n.name () == "Services" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< Services_type > r (
          Services_traits::create (i, f, this));

        if (!this->Services_)
        {
          this->Services_.set (r);
          continue;
        }
      }

      // AccessPoint
      //
      if (n.name () == "AccessPoint" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< AccessPoint_type > r (
          AccessPoint_traits::create (i, f, this));

        this->AccessPoint_.push_back (r);
        continue;
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "manufacturer" && n.namespace_ ().empty ())
      {
        this->manufacturer_.set (manufacturer_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "configVersion" && n.namespace_ ().empty ())
      {
        this->configVersion_.set (configVersion_traits::create (i, f, this));
        continue;
      }
    }
  }

  tIED* tIED::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tIED (*this, f, c);
  }

  tIED& tIED::
  operator= (const tIED& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tNaming& > (*this) = x;
      this->Services_ = x.Services_;
      this->AccessPoint_ = x.AccessPoint_;
      this->type_ = x.type_;
      this->manufacturer_ = x.manufacturer_;
      this->configVersion_ = x.configVersion_;
    }

    return *this;
  }

  tIED::
  ~tIED ()
  {
  }

  // tServices
  //

  tServices::
  tServices ()
  : ::xml_schema::type (),
    DynAssociation_ (this),
    SettingGroups_ (this),
    GetDirectory_ (this),
    GetDataObjectDefinition_ (this),
    DataObjectDirectory_ (this),
    GetDataSetValue_ (this),
    SetDataSetValue_ (this),
    DataSetDirectory_ (this),
    ConfDataSet_ (this),
    DynDataSet_ (this),
    ReadWrite_ (this),
    TimerActivatedControl_ (this),
    ConfReportControl_ (this),
    GetCBValues_ (this),
    ConfLogControl_ (this),
    ReportSettings_ (this),
    LogSettings_ (this),
    GSESettings_ (this),
    SMVSettings_ (this),
    GSEDir_ (this),
    GOOSE_ (this),
    GSSE_ (this),
    FileHandling_ (this),
    ConfLNs_ (this),
    ClientServices_ (this)
  {
  }

  tServices::
  tServices (const tServices& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    DynAssociation_ (x.DynAssociation_, f, this),
    SettingGroups_ (x.SettingGroups_, f, this),
    GetDirectory_ (x.GetDirectory_, f, this),
    GetDataObjectDefinition_ (x.GetDataObjectDefinition_, f, this),
    DataObjectDirectory_ (x.DataObjectDirectory_, f, this),
    GetDataSetValue_ (x.GetDataSetValue_, f, this),
    SetDataSetValue_ (x.SetDataSetValue_, f, this),
    DataSetDirectory_ (x.DataSetDirectory_, f, this),
    ConfDataSet_ (x.ConfDataSet_, f, this),
    DynDataSet_ (x.DynDataSet_, f, this),
    ReadWrite_ (x.ReadWrite_, f, this),
    TimerActivatedControl_ (x.TimerActivatedControl_, f, this),
    ConfReportControl_ (x.ConfReportControl_, f, this),
    GetCBValues_ (x.GetCBValues_, f, this),
    ConfLogControl_ (x.ConfLogControl_, f, this),
    ReportSettings_ (x.ReportSettings_, f, this),
    LogSettings_ (x.LogSettings_, f, this),
    GSESettings_ (x.GSESettings_, f, this),
    SMVSettings_ (x.SMVSettings_, f, this),
    GSEDir_ (x.GSEDir_, f, this),
    GOOSE_ (x.GOOSE_, f, this),
    GSSE_ (x.GSSE_, f, this),
    FileHandling_ (x.FileHandling_, f, this),
    ConfLNs_ (x.ConfLNs_, f, this),
    ClientServices_ (x.ClientServices_, f, this)
  {
  }

  tServices::
  tServices (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    DynAssociation_ (this),
    SettingGroups_ (this),
    GetDirectory_ (this),
    GetDataObjectDefinition_ (this),
    DataObjectDirectory_ (this),
    GetDataSetValue_ (this),
    SetDataSetValue_ (this),
    DataSetDirectory_ (this),
    ConfDataSet_ (this),
    DynDataSet_ (this),
    ReadWrite_ (this),
    TimerActivatedControl_ (this),
    ConfReportControl_ (this),
    GetCBValues_ (this),
    ConfLogControl_ (this),
    ReportSettings_ (this),
    LogSettings_ (this),
    GSESettings_ (this),
    SMVSettings_ (this),
    GSEDir_ (this),
    GOOSE_ (this),
    GSSE_ (this),
    FileHandling_ (this),
    ConfLNs_ (this),
    ClientServices_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void tServices::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DynAssociation
      //
      if (n.name () == "DynAssociation" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< DynAssociation_type > r (
          DynAssociation_traits::create (i, f, this));

        if (!this->DynAssociation_)
        {
          this->DynAssociation_.set (r);
          continue;
        }
      }

      // SettingGroups
      //
      if (n.name () == "SettingGroups" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< SettingGroups_type > r (
          SettingGroups_traits::create (i, f, this));

        if (!this->SettingGroups_)
        {
          this->SettingGroups_.set (r);
          continue;
        }
      }

      // GetDirectory
      //
      if (n.name () == "GetDirectory" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< GetDirectory_type > r (
          GetDirectory_traits::create (i, f, this));

        if (!this->GetDirectory_)
        {
          this->GetDirectory_.set (r);
          continue;
        }
      }

      // GetDataObjectDefinition
      //
      if (n.name () == "GetDataObjectDefinition" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< GetDataObjectDefinition_type > r (
          GetDataObjectDefinition_traits::create (i, f, this));

        if (!this->GetDataObjectDefinition_)
        {
          this->GetDataObjectDefinition_.set (r);
          continue;
        }
      }

      // DataObjectDirectory
      //
      if (n.name () == "DataObjectDirectory" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< DataObjectDirectory_type > r (
          DataObjectDirectory_traits::create (i, f, this));

        if (!this->DataObjectDirectory_)
        {
          this->DataObjectDirectory_.set (r);
          continue;
        }
      }

      // GetDataSetValue
      //
      if (n.name () == "GetDataSetValue" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< GetDataSetValue_type > r (
          GetDataSetValue_traits::create (i, f, this));

        if (!this->GetDataSetValue_)
        {
          this->GetDataSetValue_.set (r);
          continue;
        }
      }

      // SetDataSetValue
      //
      if (n.name () == "SetDataSetValue" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< SetDataSetValue_type > r (
          SetDataSetValue_traits::create (i, f, this));

        if (!this->SetDataSetValue_)
        {
          this->SetDataSetValue_.set (r);
          continue;
        }
      }

      // DataSetDirectory
      //
      if (n.name () == "DataSetDirectory" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< DataSetDirectory_type > r (
          DataSetDirectory_traits::create (i, f, this));

        if (!this->DataSetDirectory_)
        {
          this->DataSetDirectory_.set (r);
          continue;
        }
      }

      // ConfDataSet
      //
      if (n.name () == "ConfDataSet" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< ConfDataSet_type > r (
          ConfDataSet_traits::create (i, f, this));

        if (!this->ConfDataSet_)
        {
          this->ConfDataSet_.set (r);
          continue;
        }
      }

      // DynDataSet
      //
      if (n.name () == "DynDataSet" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< DynDataSet_type > r (
          DynDataSet_traits::create (i, f, this));

        if (!this->DynDataSet_)
        {
          this->DynDataSet_.set (r);
          continue;
        }
      }

      // ReadWrite
      //
      if (n.name () == "ReadWrite" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< ReadWrite_type > r (
          ReadWrite_traits::create (i, f, this));

        if (!this->ReadWrite_)
        {
          this->ReadWrite_.set (r);
          continue;
        }
      }

      // TimerActivatedControl
      //
      if (n.name () == "TimerActivatedControl" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< TimerActivatedControl_type > r (
          TimerActivatedControl_traits::create (i, f, this));

        if (!this->TimerActivatedControl_)
        {
          this->TimerActivatedControl_.set (r);
          continue;
        }
      }

      // ConfReportControl
      //
      if (n.name () == "ConfReportControl" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< ConfReportControl_type > r (
          ConfReportControl_traits::create (i, f, this));

        if (!this->ConfReportControl_)
        {
          this->ConfReportControl_.set (r);
          continue;
        }
      }

      // GetCBValues
      //
      if (n.name () == "GetCBValues" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< GetCBValues_type > r (
          GetCBValues_traits::create (i, f, this));

        if (!this->GetCBValues_)
        {
          this->GetCBValues_.set (r);
          continue;
        }
      }

      // ConfLogControl
      //
      if (n.name () == "ConfLogControl" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< ConfLogControl_type > r (
          ConfLogControl_traits::create (i, f, this));

        if (!this->ConfLogControl_)
        {
          this->ConfLogControl_.set (r);
          continue;
        }
      }

      // ReportSettings
      //
      if (n.name () == "ReportSettings" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< ReportSettings_type > r (
          ReportSettings_traits::create (i, f, this));

        if (!this->ReportSettings_)
        {
          this->ReportSettings_.set (r);
          continue;
        }
      }

      // LogSettings
      //
      if (n.name () == "LogSettings" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< LogSettings_type > r (
          LogSettings_traits::create (i, f, this));

        if (!this->LogSettings_)
        {
          this->LogSettings_.set (r);
          continue;
        }
      }

      // GSESettings
      //
      if (n.name () == "GSESettings" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< GSESettings_type > r (
          GSESettings_traits::create (i, f, this));

        if (!this->GSESettings_)
        {
          this->GSESettings_.set (r);
          continue;
        }
      }

      // SMVSettings
      //
      if (n.name () == "SMVSettings" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< SMVSettings_type > r (
          SMVSettings_traits::create (i, f, this));

        if (!this->SMVSettings_)
        {
          this->SMVSettings_.set (r);
          continue;
        }
      }

      // GSEDir
      //
      if (n.name () == "GSEDir" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< GSEDir_type > r (
          GSEDir_traits::create (i, f, this));

        if (!this->GSEDir_)
        {
          this->GSEDir_.set (r);
          continue;
        }
      }

      // GOOSE
      //
      if (n.name () == "GOOSE" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< GOOSE_type > r (
          GOOSE_traits::create (i, f, this));

        if (!this->GOOSE_)
        {
          this->GOOSE_.set (r);
          continue;
        }
      }

      // GSSE
      //
      if (n.name () == "GSSE" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< GSSE_type > r (
          GSSE_traits::create (i, f, this));

        if (!this->GSSE_)
        {
          this->GSSE_.set (r);
          continue;
        }
      }

      // FileHandling
      //
      if (n.name () == "FileHandling" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< FileHandling_type > r (
          FileHandling_traits::create (i, f, this));

        if (!this->FileHandling_)
        {
          this->FileHandling_.set (r);
          continue;
        }
      }

      // ConfLNs
      //
      if (n.name () == "ConfLNs" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< ConfLNs_type > r (
          ConfLNs_traits::create (i, f, this));

        if (!this->ConfLNs_)
        {
          this->ConfLNs_.set (r);
          continue;
        }
      }

      // ClientServices
      //
      if (n.name () == "ClientServices" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< ClientServices_type > r (
          ClientServices_traits::create (i, f, this));

        if (!this->ClientServices_)
        {
          this->ClientServices_.set (r);
          continue;
        }
      }

      break;
    }
  }

  tServices* tServices::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tServices (*this, f, c);
  }

  tServices& tServices::
  operator= (const tServices& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->DynAssociation_ = x.DynAssociation_;
      this->SettingGroups_ = x.SettingGroups_;
      this->GetDirectory_ = x.GetDirectory_;
      this->GetDataObjectDefinition_ = x.GetDataObjectDefinition_;
      this->DataObjectDirectory_ = x.DataObjectDirectory_;
      this->GetDataSetValue_ = x.GetDataSetValue_;
      this->SetDataSetValue_ = x.SetDataSetValue_;
      this->DataSetDirectory_ = x.DataSetDirectory_;
      this->ConfDataSet_ = x.ConfDataSet_;
      this->DynDataSet_ = x.DynDataSet_;
      this->ReadWrite_ = x.ReadWrite_;
      this->TimerActivatedControl_ = x.TimerActivatedControl_;
      this->ConfReportControl_ = x.ConfReportControl_;
      this->GetCBValues_ = x.GetCBValues_;
      this->ConfLogControl_ = x.ConfLogControl_;
      this->ReportSettings_ = x.ReportSettings_;
      this->LogSettings_ = x.LogSettings_;
      this->GSESettings_ = x.GSESettings_;
      this->SMVSettings_ = x.SMVSettings_;
      this->GSEDir_ = x.GSEDir_;
      this->GOOSE_ = x.GOOSE_;
      this->GSSE_ = x.GSSE_;
      this->FileHandling_ = x.FileHandling_;
      this->ConfLNs_ = x.ConfLNs_;
      this->ClientServices_ = x.ClientServices_;
    }

    return *this;
  }

  tServices::
  ~tServices ()
  {
  }

  // tAccessPoint
  //

  tAccessPoint::
  tAccessPoint (const name_type& name)
  : ::SCL::tNaming (name),
    Server_ (this),
    LN_ (this),
    router_ (router_default_value (), this),
    clock_ (clock_default_value (), this)
  {
  }

  tAccessPoint::
  tAccessPoint (const tAccessPoint& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::SCL::tNaming (x, f, c),
    Server_ (x.Server_, f, this),
    LN_ (x.LN_, f, this),
    router_ (x.router_, f, this),
    clock_ (x.clock_, f, this)
  {
  }

  tAccessPoint::
  tAccessPoint (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::SCL::tNaming (e, f | ::xml_schema::flags::base, c),
    Server_ (this),
    LN_ (this),
    router_ (this),
    clock_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tAccessPoint::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tNaming::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Server
      //
      if (n.name () == "Server" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< Server_type > r (
          Server_traits::create (i, f, this));

        if (!this->Server_)
        {
          this->Server_.set (r);
          continue;
        }
      }

      // LN
      //
      if (n.name () == "LN" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< LN_type > r (
          LN_traits::create (i, f, this));

        this->LN_.push_back (r);
        continue;
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "router" && n.namespace_ ().empty ())
      {
        this->router_.set (router_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "clock" && n.namespace_ ().empty ())
      {
        this->clock_.set (clock_traits::create (i, f, this));
        continue;
      }
    }

    if (!router_.present ())
    {
      this->router_.set (router_default_value ());
    }

    if (!clock_.present ())
    {
      this->clock_.set (clock_default_value ());
    }
  }

  tAccessPoint* tAccessPoint::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tAccessPoint (*this, f, c);
  }

  tAccessPoint& tAccessPoint::
  operator= (const tAccessPoint& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tNaming& > (*this) = x;
      this->Server_ = x.Server_;
      this->LN_ = x.LN_;
      this->router_ = x.router_;
      this->clock_ = x.clock_;
    }

    return *this;
  }

  tAccessPoint::
  ~tAccessPoint ()
  {
  }

  // tServer
  //

  tServer::
  tServer (const Authentication_type& Authentication)
  : ::SCL::tUnNaming (),
    Authentication_ (Authentication, this),
    LDevice_ (this),
    Association_ (this),
    timeout_ (timeout_default_value (), this)
  {
  }

  tServer::
  tServer (::std::auto_ptr< Authentication_type > Authentication)
  : ::SCL::tUnNaming (),
    Authentication_ (Authentication, this),
    LDevice_ (this),
    Association_ (this),
    timeout_ (timeout_default_value (), this)
  {
  }

  tServer::
  tServer (const tServer& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::SCL::tUnNaming (x, f, c),
    Authentication_ (x.Authentication_, f, this),
    LDevice_ (x.LDevice_, f, this),
    Association_ (x.Association_, f, this),
    timeout_ (x.timeout_, f, this)
  {
  }

  tServer::
  tServer (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::SCL::tUnNaming (e, f | ::xml_schema::flags::base, c),
    Authentication_ (this),
    LDevice_ (this),
    Association_ (this),
    timeout_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tServer::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tUnNaming::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Authentication
      //
      if (n.name () == "Authentication" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< Authentication_type > r (
          Authentication_traits::create (i, f, this));

        if (!Authentication_.present ())
        {
          this->Authentication_.set (r);
          continue;
        }
      }

      // LDevice
      //
      if (n.name () == "LDevice" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< LDevice_type > r (
          LDevice_traits::create (i, f, this));

        this->LDevice_.push_back (r);
        continue;
      }

      // Association
      //
      if (n.name () == "Association" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< Association_type > r (
          Association_traits::create (i, f, this));

        this->Association_.push_back (r);
        continue;
      }

      break;
    }

    if (!Authentication_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Authentication",
        "http://www.iec.ch/61850/2006/SCL");
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "timeout" && n.namespace_ ().empty ())
      {
        this->timeout_.set (timeout_traits::create (i, f, this));
        continue;
      }
    }

    if (!timeout_.present ())
    {
      this->timeout_.set (timeout_default_value ());
    }
  }

  tServer* tServer::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tServer (*this, f, c);
  }

  tServer& tServer::
  operator= (const tServer& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tUnNaming& > (*this) = x;
      this->Authentication_ = x.Authentication_;
      this->LDevice_ = x.LDevice_;
      this->Association_ = x.Association_;
      this->timeout_ = x.timeout_;
    }

    return *this;
  }

  tServer::
  ~tServer ()
  {
  }

  // tLDevice
  //

  tLDevice::
  tLDevice (const LN0_type& LN0,
            const inst_type& inst)
  : ::SCL::tUnNaming (),
    LN0_ (LN0, this),
    LN_ (this),
    AccessControl_ (this),
    inst_ (inst, this),
    ldName_ (this)
  {
  }

  tLDevice::
  tLDevice (::std::auto_ptr< LN0_type > LN0,
            const inst_type& inst)
  : ::SCL::tUnNaming (),
    LN0_ (LN0, this),
    LN_ (this),
    AccessControl_ (this),
    inst_ (inst, this),
    ldName_ (this)
  {
  }

  tLDevice::
  tLDevice (const tLDevice& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::SCL::tUnNaming (x, f, c),
    LN0_ (x.LN0_, f, this),
    LN_ (x.LN_, f, this),
    AccessControl_ (x.AccessControl_, f, this),
    inst_ (x.inst_, f, this),
    ldName_ (x.ldName_, f, this)
  {
  }

  tLDevice::
  tLDevice (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::SCL::tUnNaming (e, f | ::xml_schema::flags::base, c),
    LN0_ (this),
    LN_ (this),
    AccessControl_ (this),
    inst_ (this),
    ldName_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tLDevice::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tUnNaming::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // LN0
      //
      if (n.name () == "LN0" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< LN0_type > r (
          LN0_traits::create (i, f, this));

        if (!LN0_.present ())
        {
          this->LN0_.set (r);
          continue;
        }
      }

      // LN
      //
      if (n.name () == "LN" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< LN_type > r (
          LN_traits::create (i, f, this));

        this->LN_.push_back (r);
        continue;
      }

      // AccessControl
      //
      if (n.name () == "AccessControl" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< AccessControl_type > r (
          AccessControl_traits::create (i, f, this));

        if (!this->AccessControl_)
        {
          this->AccessControl_.set (r);
          continue;
        }
      }

      break;
    }

    if (!LN0_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "LN0",
        "http://www.iec.ch/61850/2006/SCL");
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "inst" && n.namespace_ ().empty ())
      {
        this->inst_.set (inst_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ldName" && n.namespace_ ().empty ())
      {
        this->ldName_.set (ldName_traits::create (i, f, this));
        continue;
      }
    }

    if (!inst_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "inst",
        "");
    }
  }

  tLDevice* tLDevice::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tLDevice (*this, f, c);
  }

  tLDevice& tLDevice::
  operator= (const tLDevice& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tUnNaming& > (*this) = x;
      this->LN0_ = x.LN0_;
      this->LN_ = x.LN_;
      this->AccessControl_ = x.AccessControl_;
      this->inst_ = x.inst_;
      this->ldName_ = x.ldName_;
    }

    return *this;
  }

  tLDevice::
  ~tLDevice ()
  {
  }

  // tAccessControl
  //

  tAccessControl::
  tAccessControl ()
  : ::SCL::tAnyContentFromOtherNamespace ()
  {
  }

  tAccessControl::
  tAccessControl (const tAccessControl& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::SCL::tAnyContentFromOtherNamespace (x, f, c)
  {
  }

  tAccessControl::
  tAccessControl (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::SCL::tAnyContentFromOtherNamespace (e, f, c)
  {
  }

  tAccessControl* tAccessControl::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tAccessControl (*this, f, c);
  }

  tAccessControl::
  ~tAccessControl ()
  {
  }

  // tAssociation
  //

  tAssociation::
  tAssociation (const kind_type& kind,
                const iedName_type& iedName,
                const ldInst_type& ldInst,
                const lnClass_type& lnClass,
                const lnInst_type& lnInst)
  : ::xml_schema::type (),
    kind_ (kind, this),
    associationID_ (this),
    iedName_ (iedName, this),
    ldInst_ (ldInst, this),
    prefix_ (this),
    lnClass_ (lnClass, this),
    lnInst_ (lnInst, this)
  {
  }

  tAssociation::
  tAssociation (const tAssociation& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    kind_ (x.kind_, f, this),
    associationID_ (x.associationID_, f, this),
    iedName_ (x.iedName_, f, this),
    ldInst_ (x.ldInst_, f, this),
    prefix_ (x.prefix_, f, this),
    lnClass_ (x.lnClass_, f, this),
    lnInst_ (x.lnInst_, f, this)
  {
  }

  tAssociation::
  tAssociation (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    kind_ (this),
    associationID_ (this),
    iedName_ (this),
    ldInst_ (this),
    prefix_ (this),
    lnClass_ (this),
    lnInst_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void tAssociation::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "kind" && n.namespace_ ().empty ())
      {
        this->kind_.set (kind_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "associationID" && n.namespace_ ().empty ())
      {
        this->associationID_.set (associationID_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "iedName" && n.namespace_ ().empty ())
      {
        this->iedName_.set (iedName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ldInst" && n.namespace_ ().empty ())
      {
        this->ldInst_.set (ldInst_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "prefix" && n.namespace_ ().empty ())
      {
        this->prefix_.set (prefix_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "lnClass" && n.namespace_ ().empty ())
      {
        this->lnClass_.set (lnClass_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "lnInst" && n.namespace_ ().empty ())
      {
        this->lnInst_.set (lnInst_traits::create (i, f, this));
        continue;
      }
    }

    if (!kind_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "kind",
        "");
    }

    if (!iedName_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "iedName",
        "");
    }

    if (!ldInst_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ldInst",
        "");
    }

    if (!lnClass_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "lnClass",
        "");
    }

    if (!lnInst_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "lnInst",
        "");
    }
  }

  tAssociation* tAssociation::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tAssociation (*this, f, c);
  }

  tAssociation& tAssociation::
  operator= (const tAssociation& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->kind_ = x.kind_;
      this->associationID_ = x.associationID_;
      this->iedName_ = x.iedName_;
      this->ldInst_ = x.ldInst_;
      this->prefix_ = x.prefix_;
      this->lnClass_ = x.lnClass_;
      this->lnInst_ = x.lnInst_;
    }

    return *this;
  }

  tAssociation::
  ~tAssociation ()
  {
  }

  // tAnyLN
  //

  tAnyLN::
  tAnyLN (const lnType_type& lnType)
  : ::SCL::tUnNaming (),
    DataSet_ (this),
    ReportControl_ (this),
    LogControl_ (this),
    DOI_ (this),
    Inputs_ (this),
    lnType_ (lnType, this)
  {
  }

  tAnyLN::
  tAnyLN (const tAnyLN& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::SCL::tUnNaming (x, f, c),
    DataSet_ (x.DataSet_, f, this),
    ReportControl_ (x.ReportControl_, f, this),
    LogControl_ (x.LogControl_, f, this),
    DOI_ (x.DOI_, f, this),
    Inputs_ (x.Inputs_, f, this),
    lnType_ (x.lnType_, f, this)
  {
  }

  tAnyLN::
  tAnyLN (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::SCL::tUnNaming (e, f | ::xml_schema::flags::base, c),
    DataSet_ (this),
    ReportControl_ (this),
    LogControl_ (this),
    DOI_ (this),
    Inputs_ (this),
    lnType_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tAnyLN::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tUnNaming::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DataSet
      //
      if (n.name () == "DataSet" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< DataSet_type > r (
          DataSet_traits::create (i, f, this));

        this->DataSet_.push_back (r);
        continue;
      }

      // ReportControl
      //
      if (n.name () == "ReportControl" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< ReportControl_type > r (
          ReportControl_traits::create (i, f, this));

        this->ReportControl_.push_back (r);
        continue;
      }

      // LogControl
      //
      if (n.name () == "LogControl" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< LogControl_type > r (
          LogControl_traits::create (i, f, this));

        this->LogControl_.push_back (r);
        continue;
      }

      // DOI
      //
      if (n.name () == "DOI" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< DOI_type > r (
          DOI_traits::create (i, f, this));

        this->DOI_.push_back (r);
        continue;
      }

      // Inputs
      //
      if (n.name () == "Inputs" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< Inputs_type > r (
          Inputs_traits::create (i, f, this));

        if (!this->Inputs_)
        {
          this->Inputs_.set (r);
          continue;
        }
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "lnType" && n.namespace_ ().empty ())
      {
        this->lnType_.set (lnType_traits::create (i, f, this));
        continue;
      }
    }

    if (!lnType_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "lnType",
        "");
    }
  }

  tAnyLN* tAnyLN::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tAnyLN (*this, f, c);
  }

  tAnyLN& tAnyLN::
  operator= (const tAnyLN& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tUnNaming& > (*this) = x;
      this->DataSet_ = x.DataSet_;
      this->ReportControl_ = x.ReportControl_;
      this->LogControl_ = x.LogControl_;
      this->DOI_ = x.DOI_;
      this->Inputs_ = x.Inputs_;
      this->lnType_ = x.lnType_;
    }

    return *this;
  }

  tAnyLN::
  ~tAnyLN ()
  {
  }

  // tLN
  //

  tLN::
  tLN (const lnType_type& lnType,
       const lnClass_type& lnClass,
       const inst_type& inst)
  : ::SCL::tAnyLN (lnType),
    lnClass_ (lnClass, this),
    inst_ (inst, this),
    prefix_ (this)
  {
  }

  tLN::
  tLN (const tLN& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::SCL::tAnyLN (x, f, c),
    lnClass_ (x.lnClass_, f, this),
    inst_ (x.inst_, f, this),
    prefix_ (x.prefix_, f, this)
  {
  }

  tLN::
  tLN (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::SCL::tAnyLN (e, f | ::xml_schema::flags::base, c),
    lnClass_ (this),
    inst_ (this),
    prefix_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tLN::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tAnyLN::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "lnClass" && n.namespace_ ().empty ())
      {
        this->lnClass_.set (lnClass_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "inst" && n.namespace_ ().empty ())
      {
        this->inst_.set (inst_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "prefix" && n.namespace_ ().empty ())
      {
        this->prefix_.set (prefix_traits::create (i, f, this));
        continue;
      }
    }

    if (!lnClass_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "lnClass",
        "");
    }

    if (!inst_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "inst",
        "");
    }
  }

  tLN* tLN::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tLN (*this, f, c);
  }

  tLN& tLN::
  operator= (const tLN& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tAnyLN& > (*this) = x;
      this->lnClass_ = x.lnClass_;
      this->inst_ = x.inst_;
      this->prefix_ = x.prefix_;
    }

    return *this;
  }

  tLN::
  ~tLN ()
  {
  }

  // tLN0
  //

  const tLN0::lnClass_type tLN0::lnClass_default_value_ (
    "LLN0");

  const tLN0::inst_type tLN0::inst_default_value_ (
    "");

  tLN0::
  tLN0 (const lnType_type& lnType)
  : ::SCL::tAnyLN (lnType),
    GSEControl_ (this),
    SampledValueControl_ (this),
    SettingControl_ (this),
    SCLControl_ (this),
    Log_ (this),
    lnClass_ (lnClass_default_value (), this),
    inst_ (inst_default_value (), this)
  {
  }

  tLN0::
  tLN0 (const tLN0& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::SCL::tAnyLN (x, f, c),
    GSEControl_ (x.GSEControl_, f, this),
    SampledValueControl_ (x.SampledValueControl_, f, this),
    SettingControl_ (x.SettingControl_, f, this),
    SCLControl_ (x.SCLControl_, f, this),
    Log_ (x.Log_, f, this),
    lnClass_ (x.lnClass_, f, this),
    inst_ (x.inst_, f, this)
  {
  }

  tLN0::
  tLN0 (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::SCL::tAnyLN (e, f | ::xml_schema::flags::base, c),
    GSEControl_ (this),
    SampledValueControl_ (this),
    SettingControl_ (this),
    SCLControl_ (this),
    Log_ (this),
    lnClass_ (this),
    inst_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tLN0::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tAnyLN::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // GSEControl
      //
      if (n.name () == "GSEControl" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< GSEControl_type > r (
          GSEControl_traits::create (i, f, this));

        this->GSEControl_.push_back (r);
        continue;
      }

      // SampledValueControl
      //
      if (n.name () == "SampledValueControl" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< SampledValueControl_type > r (
          SampledValueControl_traits::create (i, f, this));

        this->SampledValueControl_.push_back (r);
        continue;
      }

      // SettingControl
      //
      if (n.name () == "SettingControl" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< SettingControl_type > r (
          SettingControl_traits::create (i, f, this));

        if (!this->SettingControl_)
        {
          this->SettingControl_.set (r);
          continue;
        }
      }

      // SCLControl
      //
      if (n.name () == "SCLControl" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< SCLControl_type > r (
          SCLControl_traits::create (i, f, this));

        if (!this->SCLControl_)
        {
          this->SCLControl_.set (r);
          continue;
        }
      }

      // Log
      //
      if (n.name () == "Log" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< Log_type > r (
          Log_traits::create (i, f, this));

        if (!this->Log_)
        {
          this->Log_.set (r);
          continue;
        }
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "lnClass" && n.namespace_ ().empty ())
      {
        this->lnClass_.set (lnClass_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "inst" && n.namespace_ ().empty ())
      {
        this->inst_.set (inst_traits::create (i, f, this));
        continue;
      }
    }

    if (!lnClass_.present ())
    {
      this->lnClass_.set (lnClass_default_value ());
    }

    if (!inst_.present ())
    {
      this->inst_.set (inst_default_value ());
    }
  }

  tLN0* tLN0::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tLN0 (*this, f, c);
  }

  tLN0& tLN0::
  operator= (const tLN0& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tAnyLN& > (*this) = x;
      this->GSEControl_ = x.GSEControl_;
      this->SampledValueControl_ = x.SampledValueControl_;
      this->SettingControl_ = x.SettingControl_;
      this->SCLControl_ = x.SCLControl_;
      this->Log_ = x.Log_;
      this->lnClass_ = x.lnClass_;
      this->inst_ = x.inst_;
    }

    return *this;
  }

  tLN0::
  ~tLN0 ()
  {
  }

  // tDataSet
  //

  tDataSet::
  tDataSet (const name_type& name)
  : ::SCL::tNaming (name),
    FCDA_ (this),
    FCCB_ (this)
  {
  }

  tDataSet::
  tDataSet (const tDataSet& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::SCL::tNaming (x, f, c),
    FCDA_ (x.FCDA_, f, this),
    FCCB_ (x.FCCB_, f, this)
  {
  }

  tDataSet::
  tDataSet (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::SCL::tNaming (e, f | ::xml_schema::flags::base, c),
    FCDA_ (this),
    FCCB_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tDataSet::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tNaming::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // FCDA
      //
      if (n.name () == "FCDA" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< FCDA_type > r (
          FCDA_traits::create (i, f, this));

        this->FCDA_.push_back (r);
        continue;
      }

      // FCCB
      //
      if (n.name () == "FCCB" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< FCCB_type > r (
          FCCB_traits::create (i, f, this));

        this->FCCB_.push_back (r);
        continue;
      }

      break;
    }
  }

  tDataSet* tDataSet::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tDataSet (*this, f, c);
  }

  tDataSet& tDataSet::
  operator= (const tDataSet& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tNaming& > (*this) = x;
      this->FCDA_ = x.FCDA_;
      this->FCCB_ = x.FCCB_;
    }

    return *this;
  }

  tDataSet::
  ~tDataSet ()
  {
  }

  // tFCDA
  //

  tFCDA::
  tFCDA (const fc_type& fc)
  : ::xml_schema::type (),
    ldInst_ (this),
    prefix_ (this),
    lnClass_ (this),
    lnInst_ (this),
    doName_ (this),
    daName_ (this),
    fc_ (fc, this)
  {
  }

  tFCDA::
  tFCDA (const tFCDA& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    ldInst_ (x.ldInst_, f, this),
    prefix_ (x.prefix_, f, this),
    lnClass_ (x.lnClass_, f, this),
    lnInst_ (x.lnInst_, f, this),
    doName_ (x.doName_, f, this),
    daName_ (x.daName_, f, this),
    fc_ (x.fc_, f, this)
  {
  }

  tFCDA::
  tFCDA (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    ldInst_ (this),
    prefix_ (this),
    lnClass_ (this),
    lnInst_ (this),
    doName_ (this),
    daName_ (this),
    fc_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void tFCDA::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ldInst" && n.namespace_ ().empty ())
      {
        this->ldInst_.set (ldInst_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "prefix" && n.namespace_ ().empty ())
      {
        this->prefix_.set (prefix_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "lnClass" && n.namespace_ ().empty ())
      {
        this->lnClass_.set (lnClass_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "lnInst" && n.namespace_ ().empty ())
      {
        this->lnInst_.set (lnInst_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "doName" && n.namespace_ ().empty ())
      {
        this->doName_.set (doName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "daName" && n.namespace_ ().empty ())
      {
        this->daName_.set (daName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "fc" && n.namespace_ ().empty ())
      {
        this->fc_.set (fc_traits::create (i, f, this));
        continue;
      }
    }

    if (!fc_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "fc",
        "");
    }
  }

  tFCDA* tFCDA::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tFCDA (*this, f, c);
  }

  tFCDA& tFCDA::
  operator= (const tFCDA& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->ldInst_ = x.ldInst_;
      this->prefix_ = x.prefix_;
      this->lnClass_ = x.lnClass_;
      this->lnInst_ = x.lnInst_;
      this->doName_ = x.doName_;
      this->daName_ = x.daName_;
      this->fc_ = x.fc_;
    }

    return *this;
  }

  tFCDA::
  ~tFCDA ()
  {
  }

  // tFCCB
  //

  tFCCB::
  tFCCB (const ldInst_type& ldInst,
         const lnClass_type& lnClass,
         const cbName_type& cbName,
         const fc_type& fc)
  : ::xml_schema::type (),
    ldInst_ (ldInst, this),
    prefix_ (this),
    lnClass_ (lnClass, this),
    lnInst_ (this),
    cbName_ (cbName, this),
    daName_ (this),
    fc_ (fc, this)
  {
  }

  tFCCB::
  tFCCB (const tFCCB& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    ldInst_ (x.ldInst_, f, this),
    prefix_ (x.prefix_, f, this),
    lnClass_ (x.lnClass_, f, this),
    lnInst_ (x.lnInst_, f, this),
    cbName_ (x.cbName_, f, this),
    daName_ (x.daName_, f, this),
    fc_ (x.fc_, f, this)
  {
  }

  tFCCB::
  tFCCB (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    ldInst_ (this),
    prefix_ (this),
    lnClass_ (this),
    lnInst_ (this),
    cbName_ (this),
    daName_ (this),
    fc_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void tFCCB::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ldInst" && n.namespace_ ().empty ())
      {
        this->ldInst_.set (ldInst_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "prefix" && n.namespace_ ().empty ())
      {
        this->prefix_.set (prefix_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "lnClass" && n.namespace_ ().empty ())
      {
        this->lnClass_.set (lnClass_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "lnInst" && n.namespace_ ().empty ())
      {
        this->lnInst_.set (lnInst_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "cbName" && n.namespace_ ().empty ())
      {
        this->cbName_.set (cbName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "daName" && n.namespace_ ().empty ())
      {
        this->daName_.set (daName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "fc" && n.namespace_ ().empty ())
      {
        this->fc_.set (fc_traits::create (i, f, this));
        continue;
      }
    }

    if (!ldInst_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ldInst",
        "");
    }

    if (!lnClass_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "lnClass",
        "");
    }

    if (!cbName_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "cbName",
        "");
    }

    if (!fc_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "fc",
        "");
    }
  }

  tFCCB* tFCCB::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tFCCB (*this, f, c);
  }

  tFCCB& tFCCB::
  operator= (const tFCCB& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->ldInst_ = x.ldInst_;
      this->prefix_ = x.prefix_;
      this->lnClass_ = x.lnClass_;
      this->lnInst_ = x.lnInst_;
      this->cbName_ = x.cbName_;
      this->daName_ = x.daName_;
      this->fc_ = x.fc_;
    }

    return *this;
  }

  tFCCB::
  ~tFCCB ()
  {
  }

  // tControl
  //

  tControl::
  tControl (const name_type& name)
  : ::SCL::tNaming (name),
    datSet_ (this)
  {
  }

  tControl::
  tControl (const tControl& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::SCL::tNaming (x, f, c),
    datSet_ (x.datSet_, f, this)
  {
  }

  tControl::
  tControl (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::SCL::tNaming (e, f | ::xml_schema::flags::base, c),
    datSet_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tControl::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tNaming::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "datSet" && n.namespace_ ().empty ())
      {
        this->datSet_.set (datSet_traits::create (i, f, this));
        continue;
      }
    }
  }

  tControl* tControl::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tControl (*this, f, c);
  }

  tControl& tControl::
  operator= (const tControl& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tNaming& > (*this) = x;
      this->datSet_ = x.datSet_;
    }

    return *this;
  }

  tControl::
  ~tControl ()
  {
  }

  // tControlWithTriggerOpt
  //

  tControlWithTriggerOpt::
  tControlWithTriggerOpt (const name_type& name)
  : ::SCL::tControl (name),
    TrgOps_ (this),
    intgPd_ (intgPd_default_value (), this)
  {
  }

  tControlWithTriggerOpt::
  tControlWithTriggerOpt (const tControlWithTriggerOpt& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::SCL::tControl (x, f, c),
    TrgOps_ (x.TrgOps_, f, this),
    intgPd_ (x.intgPd_, f, this)
  {
  }

  tControlWithTriggerOpt::
  tControlWithTriggerOpt (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::SCL::tControl (e, f | ::xml_schema::flags::base, c),
    TrgOps_ (this),
    intgPd_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tControlWithTriggerOpt::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tControl::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // TrgOps
      //
      if (n.name () == "TrgOps" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< TrgOps_type > r (
          TrgOps_traits::create (i, f, this));

        if (!this->TrgOps_)
        {
          this->TrgOps_.set (r);
          continue;
        }
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "intgPd" && n.namespace_ ().empty ())
      {
        this->intgPd_.set (intgPd_traits::create (i, f, this));
        continue;
      }
    }

    if (!intgPd_.present ())
    {
      this->intgPd_.set (intgPd_default_value ());
    }
  }

  tControlWithTriggerOpt* tControlWithTriggerOpt::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tControlWithTriggerOpt (*this, f, c);
  }

  tControlWithTriggerOpt& tControlWithTriggerOpt::
  operator= (const tControlWithTriggerOpt& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tControl& > (*this) = x;
      this->TrgOps_ = x.TrgOps_;
      this->intgPd_ = x.intgPd_;
    }

    return *this;
  }

  tControlWithTriggerOpt::
  ~tControlWithTriggerOpt ()
  {
  }

  // tTrgOps
  //

  tTrgOps::
  tTrgOps ()
  : ::xml_schema::type (),
    dchg_ (dchg_default_value (), this),
    qchg_ (qchg_default_value (), this),
    dupd_ (dupd_default_value (), this),
    period_ (period_default_value (), this)
  {
  }

  tTrgOps::
  tTrgOps (const tTrgOps& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    dchg_ (x.dchg_, f, this),
    qchg_ (x.qchg_, f, this),
    dupd_ (x.dupd_, f, this),
    period_ (x.period_, f, this)
  {
  }

  tTrgOps::
  tTrgOps (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    dchg_ (this),
    qchg_ (this),
    dupd_ (this),
    period_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void tTrgOps::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "dchg" && n.namespace_ ().empty ())
      {
        this->dchg_.set (dchg_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "qchg" && n.namespace_ ().empty ())
      {
        this->qchg_.set (qchg_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "dupd" && n.namespace_ ().empty ())
      {
        this->dupd_.set (dupd_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "period" && n.namespace_ ().empty ())
      {
        this->period_.set (period_traits::create (i, f, this));
        continue;
      }
    }

    if (!dchg_.present ())
    {
      this->dchg_.set (dchg_default_value ());
    }

    if (!qchg_.present ())
    {
      this->qchg_.set (qchg_default_value ());
    }

    if (!dupd_.present ())
    {
      this->dupd_.set (dupd_default_value ());
    }

    if (!period_.present ())
    {
      this->period_.set (period_default_value ());
    }
  }

  tTrgOps* tTrgOps::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tTrgOps (*this, f, c);
  }

  tTrgOps& tTrgOps::
  operator= (const tTrgOps& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->dchg_ = x.dchg_;
      this->qchg_ = x.qchg_;
      this->dupd_ = x.dupd_;
      this->period_ = x.period_;
    }

    return *this;
  }

  tTrgOps::
  ~tTrgOps ()
  {
  }

  // tReportControl
  //

  tReportControl::
  tReportControl (const name_type& name,
                  const OptFields_type& OptFields,
                  const rptID_type& rptID,
                  const confRev_type& confRev)
  : ::SCL::tControlWithTriggerOpt (name),
    OptFields_ (OptFields, this),
    RptEnabled_ (this),
    rptID_ (rptID, this),
    confRev_ (confRev, this),
    buffered_ (buffered_default_value (), this),
    bufTime_ (bufTime_default_value (), this)
  {
  }

  tReportControl::
  tReportControl (const name_type& name,
                  ::std::auto_ptr< OptFields_type > OptFields,
                  const rptID_type& rptID,
                  const confRev_type& confRev)
  : ::SCL::tControlWithTriggerOpt (name),
    OptFields_ (OptFields, this),
    RptEnabled_ (this),
    rptID_ (rptID, this),
    confRev_ (confRev, this),
    buffered_ (buffered_default_value (), this),
    bufTime_ (bufTime_default_value (), this)
  {
  }

  tReportControl::
  tReportControl (const tReportControl& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::SCL::tControlWithTriggerOpt (x, f, c),
    OptFields_ (x.OptFields_, f, this),
    RptEnabled_ (x.RptEnabled_, f, this),
    rptID_ (x.rptID_, f, this),
    confRev_ (x.confRev_, f, this),
    buffered_ (x.buffered_, f, this),
    bufTime_ (x.bufTime_, f, this)
  {
  }

  tReportControl::
  tReportControl (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::SCL::tControlWithTriggerOpt (e, f | ::xml_schema::flags::base, c),
    OptFields_ (this),
    RptEnabled_ (this),
    rptID_ (this),
    confRev_ (this),
    buffered_ (this),
    bufTime_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tReportControl::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tControlWithTriggerOpt::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // OptFields
      //
      if (n.name () == "OptFields" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< OptFields_type > r (
          OptFields_traits::create (i, f, this));

        if (!OptFields_.present ())
        {
          this->OptFields_.set (r);
          continue;
        }
      }

      // RptEnabled
      //
      if (n.name () == "RptEnabled" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< RptEnabled_type > r (
          RptEnabled_traits::create (i, f, this));

        if (!this->RptEnabled_)
        {
          this->RptEnabled_.set (r);
          continue;
        }
      }

      break;
    }

    if (!OptFields_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "OptFields",
        "http://www.iec.ch/61850/2006/SCL");
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "rptID" && n.namespace_ ().empty ())
      {
        this->rptID_.set (rptID_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "confRev" && n.namespace_ ().empty ())
      {
        this->confRev_.set (confRev_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "buffered" && n.namespace_ ().empty ())
      {
        this->buffered_.set (buffered_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "bufTime" && n.namespace_ ().empty ())
      {
        this->bufTime_.set (bufTime_traits::create (i, f, this));
        continue;
      }
    }

    if (!rptID_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "rptID",
        "");
    }

    if (!confRev_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "confRev",
        "");
    }

    if (!buffered_.present ())
    {
      this->buffered_.set (buffered_default_value ());
    }

    if (!bufTime_.present ())
    {
      this->bufTime_.set (bufTime_default_value ());
    }
  }

  tReportControl* tReportControl::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tReportControl (*this, f, c);
  }

  tReportControl& tReportControl::
  operator= (const tReportControl& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tControlWithTriggerOpt& > (*this) = x;
      this->OptFields_ = x.OptFields_;
      this->RptEnabled_ = x.RptEnabled_;
      this->rptID_ = x.rptID_;
      this->confRev_ = x.confRev_;
      this->buffered_ = x.buffered_;
      this->bufTime_ = x.bufTime_;
    }

    return *this;
  }

  tReportControl::
  ~tReportControl ()
  {
  }

  // tRptEnabled
  //

  tRptEnabled::
  tRptEnabled ()
  : ::SCL::tUnNaming (),
    ClientLN_ (this),
    max_ (max_default_value (), this)
  {
  }

  tRptEnabled::
  tRptEnabled (const tRptEnabled& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::SCL::tUnNaming (x, f, c),
    ClientLN_ (x.ClientLN_, f, this),
    max_ (x.max_, f, this)
  {
  }

  tRptEnabled::
  tRptEnabled (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::SCL::tUnNaming (e, f | ::xml_schema::flags::base, c),
    ClientLN_ (this),
    max_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tRptEnabled::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tUnNaming::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ClientLN
      //
      if (n.name () == "ClientLN" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< ClientLN_type > r (
          ClientLN_traits::create (i, f, this));

        this->ClientLN_.push_back (r);
        continue;
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "max" && n.namespace_ ().empty ())
      {
        this->max_.set (max_traits::create (i, f, this));
        continue;
      }
    }

    if (!max_.present ())
    {
      this->max_.set (max_default_value ());
    }
  }

  tRptEnabled* tRptEnabled::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tRptEnabled (*this, f, c);
  }

  tRptEnabled& tRptEnabled::
  operator= (const tRptEnabled& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tUnNaming& > (*this) = x;
      this->ClientLN_ = x.ClientLN_;
      this->max_ = x.max_;
    }

    return *this;
  }

  tRptEnabled::
  ~tRptEnabled ()
  {
  }

  // tClientLN
  //

  tClientLN::
  tClientLN (const iedName_type& iedName,
             const ldInst_type& ldInst,
             const lnClass_type& lnClass,
             const lnInst_type& lnInst)
  : ::xml_schema::type (),
    iedName_ (iedName, this),
    ldInst_ (ldInst, this),
    prefix_ (this),
    lnClass_ (lnClass, this),
    lnInst_ (lnInst, this)
  {
  }

  tClientLN::
  tClientLN (const tClientLN& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    iedName_ (x.iedName_, f, this),
    ldInst_ (x.ldInst_, f, this),
    prefix_ (x.prefix_, f, this),
    lnClass_ (x.lnClass_, f, this),
    lnInst_ (x.lnInst_, f, this)
  {
  }

  tClientLN::
  tClientLN (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    iedName_ (this),
    ldInst_ (this),
    prefix_ (this),
    lnClass_ (this),
    lnInst_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void tClientLN::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "iedName" && n.namespace_ ().empty ())
      {
        this->iedName_.set (iedName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ldInst" && n.namespace_ ().empty ())
      {
        this->ldInst_.set (ldInst_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "prefix" && n.namespace_ ().empty ())
      {
        this->prefix_.set (prefix_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "lnClass" && n.namespace_ ().empty ())
      {
        this->lnClass_.set (lnClass_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "lnInst" && n.namespace_ ().empty ())
      {
        this->lnInst_.set (lnInst_traits::create (i, f, this));
        continue;
      }
    }

    if (!iedName_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "iedName",
        "");
    }

    if (!ldInst_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ldInst",
        "");
    }

    if (!lnClass_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "lnClass",
        "");
    }

    if (!lnInst_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "lnInst",
        "");
    }
  }

  tClientLN* tClientLN::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tClientLN (*this, f, c);
  }

  tClientLN& tClientLN::
  operator= (const tClientLN& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->iedName_ = x.iedName_;
      this->ldInst_ = x.ldInst_;
      this->prefix_ = x.prefix_;
      this->lnClass_ = x.lnClass_;
      this->lnInst_ = x.lnInst_;
    }

    return *this;
  }

  tClientLN::
  ~tClientLN ()
  {
  }

  // tLogControl
  //

  tLogControl::
  tLogControl (const name_type& name,
               const logName_type& logName)
  : ::SCL::tControlWithTriggerOpt (name),
    logName_ (logName, this),
    logEna_ (logEna_default_value (), this),
    reasonCode_ (reasonCode_default_value (), this)
  {
  }

  tLogControl::
  tLogControl (const tLogControl& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::SCL::tControlWithTriggerOpt (x, f, c),
    logName_ (x.logName_, f, this),
    logEna_ (x.logEna_, f, this),
    reasonCode_ (x.reasonCode_, f, this)
  {
  }

  tLogControl::
  tLogControl (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::SCL::tControlWithTriggerOpt (e, f | ::xml_schema::flags::base, c),
    logName_ (this),
    logEna_ (this),
    reasonCode_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tLogControl::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tControlWithTriggerOpt::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "logName" && n.namespace_ ().empty ())
      {
        this->logName_.set (logName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "logEna" && n.namespace_ ().empty ())
      {
        this->logEna_.set (logEna_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "reasonCode" && n.namespace_ ().empty ())
      {
        this->reasonCode_.set (reasonCode_traits::create (i, f, this));
        continue;
      }
    }

    if (!logName_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "logName",
        "");
    }

    if (!logEna_.present ())
    {
      this->logEna_.set (logEna_default_value ());
    }

    if (!reasonCode_.present ())
    {
      this->reasonCode_.set (reasonCode_default_value ());
    }
  }

  tLogControl* tLogControl::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tLogControl (*this, f, c);
  }

  tLogControl& tLogControl::
  operator= (const tLogControl& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tControlWithTriggerOpt& > (*this) = x;
      this->logName_ = x.logName_;
      this->logEna_ = x.logEna_;
      this->reasonCode_ = x.reasonCode_;
    }

    return *this;
  }

  tLogControl::
  ~tLogControl ()
  {
  }

  // tInputs
  //

  tInputs::
  tInputs ()
  : ::SCL::tUnNaming (),
    ExtRef_ (this)
  {
  }

  tInputs::
  tInputs (const tInputs& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::SCL::tUnNaming (x, f, c),
    ExtRef_ (x.ExtRef_, f, this)
  {
  }

  tInputs::
  tInputs (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::SCL::tUnNaming (e, f | ::xml_schema::flags::base, c),
    ExtRef_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tInputs::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tUnNaming::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ExtRef
      //
      if (n.name () == "ExtRef" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< ExtRef_type > r (
          ExtRef_traits::create (i, f, this));

        this->ExtRef_.push_back (r);
        continue;
      }

      break;
    }
  }

  tInputs* tInputs::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tInputs (*this, f, c);
  }

  tInputs& tInputs::
  operator= (const tInputs& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tUnNaming& > (*this) = x;
      this->ExtRef_ = x.ExtRef_;
    }

    return *this;
  }

  tInputs::
  ~tInputs ()
  {
  }

  // tExtRef
  //

  tExtRef::
  tExtRef (const iedName_type& iedName,
           const ldInst_type& ldInst,
           const lnClass_type& lnClass,
           const lnInst_type& lnInst,
           const doName_type& doName)
  : ::xml_schema::type (),
    iedName_ (iedName, this),
    ldInst_ (ldInst, this),
    prefix_ (this),
    lnClass_ (lnClass, this),
    lnInst_ (lnInst, this),
    doName_ (doName, this),
    daName_ (this),
    intAddr_ (this)
  {
  }

  tExtRef::
  tExtRef (const tExtRef& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    iedName_ (x.iedName_, f, this),
    ldInst_ (x.ldInst_, f, this),
    prefix_ (x.prefix_, f, this),
    lnClass_ (x.lnClass_, f, this),
    lnInst_ (x.lnInst_, f, this),
    doName_ (x.doName_, f, this),
    daName_ (x.daName_, f, this),
    intAddr_ (x.intAddr_, f, this)
  {
  }

  tExtRef::
  tExtRef (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    iedName_ (this),
    ldInst_ (this),
    prefix_ (this),
    lnClass_ (this),
    lnInst_ (this),
    doName_ (this),
    daName_ (this),
    intAddr_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void tExtRef::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "iedName" && n.namespace_ ().empty ())
      {
        this->iedName_.set (iedName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ldInst" && n.namespace_ ().empty ())
      {
        this->ldInst_.set (ldInst_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "prefix" && n.namespace_ ().empty ())
      {
        this->prefix_.set (prefix_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "lnClass" && n.namespace_ ().empty ())
      {
        this->lnClass_.set (lnClass_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "lnInst" && n.namespace_ ().empty ())
      {
        this->lnInst_.set (lnInst_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "doName" && n.namespace_ ().empty ())
      {
        this->doName_.set (doName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "daName" && n.namespace_ ().empty ())
      {
        this->daName_.set (daName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "intAddr" && n.namespace_ ().empty ())
      {
        this->intAddr_.set (intAddr_traits::create (i, f, this));
        continue;
      }
    }

    if (!iedName_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "iedName",
        "");
    }

    if (!ldInst_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ldInst",
        "");
    }

    if (!lnClass_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "lnClass",
        "");
    }

    if (!lnInst_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "lnInst",
        "");
    }

    if (!doName_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "doName",
        "");
    }
  }

  tExtRef* tExtRef::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tExtRef (*this, f, c);
  }

  tExtRef& tExtRef::
  operator= (const tExtRef& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->iedName_ = x.iedName_;
      this->ldInst_ = x.ldInst_;
      this->prefix_ = x.prefix_;
      this->lnClass_ = x.lnClass_;
      this->lnInst_ = x.lnInst_;
      this->doName_ = x.doName_;
      this->daName_ = x.daName_;
      this->intAddr_ = x.intAddr_;
    }

    return *this;
  }

  tExtRef::
  ~tExtRef ()
  {
  }

  // tLog
  //

  tLog::
  tLog ()
  : ::SCL::tAnyContentFromOtherNamespace ()
  {
  }

  tLog::
  tLog (const tLog& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::SCL::tAnyContentFromOtherNamespace (x, f, c)
  {
  }

  tLog::
  tLog (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::SCL::tAnyContentFromOtherNamespace (e, f, c)
  {
  }

  tLog* tLog::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tLog (*this, f, c);
  }

  tLog::
  ~tLog ()
  {
  }

  // tControlWithIEDName
  //

  tControlWithIEDName::
  tControlWithIEDName (const name_type& name)
  : ::SCL::tControl (name),
    IEDName_ (this),
    confRev_ (this)
  {
  }

  tControlWithIEDName::
  tControlWithIEDName (const tControlWithIEDName& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::SCL::tControl (x, f, c),
    IEDName_ (x.IEDName_, f, this),
    confRev_ (x.confRev_, f, this)
  {
  }

  tControlWithIEDName::
  tControlWithIEDName (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::SCL::tControl (e, f | ::xml_schema::flags::base, c),
    IEDName_ (this),
    confRev_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tControlWithIEDName::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tControl::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // IEDName
      //
      if (n.name () == "IEDName" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< IEDName_type > r (
          IEDName_traits::create (i, f, this));

        this->IEDName_.push_back (r);
        continue;
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "confRev" && n.namespace_ ().empty ())
      {
        this->confRev_.set (confRev_traits::create (i, f, this));
        continue;
      }
    }
  }

  tControlWithIEDName* tControlWithIEDName::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tControlWithIEDName (*this, f, c);
  }

  tControlWithIEDName& tControlWithIEDName::
  operator= (const tControlWithIEDName& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tControl& > (*this) = x;
      this->IEDName_ = x.IEDName_;
      this->confRev_ = x.confRev_;
    }

    return *this;
  }

  tControlWithIEDName::
  ~tControlWithIEDName ()
  {
  }

  // tGSEControl
  //

  const tGSEControl::type_type tGSEControl::type_default_value_ (
    "GOOSE");

  tGSEControl::
  tGSEControl (const name_type& name,
               const appID_type& appID)
  : ::SCL::tControlWithIEDName (name),
    type_ (type_default_value (), this),
    appID_ (appID, this)
  {
  }

  tGSEControl::
  tGSEControl (const tGSEControl& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::SCL::tControlWithIEDName (x, f, c),
    type_ (x.type_, f, this),
    appID_ (x.appID_, f, this)
  {
  }

  tGSEControl::
  tGSEControl (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::SCL::tControlWithIEDName (e, f | ::xml_schema::flags::base, c),
    type_ (this),
    appID_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tGSEControl::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tControlWithIEDName::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "appID" && n.namespace_ ().empty ())
      {
        this->appID_.set (appID_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      this->type_.set (type_default_value ());
    }

    if (!appID_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "appID",
        "");
    }
  }

  tGSEControl* tGSEControl::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tGSEControl (*this, f, c);
  }

  tGSEControl& tGSEControl::
  operator= (const tGSEControl& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tControlWithIEDName& > (*this) = x;
      this->type_ = x.type_;
      this->appID_ = x.appID_;
    }

    return *this;
  }

  tGSEControl::
  ~tGSEControl ()
  {
  }

  // tSampledValueControl
  //

  tSampledValueControl::
  tSampledValueControl (const name_type& name,
                        const SmvOpts_type& SmvOpts,
                        const smvID_type& smvID,
                        const smpRate_type& smpRate,
                        const nofASDU_type& nofASDU)
  : ::SCL::tControlWithIEDName (name),
    SmvOpts_ (SmvOpts, this),
    smvID_ (smvID, this),
    multicast_ (multicast_default_value (), this),
    smpRate_ (smpRate, this),
    nofASDU_ (nofASDU, this)
  {
  }

  tSampledValueControl::
  tSampledValueControl (const name_type& name,
                        ::std::auto_ptr< SmvOpts_type > SmvOpts,
                        const smvID_type& smvID,
                        const smpRate_type& smpRate,
                        const nofASDU_type& nofASDU)
  : ::SCL::tControlWithIEDName (name),
    SmvOpts_ (SmvOpts, this),
    smvID_ (smvID, this),
    multicast_ (multicast_default_value (), this),
    smpRate_ (smpRate, this),
    nofASDU_ (nofASDU, this)
  {
  }

  tSampledValueControl::
  tSampledValueControl (const tSampledValueControl& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::SCL::tControlWithIEDName (x, f, c),
    SmvOpts_ (x.SmvOpts_, f, this),
    smvID_ (x.smvID_, f, this),
    multicast_ (x.multicast_, f, this),
    smpRate_ (x.smpRate_, f, this),
    nofASDU_ (x.nofASDU_, f, this)
  {
  }

  tSampledValueControl::
  tSampledValueControl (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::SCL::tControlWithIEDName (e, f | ::xml_schema::flags::base, c),
    SmvOpts_ (this),
    smvID_ (this),
    multicast_ (this),
    smpRate_ (this),
    nofASDU_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tSampledValueControl::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tControlWithIEDName::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // SmvOpts
      //
      if (n.name () == "SmvOpts" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< SmvOpts_type > r (
          SmvOpts_traits::create (i, f, this));

        if (!SmvOpts_.present ())
        {
          this->SmvOpts_.set (r);
          continue;
        }
      }

      break;
    }

    if (!SmvOpts_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "SmvOpts",
        "http://www.iec.ch/61850/2006/SCL");
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "smvID" && n.namespace_ ().empty ())
      {
        this->smvID_.set (smvID_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "multicast" && n.namespace_ ().empty ())
      {
        this->multicast_.set (multicast_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "smpRate" && n.namespace_ ().empty ())
      {
        this->smpRate_.set (smpRate_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "nofASDU" && n.namespace_ ().empty ())
      {
        this->nofASDU_.set (nofASDU_traits::create (i, f, this));
        continue;
      }
    }

    if (!smvID_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "smvID",
        "");
    }

    if (!multicast_.present ())
    {
      this->multicast_.set (multicast_default_value ());
    }

    if (!smpRate_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "smpRate",
        "");
    }

    if (!nofASDU_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "nofASDU",
        "");
    }
  }

  tSampledValueControl* tSampledValueControl::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tSampledValueControl (*this, f, c);
  }

  tSampledValueControl& tSampledValueControl::
  operator= (const tSampledValueControl& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tControlWithIEDName& > (*this) = x;
      this->SmvOpts_ = x.SmvOpts_;
      this->smvID_ = x.smvID_;
      this->multicast_ = x.multicast_;
      this->smpRate_ = x.smpRate_;
      this->nofASDU_ = x.nofASDU_;
    }

    return *this;
  }

  tSampledValueControl::
  ~tSampledValueControl ()
  {
  }

  // tSettingControl
  //

  tSettingControl::
  tSettingControl (const numOfSGs_type& numOfSGs)
  : ::SCL::tUnNaming (),
    numOfSGs_ (numOfSGs, this),
    actSG_ (actSG_default_value (), this)
  {
  }

  tSettingControl::
  tSettingControl (const tSettingControl& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::SCL::tUnNaming (x, f, c),
    numOfSGs_ (x.numOfSGs_, f, this),
    actSG_ (x.actSG_, f, this)
  {
  }

  tSettingControl::
  tSettingControl (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::SCL::tUnNaming (e, f | ::xml_schema::flags::base, c),
    numOfSGs_ (this),
    actSG_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tSettingControl::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tUnNaming::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "numOfSGs" && n.namespace_ ().empty ())
      {
        this->numOfSGs_.set (numOfSGs_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "actSG" && n.namespace_ ().empty ())
      {
        this->actSG_.set (actSG_traits::create (i, f, this));
        continue;
      }
    }

    if (!numOfSGs_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "numOfSGs",
        "");
    }

    if (!actSG_.present ())
    {
      this->actSG_.set (actSG_default_value ());
    }
  }

  tSettingControl* tSettingControl::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tSettingControl (*this, f, c);
  }

  tSettingControl& tSettingControl::
  operator= (const tSettingControl& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tUnNaming& > (*this) = x;
      this->numOfSGs_ = x.numOfSGs_;
      this->actSG_ = x.actSG_;
    }

    return *this;
  }

  tSettingControl::
  ~tSettingControl ()
  {
  }

  // tSCLControl
  //

  tSCLControl::
  tSCLControl ()
  : ::SCL::tUnNaming ()
  {
  }

  tSCLControl::
  tSCLControl (const tSCLControl& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::SCL::tUnNaming (x, f, c)
  {
  }

  tSCLControl::
  tSCLControl (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::SCL::tUnNaming (e, f, c)
  {
  }

  tSCLControl* tSCLControl::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tSCLControl (*this, f, c);
  }

  tSCLControl::
  ~tSCLControl ()
  {
  }

  // tDOI
  //

  tDOI::
  tDOI (const name_type& name)
  : ::SCL::tUnNaming (),
    SDI_ (this),
    DAI_ (this),
    name_ (name, this),
    ix_ (this),
    accessControl_ (this)
  {
  }

  tDOI::
  tDOI (const tDOI& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::SCL::tUnNaming (x, f, c),
    SDI_ (x.SDI_, f, this),
    DAI_ (x.DAI_, f, this),
    name_ (x.name_, f, this),
    ix_ (x.ix_, f, this),
    accessControl_ (x.accessControl_, f, this)
  {
  }

  tDOI::
  tDOI (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::SCL::tUnNaming (e, f | ::xml_schema::flags::base, c),
    SDI_ (this),
    DAI_ (this),
    name_ (this),
    ix_ (this),
    accessControl_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tDOI::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tUnNaming::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // SDI
      //
      if (n.name () == "SDI" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< SDI_type > r (
          SDI_traits::create (i, f, this));

        this->SDI_.push_back (r);
        continue;
      }

      // DAI
      //
      if (n.name () == "DAI" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< DAI_type > r (
          DAI_traits::create (i, f, this));

        this->DAI_.push_back (r);
        continue;
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ix" && n.namespace_ ().empty ())
      {
        this->ix_.set (ix_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "accessControl" && n.namespace_ ().empty ())
      {
        this->accessControl_.set (accessControl_traits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  tDOI* tDOI::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tDOI (*this, f, c);
  }

  tDOI& tDOI::
  operator= (const tDOI& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tUnNaming& > (*this) = x;
      this->SDI_ = x.SDI_;
      this->DAI_ = x.DAI_;
      this->name_ = x.name_;
      this->ix_ = x.ix_;
      this->accessControl_ = x.accessControl_;
    }

    return *this;
  }

  tDOI::
  ~tDOI ()
  {
  }

  // tSDI
  //

  tSDI::
  tSDI (const name_type& name)
  : ::SCL::tUnNaming (),
    SDI_ (this),
    DAI_ (this),
    name_ (name, this),
    ix_ (this)
  {
  }

  tSDI::
  tSDI (const tSDI& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::SCL::tUnNaming (x, f, c),
    SDI_ (x.SDI_, f, this),
    DAI_ (x.DAI_, f, this),
    name_ (x.name_, f, this),
    ix_ (x.ix_, f, this)
  {
  }

  tSDI::
  tSDI (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::SCL::tUnNaming (e, f | ::xml_schema::flags::base, c),
    SDI_ (this),
    DAI_ (this),
    name_ (this),
    ix_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tSDI::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tUnNaming::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // SDI
      //
      if (n.name () == "SDI" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< SDI_type > r (
          SDI_traits::create (i, f, this));

        this->SDI_.push_back (r);
        continue;
      }

      // DAI
      //
      if (n.name () == "DAI" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< DAI_type > r (
          DAI_traits::create (i, f, this));

        this->DAI_.push_back (r);
        continue;
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ix" && n.namespace_ ().empty ())
      {
        this->ix_.set (ix_traits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  tSDI* tSDI::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tSDI (*this, f, c);
  }

  tSDI& tSDI::
  operator= (const tSDI& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tUnNaming& > (*this) = x;
      this->SDI_ = x.SDI_;
      this->DAI_ = x.DAI_;
      this->name_ = x.name_;
      this->ix_ = x.ix_;
    }

    return *this;
  }

  tSDI::
  ~tSDI ()
  {
  }

  // tDAI
  //

  const tDAI::valKind_type tDAI::valKind_default_value_ (
    "Set");

  tDAI::
  tDAI (const name_type& name)
  : ::SCL::tUnNaming (),
    Val_ (this),
    name_ (name, this),
    sAddr_ (this),
    valKind_ (valKind_default_value (), this),
    ix_ (this)
  {
  }

  tDAI::
  tDAI (const tDAI& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::SCL::tUnNaming (x, f, c),
    Val_ (x.Val_, f, this),
    name_ (x.name_, f, this),
    sAddr_ (x.sAddr_, f, this),
    valKind_ (x.valKind_, f, this),
    ix_ (x.ix_, f, this)
  {
  }

  tDAI::
  tDAI (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::SCL::tUnNaming (e, f | ::xml_schema::flags::base, c),
    Val_ (this),
    name_ (this),
    sAddr_ (this),
    valKind_ (this),
    ix_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tDAI::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tUnNaming::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Val
      //
      if (n.name () == "Val" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< Val_type > r (
          Val_traits::create (i, f, this));

        this->Val_.push_back (r);
        continue;
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sAddr" && n.namespace_ ().empty ())
      {
        this->sAddr_.set (sAddr_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "valKind" && n.namespace_ ().empty ())
      {
        this->valKind_.set (valKind_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ix" && n.namespace_ ().empty ())
      {
        this->ix_.set (ix_traits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!valKind_.present ())
    {
      this->valKind_.set (valKind_default_value ());
    }
  }

  tDAI* tDAI::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tDAI (*this, f, c);
  }

  tDAI& tDAI::
  operator= (const tDAI& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tUnNaming& > (*this) = x;
      this->Val_ = x.Val_;
      this->name_ = x.name_;
      this->sAddr_ = x.sAddr_;
      this->valKind_ = x.valKind_;
      this->ix_ = x.ix_;
    }

    return *this;
  }

  tDAI::
  ~tDAI ()
  {
  }

  // tServiceYesNo
  //

  tServiceYesNo::
  tServiceYesNo ()
  : ::xml_schema::type ()
  {
  }

  tServiceYesNo::
  tServiceYesNo (const tServiceYesNo& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c)
  {
  }

  tServiceYesNo::
  tServiceYesNo (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f, c)
  {
  }

  tServiceYesNo::
  tServiceYesNo (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (a, f, c)
  {
  }

  tServiceYesNo::
  tServiceYesNo (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (s, e, f, c)
  {
  }

  tServiceYesNo* tServiceYesNo::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tServiceYesNo (*this, f, c);
  }

  tServiceYesNo::
  ~tServiceYesNo ()
  {
  }

  // tServiceWithMax
  //

  tServiceWithMax::
  tServiceWithMax (const max_type& max)
  : ::xml_schema::type (),
    max_ (max, this)
  {
  }

  tServiceWithMax::
  tServiceWithMax (const tServiceWithMax& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    max_ (x.max_, f, this)
  {
  }

  tServiceWithMax::
  tServiceWithMax (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    max_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void tServiceWithMax::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "max" && n.namespace_ ().empty ())
      {
        this->max_.set (max_traits::create (i, f, this));
        continue;
      }
    }

    if (!max_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "max",
        "");
    }
  }

  tServiceWithMax* tServiceWithMax::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tServiceWithMax (*this, f, c);
  }

  tServiceWithMax& tServiceWithMax::
  operator= (const tServiceWithMax& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->max_ = x.max_;
    }

    return *this;
  }

  tServiceWithMax::
  ~tServiceWithMax ()
  {
  }

  // tServiceWithMaxAndMaxAttributes
  //

  tServiceWithMaxAndMaxAttributes::
  tServiceWithMaxAndMaxAttributes (const max_type& max)
  : ::SCL::tServiceWithMax (max),
    maxAttributes_ (this)
  {
  }

  tServiceWithMaxAndMaxAttributes::
  tServiceWithMaxAndMaxAttributes (const tServiceWithMaxAndMaxAttributes& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
  : ::SCL::tServiceWithMax (x, f, c),
    maxAttributes_ (x.maxAttributes_, f, this)
  {
  }

  tServiceWithMaxAndMaxAttributes::
  tServiceWithMaxAndMaxAttributes (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
  : ::SCL::tServiceWithMax (e, f | ::xml_schema::flags::base, c),
    maxAttributes_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void tServiceWithMaxAndMaxAttributes::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tServiceWithMax::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "maxAttributes" && n.namespace_ ().empty ())
      {
        this->maxAttributes_.set (maxAttributes_traits::create (i, f, this));
        continue;
      }
    }
  }

  tServiceWithMaxAndMaxAttributes* tServiceWithMaxAndMaxAttributes::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tServiceWithMaxAndMaxAttributes (*this, f, c);
  }

  tServiceWithMaxAndMaxAttributes& tServiceWithMaxAndMaxAttributes::
  operator= (const tServiceWithMaxAndMaxAttributes& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tServiceWithMax& > (*this) = x;
      this->maxAttributes_ = x.maxAttributes_;
    }

    return *this;
  }

  tServiceWithMaxAndMaxAttributes::
  ~tServiceWithMaxAndMaxAttributes ()
  {
  }

  // tServiceWithMaxAndModify
  //

  tServiceWithMaxAndModify::
  tServiceWithMaxAndModify (const max_type& max)
  : ::SCL::tServiceWithMax (max),
    modify_ (modify_default_value (), this)
  {
  }

  tServiceWithMaxAndModify::
  tServiceWithMaxAndModify (const tServiceWithMaxAndModify& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::SCL::tServiceWithMax (x, f, c),
    modify_ (x.modify_, f, this)
  {
  }

  tServiceWithMaxAndModify::
  tServiceWithMaxAndModify (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::SCL::tServiceWithMax (e, f | ::xml_schema::flags::base, c),
    modify_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void tServiceWithMaxAndModify::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tServiceWithMax::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "modify" && n.namespace_ ().empty ())
      {
        this->modify_.set (modify_traits::create (i, f, this));
        continue;
      }
    }

    if (!modify_.present ())
    {
      this->modify_.set (modify_default_value ());
    }
  }

  tServiceWithMaxAndModify* tServiceWithMaxAndModify::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tServiceWithMaxAndModify (*this, f, c);
  }

  tServiceWithMaxAndModify& tServiceWithMaxAndModify::
  operator= (const tServiceWithMaxAndModify& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tServiceWithMax& > (*this) = x;
      this->modify_ = x.modify_;
    }

    return *this;
  }

  tServiceWithMaxAndModify::
  ~tServiceWithMaxAndModify ()
  {
  }

  // tServiceWithMaxAndMaxAttributesAndModify
  //

  tServiceWithMaxAndMaxAttributesAndModify::
  tServiceWithMaxAndMaxAttributesAndModify (const max_type& max)
  : ::SCL::tServiceWithMaxAndMaxAttributes (max),
    modify_ (modify_default_value (), this)
  {
  }

  tServiceWithMaxAndMaxAttributesAndModify::
  tServiceWithMaxAndMaxAttributesAndModify (const tServiceWithMaxAndMaxAttributesAndModify& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
  : ::SCL::tServiceWithMaxAndMaxAttributes (x, f, c),
    modify_ (x.modify_, f, this)
  {
  }

  tServiceWithMaxAndMaxAttributesAndModify::
  tServiceWithMaxAndMaxAttributesAndModify (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
  : ::SCL::tServiceWithMaxAndMaxAttributes (e, f | ::xml_schema::flags::base, c),
    modify_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void tServiceWithMaxAndMaxAttributesAndModify::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tServiceWithMaxAndMaxAttributes::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "modify" && n.namespace_ ().empty ())
      {
        this->modify_.set (modify_traits::create (i, f, this));
        continue;
      }
    }

    if (!modify_.present ())
    {
      this->modify_.set (modify_default_value ());
    }
  }

  tServiceWithMaxAndMaxAttributesAndModify* tServiceWithMaxAndMaxAttributesAndModify::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tServiceWithMaxAndMaxAttributesAndModify (*this, f, c);
  }

  tServiceWithMaxAndMaxAttributesAndModify& tServiceWithMaxAndMaxAttributesAndModify::
  operator= (const tServiceWithMaxAndMaxAttributesAndModify& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tServiceWithMaxAndMaxAttributes& > (*this) = x;
      this->modify_ = x.modify_;
    }

    return *this;
  }

  tServiceWithMaxAndMaxAttributesAndModify::
  ~tServiceWithMaxAndMaxAttributesAndModify ()
  {
  }

  // tClientServices
  //

  tClientServices::
  tClientServices ()
  : ::xml_schema::type (),
    goose_ (goose_default_value (), this),
    gsse_ (gsse_default_value (), this),
    bufReport_ (bufReport_default_value (), this),
    unbufReport_ (unbufReport_default_value (), this),
    readLog_ (readLog_default_value (), this)
  {
  }

  tClientServices::
  tClientServices (const tClientServices& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    goose_ (x.goose_, f, this),
    gsse_ (x.gsse_, f, this),
    bufReport_ (x.bufReport_, f, this),
    unbufReport_ (x.unbufReport_, f, this),
    readLog_ (x.readLog_, f, this)
  {
  }

  tClientServices::
  tClientServices (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    goose_ (this),
    gsse_ (this),
    bufReport_ (this),
    unbufReport_ (this),
    readLog_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void tClientServices::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "goose" && n.namespace_ ().empty ())
      {
        this->goose_.set (goose_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "gsse" && n.namespace_ ().empty ())
      {
        this->gsse_.set (gsse_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "bufReport" && n.namespace_ ().empty ())
      {
        this->bufReport_.set (bufReport_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "unbufReport" && n.namespace_ ().empty ())
      {
        this->unbufReport_.set (unbufReport_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "readLog" && n.namespace_ ().empty ())
      {
        this->readLog_.set (readLog_traits::create (i, f, this));
        continue;
      }
    }

    if (!goose_.present ())
    {
      this->goose_.set (goose_default_value ());
    }

    if (!gsse_.present ())
    {
      this->gsse_.set (gsse_default_value ());
    }

    if (!bufReport_.present ())
    {
      this->bufReport_.set (bufReport_default_value ());
    }

    if (!unbufReport_.present ())
    {
      this->unbufReport_.set (unbufReport_default_value ());
    }

    if (!readLog_.present ())
    {
      this->readLog_.set (readLog_default_value ());
    }
  }

  tClientServices* tClientServices::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tClientServices (*this, f, c);
  }

  tClientServices& tClientServices::
  operator= (const tClientServices& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->goose_ = x.goose_;
      this->gsse_ = x.gsse_;
      this->bufReport_ = x.bufReport_;
      this->unbufReport_ = x.unbufReport_;
      this->readLog_ = x.readLog_;
    }

    return *this;
  }

  tClientServices::
  ~tClientServices ()
  {
  }

  // tServiceSettings
  //

  const tServiceSettings::cbName_type tServiceSettings::cbName_default_value_ (
    "Fix");

  const tServiceSettings::datSet_type tServiceSettings::datSet_default_value_ (
    "Fix");

  tServiceSettings::
  tServiceSettings ()
  : ::xml_schema::type (),
    cbName_ (cbName_default_value (), this),
    datSet_ (datSet_default_value (), this)
  {
  }

  tServiceSettings::
  tServiceSettings (const tServiceSettings& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    cbName_ (x.cbName_, f, this),
    datSet_ (x.datSet_, f, this)
  {
  }

  tServiceSettings::
  tServiceSettings (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    cbName_ (this),
    datSet_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void tServiceSettings::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "cbName" && n.namespace_ ().empty ())
      {
        this->cbName_.set (cbName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "datSet" && n.namespace_ ().empty ())
      {
        this->datSet_.set (datSet_traits::create (i, f, this));
        continue;
      }
    }

    if (!cbName_.present ())
    {
      this->cbName_.set (cbName_default_value ());
    }

    if (!datSet_.present ())
    {
      this->datSet_.set (datSet_default_value ());
    }
  }

  tServiceSettings* tServiceSettings::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tServiceSettings (*this, f, c);
  }

  tServiceSettings& tServiceSettings::
  operator= (const tServiceSettings& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->cbName_ = x.cbName_;
      this->datSet_ = x.datSet_;
    }

    return *this;
  }

  tServiceSettings::
  ~tServiceSettings ()
  {
  }

  // tReportSettings
  //

  const tReportSettings::rptID_type tReportSettings::rptID_default_value_ (
    "Fix");

  const tReportSettings::optFields_type tReportSettings::optFields_default_value_ (
    "Fix");

  const tReportSettings::bufTime_type tReportSettings::bufTime_default_value_ (
    "Fix");

  const tReportSettings::trgOps_type tReportSettings::trgOps_default_value_ (
    "Fix");

  const tReportSettings::intgPd_type tReportSettings::intgPd_default_value_ (
    "Fix");

  tReportSettings::
  tReportSettings ()
  : ::SCL::tServiceSettings (),
    rptID_ (rptID_default_value (), this),
    optFields_ (optFields_default_value (), this),
    bufTime_ (bufTime_default_value (), this),
    trgOps_ (trgOps_default_value (), this),
    intgPd_ (intgPd_default_value (), this)
  {
  }

  tReportSettings::
  tReportSettings (const tReportSettings& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::SCL::tServiceSettings (x, f, c),
    rptID_ (x.rptID_, f, this),
    optFields_ (x.optFields_, f, this),
    bufTime_ (x.bufTime_, f, this),
    trgOps_ (x.trgOps_, f, this),
    intgPd_ (x.intgPd_, f, this)
  {
  }

  tReportSettings::
  tReportSettings (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::SCL::tServiceSettings (e, f | ::xml_schema::flags::base, c),
    rptID_ (this),
    optFields_ (this),
    bufTime_ (this),
    trgOps_ (this),
    intgPd_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void tReportSettings::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tServiceSettings::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "rptID" && n.namespace_ ().empty ())
      {
        this->rptID_.set (rptID_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "optFields" && n.namespace_ ().empty ())
      {
        this->optFields_.set (optFields_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "bufTime" && n.namespace_ ().empty ())
      {
        this->bufTime_.set (bufTime_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "trgOps" && n.namespace_ ().empty ())
      {
        this->trgOps_.set (trgOps_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "intgPd" && n.namespace_ ().empty ())
      {
        this->intgPd_.set (intgPd_traits::create (i, f, this));
        continue;
      }
    }

    if (!rptID_.present ())
    {
      this->rptID_.set (rptID_default_value ());
    }

    if (!optFields_.present ())
    {
      this->optFields_.set (optFields_default_value ());
    }

    if (!bufTime_.present ())
    {
      this->bufTime_.set (bufTime_default_value ());
    }

    if (!trgOps_.present ())
    {
      this->trgOps_.set (trgOps_default_value ());
    }

    if (!intgPd_.present ())
    {
      this->intgPd_.set (intgPd_default_value ());
    }
  }

  tReportSettings* tReportSettings::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tReportSettings (*this, f, c);
  }

  tReportSettings& tReportSettings::
  operator= (const tReportSettings& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tServiceSettings& > (*this) = x;
      this->rptID_ = x.rptID_;
      this->optFields_ = x.optFields_;
      this->bufTime_ = x.bufTime_;
      this->trgOps_ = x.trgOps_;
      this->intgPd_ = x.intgPd_;
    }

    return *this;
  }

  tReportSettings::
  ~tReportSettings ()
  {
  }

  // tLogSettings
  //

  const tLogSettings::logEna_type tLogSettings::logEna_default_value_ (
    "Fix");

  const tLogSettings::trgOps_type tLogSettings::trgOps_default_value_ (
    "Fix");

  const tLogSettings::intgPd_type tLogSettings::intgPd_default_value_ (
    "Fix");

  tLogSettings::
  tLogSettings ()
  : ::SCL::tServiceSettings (),
    logEna_ (logEna_default_value (), this),
    trgOps_ (trgOps_default_value (), this),
    intgPd_ (intgPd_default_value (), this)
  {
  }

  tLogSettings::
  tLogSettings (const tLogSettings& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::SCL::tServiceSettings (x, f, c),
    logEna_ (x.logEna_, f, this),
    trgOps_ (x.trgOps_, f, this),
    intgPd_ (x.intgPd_, f, this)
  {
  }

  tLogSettings::
  tLogSettings (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::SCL::tServiceSettings (e, f | ::xml_schema::flags::base, c),
    logEna_ (this),
    trgOps_ (this),
    intgPd_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void tLogSettings::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tServiceSettings::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "logEna" && n.namespace_ ().empty ())
      {
        this->logEna_.set (logEna_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "trgOps" && n.namespace_ ().empty ())
      {
        this->trgOps_.set (trgOps_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "intgPd" && n.namespace_ ().empty ())
      {
        this->intgPd_.set (intgPd_traits::create (i, f, this));
        continue;
      }
    }

    if (!logEna_.present ())
    {
      this->logEna_.set (logEna_default_value ());
    }

    if (!trgOps_.present ())
    {
      this->trgOps_.set (trgOps_default_value ());
    }

    if (!intgPd_.present ())
    {
      this->intgPd_.set (intgPd_default_value ());
    }
  }

  tLogSettings* tLogSettings::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tLogSettings (*this, f, c);
  }

  tLogSettings& tLogSettings::
  operator= (const tLogSettings& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tServiceSettings& > (*this) = x;
      this->logEna_ = x.logEna_;
      this->trgOps_ = x.trgOps_;
      this->intgPd_ = x.intgPd_;
    }

    return *this;
  }

  tLogSettings::
  ~tLogSettings ()
  {
  }

  // tGSESettings
  //

  const tGSESettings::appID_type tGSESettings::appID_default_value_ (
    "Fix");

  const tGSESettings::dataLabel_type tGSESettings::dataLabel_default_value_ (
    "Fix");

  tGSESettings::
  tGSESettings ()
  : ::SCL::tServiceSettings (),
    appID_ (appID_default_value (), this),
    dataLabel_ (dataLabel_default_value (), this)
  {
  }

  tGSESettings::
  tGSESettings (const tGSESettings& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::SCL::tServiceSettings (x, f, c),
    appID_ (x.appID_, f, this),
    dataLabel_ (x.dataLabel_, f, this)
  {
  }

  tGSESettings::
  tGSESettings (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::SCL::tServiceSettings (e, f | ::xml_schema::flags::base, c),
    appID_ (this),
    dataLabel_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void tGSESettings::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tServiceSettings::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "appID" && n.namespace_ ().empty ())
      {
        this->appID_.set (appID_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "dataLabel" && n.namespace_ ().empty ())
      {
        this->dataLabel_.set (dataLabel_traits::create (i, f, this));
        continue;
      }
    }

    if (!appID_.present ())
    {
      this->appID_.set (appID_default_value ());
    }

    if (!dataLabel_.present ())
    {
      this->dataLabel_.set (dataLabel_default_value ());
    }
  }

  tGSESettings* tGSESettings::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tGSESettings (*this, f, c);
  }

  tGSESettings& tGSESettings::
  operator= (const tGSESettings& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tServiceSettings& > (*this) = x;
      this->appID_ = x.appID_;
      this->dataLabel_ = x.dataLabel_;
    }

    return *this;
  }

  tGSESettings::
  ~tGSESettings ()
  {
  }

  // tSMVSettings
  //

  const tSMVSettings::svID_type tSMVSettings::svID_default_value_ (
    "Fix");

  const tSMVSettings::optFields_type tSMVSettings::optFields_default_value_ (
    "Fix");

  const tSMVSettings::smpRate2_type tSMVSettings::smpRate2_default_value_ (
    "Fix");

  tSMVSettings::
  tSMVSettings ()
  : ::SCL::tServiceSettings (),
    SmpRate1_ (this),
    svID_ (svID_default_value (), this),
    optFields_ (optFields_default_value (), this),
    smpRate2_ (smpRate2_default_value (), this)
  {
  }

  tSMVSettings::
  tSMVSettings (const tSMVSettings& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::SCL::tServiceSettings (x, f, c),
    SmpRate1_ (x.SmpRate1_, f, this),
    svID_ (x.svID_, f, this),
    optFields_ (x.optFields_, f, this),
    smpRate2_ (x.smpRate2_, f, this)
  {
  }

  tSMVSettings::
  tSMVSettings (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::SCL::tServiceSettings (e, f | ::xml_schema::flags::base, c),
    SmpRate1_ (this),
    svID_ (this),
    optFields_ (this),
    smpRate2_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tSMVSettings::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tServiceSettings::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // SmpRate1
      //
      if (n.name () == "SmpRate1" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< SmpRate1_type > r (
          SmpRate1_traits::create (i, f, this));

        this->SmpRate1_.push_back (r);
        continue;
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "svID" && n.namespace_ ().empty ())
      {
        this->svID_.set (svID_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "optFields" && n.namespace_ ().empty ())
      {
        this->optFields_.set (optFields_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "smpRate2" && n.namespace_ ().empty ())
      {
        this->smpRate2_.set (smpRate2_traits::create (i, f, this));
        continue;
      }
    }

    if (!svID_.present ())
    {
      this->svID_.set (svID_default_value ());
    }

    if (!optFields_.present ())
    {
      this->optFields_.set (optFields_default_value ());
    }

    if (!smpRate2_.present ())
    {
      this->smpRate2_.set (smpRate2_default_value ());
    }
  }

  tSMVSettings* tSMVSettings::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tSMVSettings (*this, f, c);
  }

  tSMVSettings& tSMVSettings::
  operator= (const tSMVSettings& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tServiceSettings& > (*this) = x;
      this->SmpRate1_ = x.SmpRate1_;
      this->svID_ = x.svID_;
      this->optFields_ = x.optFields_;
      this->smpRate2_ = x.smpRate2_;
    }

    return *this;
  }

  tSMVSettings::
  ~tSMVSettings ()
  {
  }

  // tConfLNs
  //

  tConfLNs::
  tConfLNs ()
  : ::xml_schema::type (),
    fixPrefix_ (fixPrefix_default_value (), this),
    fixLnInst_ (fixLnInst_default_value (), this)
  {
  }

  tConfLNs::
  tConfLNs (const tConfLNs& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    fixPrefix_ (x.fixPrefix_, f, this),
    fixLnInst_ (x.fixLnInst_, f, this)
  {
  }

  tConfLNs::
  tConfLNs (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    fixPrefix_ (this),
    fixLnInst_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void tConfLNs::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "fixPrefix" && n.namespace_ ().empty ())
      {
        this->fixPrefix_.set (fixPrefix_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "fixLnInst" && n.namespace_ ().empty ())
      {
        this->fixLnInst_.set (fixLnInst_traits::create (i, f, this));
        continue;
      }
    }

    if (!fixPrefix_.present ())
    {
      this->fixPrefix_.set (fixPrefix_default_value ());
    }

    if (!fixLnInst_.present ())
    {
      this->fixLnInst_.set (fixLnInst_default_value ());
    }
  }

  tConfLNs* tConfLNs::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tConfLNs (*this, f, c);
  }

  tConfLNs& tConfLNs::
  operator= (const tConfLNs& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->fixPrefix_ = x.fixPrefix_;
      this->fixLnInst_ = x.fixLnInst_;
    }

    return *this;
  }

  tConfLNs::
  ~tConfLNs ()
  {
  }

  // SettingGroups
  //

  SettingGroups::
  SettingGroups ()
  : ::xml_schema::type (),
    SGEdit_ (this),
    ConfSG_ (this)
  {
  }

  SettingGroups::
  SettingGroups (const SettingGroups& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    SGEdit_ (x.SGEdit_, f, this),
    ConfSG_ (x.ConfSG_, f, this)
  {
  }

  SettingGroups::
  SettingGroups (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    SGEdit_ (this),
    ConfSG_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void SettingGroups::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // SGEdit
      //
      if (n.name () == "SGEdit" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< SGEdit_type > r (
          SGEdit_traits::create (i, f, this));

        if (!this->SGEdit_)
        {
          this->SGEdit_.set (r);
          continue;
        }
      }

      // ConfSG
      //
      if (n.name () == "ConfSG" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< ConfSG_type > r (
          ConfSG_traits::create (i, f, this));

        if (!this->ConfSG_)
        {
          this->ConfSG_.set (r);
          continue;
        }
      }

      break;
    }
  }

  SettingGroups* SettingGroups::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SettingGroups (*this, f, c);
  }

  SettingGroups& SettingGroups::
  operator= (const SettingGroups& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->SGEdit_ = x.SGEdit_;
      this->ConfSG_ = x.ConfSG_;
    }

    return *this;
  }

  SettingGroups::
  ~SettingGroups ()
  {
  }

  // Authentication
  //

  Authentication::
  Authentication ()
  : ::xml_schema::type (),
    none_ (none_default_value (), this),
    password_ (password_default_value (), this),
    weak_ (weak_default_value (), this),
    strong_ (strong_default_value (), this),
    certificate_ (certificate_default_value (), this)
  {
  }

  Authentication::
  Authentication (const Authentication& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    none_ (x.none_, f, this),
    password_ (x.password_, f, this),
    weak_ (x.weak_, f, this),
    strong_ (x.strong_, f, this),
    certificate_ (x.certificate_, f, this)
  {
  }

  Authentication::
  Authentication (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    none_ (this),
    password_ (this),
    weak_ (this),
    strong_ (this),
    certificate_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Authentication::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "none" && n.namespace_ ().empty ())
      {
        this->none_.set (none_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "password" && n.namespace_ ().empty ())
      {
        this->password_.set (password_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "weak" && n.namespace_ ().empty ())
      {
        this->weak_.set (weak_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "strong" && n.namespace_ ().empty ())
      {
        this->strong_.set (strong_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "certificate" && n.namespace_ ().empty ())
      {
        this->certificate_.set (certificate_traits::create (i, f, this));
        continue;
      }
    }

    if (!none_.present ())
    {
      this->none_.set (none_default_value ());
    }

    if (!password_.present ())
    {
      this->password_.set (password_default_value ());
    }

    if (!weak_.present ())
    {
      this->weak_.set (weak_default_value ());
    }

    if (!strong_.present ())
    {
      this->strong_.set (strong_default_value ());
    }

    if (!certificate_.present ())
    {
      this->certificate_.set (certificate_default_value ());
    }
  }

  Authentication* Authentication::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Authentication (*this, f, c);
  }

  Authentication& Authentication::
  operator= (const Authentication& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->none_ = x.none_;
      this->password_ = x.password_;
      this->weak_ = x.weak_;
      this->strong_ = x.strong_;
      this->certificate_ = x.certificate_;
    }

    return *this;
  }

  Authentication::
  ~Authentication ()
  {
  }

  // LN0
  //

  LN0::
  LN0 (const lnType_type& lnType)
  : ::SCL::tLN0 (lnType)
  {
  }

  LN0::
  LN0 (const LN0& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::SCL::tLN0 (x, f, c)
  {
  }

  LN0::
  LN0 (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::SCL::tLN0 (e, f, c)
  {
  }

  LN0* LN0::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class LN0 (*this, f, c);
  }

  LN0::
  ~LN0 ()
  {
  }

  // OptFields
  //

  OptFields::
  OptFields ()
  : ::xml_schema::type (),
    seqNum_ (seqNum_default_value (), this),
    timeStamp_ (timeStamp_default_value (), this),
    dataSet_ (dataSet_default_value (), this),
    reasonCode_ (reasonCode_default_value (), this),
    dataRef_ (dataRef_default_value (), this),
    bufOvfl_ (bufOvfl_default_value (), this),
    entryID_ (entryID_default_value (), this),
    configRef_ (configRef_default_value (), this)
  {
  }

  OptFields::
  OptFields (const OptFields& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    seqNum_ (x.seqNum_, f, this),
    timeStamp_ (x.timeStamp_, f, this),
    dataSet_ (x.dataSet_, f, this),
    reasonCode_ (x.reasonCode_, f, this),
    dataRef_ (x.dataRef_, f, this),
    bufOvfl_ (x.bufOvfl_, f, this),
    entryID_ (x.entryID_, f, this),
    configRef_ (x.configRef_, f, this)
  {
  }

  OptFields::
  OptFields (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    seqNum_ (this),
    timeStamp_ (this),
    dataSet_ (this),
    reasonCode_ (this),
    dataRef_ (this),
    bufOvfl_ (this),
    entryID_ (this),
    configRef_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void OptFields::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "seqNum" && n.namespace_ ().empty ())
      {
        this->seqNum_.set (seqNum_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "timeStamp" && n.namespace_ ().empty ())
      {
        this->timeStamp_.set (timeStamp_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "dataSet" && n.namespace_ ().empty ())
      {
        this->dataSet_.set (dataSet_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "reasonCode" && n.namespace_ ().empty ())
      {
        this->reasonCode_.set (reasonCode_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "dataRef" && n.namespace_ ().empty ())
      {
        this->dataRef_.set (dataRef_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "bufOvfl" && n.namespace_ ().empty ())
      {
        this->bufOvfl_.set (bufOvfl_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "entryID" && n.namespace_ ().empty ())
      {
        this->entryID_.set (entryID_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "configRef" && n.namespace_ ().empty ())
      {
        this->configRef_.set (configRef_traits::create (i, f, this));
        continue;
      }
    }

    if (!seqNum_.present ())
    {
      this->seqNum_.set (seqNum_default_value ());
    }

    if (!timeStamp_.present ())
    {
      this->timeStamp_.set (timeStamp_default_value ());
    }

    if (!dataSet_.present ())
    {
      this->dataSet_.set (dataSet_default_value ());
    }

    if (!reasonCode_.present ())
    {
      this->reasonCode_.set (reasonCode_default_value ());
    }

    if (!dataRef_.present ())
    {
      this->dataRef_.set (dataRef_default_value ());
    }

    if (!bufOvfl_.present ())
    {
      this->bufOvfl_.set (bufOvfl_default_value ());
    }

    if (!entryID_.present ())
    {
      this->entryID_.set (entryID_default_value ());
    }

    if (!configRef_.present ())
    {
      this->configRef_.set (configRef_default_value ());
    }
  }

  OptFields* OptFields::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class OptFields (*this, f, c);
  }

  OptFields& OptFields::
  operator= (const OptFields& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->seqNum_ = x.seqNum_;
      this->timeStamp_ = x.timeStamp_;
      this->dataSet_ = x.dataSet_;
      this->reasonCode_ = x.reasonCode_;
      this->dataRef_ = x.dataRef_;
      this->bufOvfl_ = x.bufOvfl_;
      this->entryID_ = x.entryID_;
      this->configRef_ = x.configRef_;
    }

    return *this;
  }

  OptFields::
  ~OptFields ()
  {
  }

  // SmvOpts
  //

  SmvOpts::
  SmvOpts ()
  : ::xml_schema::type (),
    refreshTime_ (refreshTime_default_value (), this),
    sampleSynchronized_ (sampleSynchronized_default_value (), this),
    sampleRate_ (sampleRate_default_value (), this),
    dataSet_ (dataSet_default_value (), this),
    security_ (security_default_value (), this)
  {
  }

  SmvOpts::
  SmvOpts (const SmvOpts& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    refreshTime_ (x.refreshTime_, f, this),
    sampleSynchronized_ (x.sampleSynchronized_, f, this),
    sampleRate_ (x.sampleRate_, f, this),
    dataSet_ (x.dataSet_, f, this),
    security_ (x.security_, f, this)
  {
  }

  SmvOpts::
  SmvOpts (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    refreshTime_ (this),
    sampleSynchronized_ (this),
    sampleRate_ (this),
    dataSet_ (this),
    security_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void SmvOpts::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "refreshTime" && n.namespace_ ().empty ())
      {
        this->refreshTime_.set (refreshTime_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sampleSynchronized" && n.namespace_ ().empty ())
      {
        this->sampleSynchronized_.set (sampleSynchronized_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sampleRate" && n.namespace_ ().empty ())
      {
        this->sampleRate_.set (sampleRate_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "dataSet" && n.namespace_ ().empty ())
      {
        this->dataSet_.set (dataSet_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "security" && n.namespace_ ().empty ())
      {
        this->security_.set (security_traits::create (i, f, this));
        continue;
      }
    }

    if (!refreshTime_.present ())
    {
      this->refreshTime_.set (refreshTime_default_value ());
    }

    if (!sampleSynchronized_.present ())
    {
      this->sampleSynchronized_.set (sampleSynchronized_default_value ());
    }

    if (!sampleRate_.present ())
    {
      this->sampleRate_.set (sampleRate_default_value ());
    }

    if (!dataSet_.present ())
    {
      this->dataSet_.set (dataSet_default_value ());
    }

    if (!security_.present ())
    {
      this->security_.set (security_default_value ());
    }
  }

  SmvOpts* SmvOpts::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SmvOpts (*this, f, c);
  }

  SmvOpts& SmvOpts::
  operator= (const SmvOpts& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->refreshTime_ = x.refreshTime_;
      this->sampleSynchronized_ = x.sampleSynchronized_;
      this->sampleRate_ = x.sampleRate_;
      this->dataSet_ = x.dataSet_;
      this->security_ = x.security_;
    }

    return *this;
  }

  SmvOpts::
  ~SmvOpts ()
  {
  }

  // SmpRate1
  //

  SmpRate1::
  SmpRate1 (const ::xml_schema::decimal& _xsd_decimal_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base)
  {
  }

  SmpRate1::
  SmpRate1 (const SmpRate1& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c)
  {
  }

  SmpRate1::
  SmpRate1 (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f, c)
  {
  }

  SmpRate1::
  SmpRate1 (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (a, f, c)
  {
  }

  SmpRate1::
  SmpRate1 (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (s, e, f, c)
  {
  }

  SmpRate1* SmpRate1::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SmpRate1 (*this, f, c);
  }

  SmpRate1::
  ~SmpRate1 ()
  {
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace SCL
{
  ::std::auto_ptr< ::SCL::LN0 >
  LN0_ (const ::std::string& u,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::SCL::LN0 > (
      ::SCL::LN0_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::SCL::LN0 >
  LN0_ (const ::std::string& u,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::SCL::LN0 > (
      ::SCL::LN0_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::SCL::LN0 >
  LN0_ (const ::std::string& u,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::SCL::LN0 > (
      ::SCL::LN0_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::SCL::LN0 >
  LN0_ (::std::istream& is,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::SCL::LN0_ (isrc, f, p);
  }

  ::std::auto_ptr< ::SCL::LN0 >
  LN0_ (::std::istream& is,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::SCL::LN0_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::SCL::LN0 >
  LN0_ (::std::istream& is,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::SCL::LN0_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::SCL::LN0 >
  LN0_ (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::SCL::LN0_ (isrc, f, p);
  }

  ::std::auto_ptr< ::SCL::LN0 >
  LN0_ (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::SCL::LN0_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::SCL::LN0 >
  LN0_ (::std::istream& is,
        const ::std::string& sid,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::SCL::LN0_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::SCL::LN0 >
  LN0_ (::xercesc::InputSource& i,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::SCL::LN0 > (
      ::SCL::LN0_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::SCL::LN0 >
  LN0_ (::xercesc::InputSource& i,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::SCL::LN0 > (
      ::SCL::LN0_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::SCL::LN0 >
  LN0_ (::xercesc::InputSource& i,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::SCL::LN0 > (
      ::SCL::LN0_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::SCL::LN0 >
  LN0_ (const ::xercesc::DOMDocument& doc,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::SCL::LN0 > (
        ::SCL::LN0_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "LN0" &&
        n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
    {
      ::std::auto_ptr< ::SCL::LN0 > r (
        ::xsd::cxx::tree::traits< ::SCL::LN0, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "LN0",
      "http://www.iec.ch/61850/2006/SCL");
  }

  ::std::auto_ptr< ::SCL::LN0 >
  LN0_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
        ::xml_schema::flags f,
        const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "LN0" &&
        n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
    {
      ::std::auto_ptr< ::SCL::LN0 > r (
        ::xsd::cxx::tree::traits< ::SCL::LN0, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "LN0",
      "http://www.iec.ch/61850/2006/SCL");
  }

  ::std::auto_ptr< ::SCL::tLN >
  LN (const ::std::string& u,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::SCL::tLN > (
      ::SCL::LN (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::SCL::tLN >
  LN (const ::std::string& u,
      ::xml_schema::error_handler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::SCL::tLN > (
      ::SCL::LN (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::SCL::tLN >
  LN (const ::std::string& u,
      ::xercesc::DOMErrorHandler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::SCL::tLN > (
      ::SCL::LN (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::SCL::tLN >
  LN (::std::istream& is,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::SCL::LN (isrc, f, p);
  }

  ::std::auto_ptr< ::SCL::tLN >
  LN (::std::istream& is,
      ::xml_schema::error_handler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::SCL::LN (isrc, h, f, p);
  }

  ::std::auto_ptr< ::SCL::tLN >
  LN (::std::istream& is,
      ::xercesc::DOMErrorHandler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::SCL::LN (isrc, h, f, p);
  }

  ::std::auto_ptr< ::SCL::tLN >
  LN (::std::istream& is,
      const ::std::string& sid,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::SCL::LN (isrc, f, p);
  }

  ::std::auto_ptr< ::SCL::tLN >
  LN (::std::istream& is,
      const ::std::string& sid,
      ::xml_schema::error_handler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::SCL::LN (isrc, h, f, p);
  }

  ::std::auto_ptr< ::SCL::tLN >
  LN (::std::istream& is,
      const ::std::string& sid,
      ::xercesc::DOMErrorHandler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::SCL::LN (isrc, h, f, p);
  }

  ::std::auto_ptr< ::SCL::tLN >
  LN (::xercesc::InputSource& i,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::SCL::tLN > (
      ::SCL::LN (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::SCL::tLN >
  LN (::xercesc::InputSource& i,
      ::xml_schema::error_handler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::SCL::tLN > (
      ::SCL::LN (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::SCL::tLN >
  LN (::xercesc::InputSource& i,
      ::xercesc::DOMErrorHandler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::SCL::tLN > (
      ::SCL::LN (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::SCL::tLN >
  LN (const ::xercesc::DOMDocument& doc,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::SCL::tLN > (
        ::SCL::LN (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "LN" &&
        n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
    {
      ::std::auto_ptr< ::SCL::tLN > r (
        ::xsd::cxx::tree::traits< ::SCL::tLN, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "LN",
      "http://www.iec.ch/61850/2006/SCL");
  }

  ::std::auto_ptr< ::SCL::tLN >
  LN (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
      ::xml_schema::flags f,
      const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "LN" &&
        n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
    {
      ::std::auto_ptr< ::SCL::tLN > r (
        ::xsd::cxx::tree::traits< ::SCL::tLN, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "LN",
      "http://www.iec.ch/61850/2006/SCL");
  }

  ::std::auto_ptr< ::SCL::tIED >
  IED (const ::std::string& u,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::SCL::tIED > (
      ::SCL::IED (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::SCL::tIED >
  IED (const ::std::string& u,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::SCL::tIED > (
      ::SCL::IED (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::SCL::tIED >
  IED (const ::std::string& u,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::SCL::tIED > (
      ::SCL::IED (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::SCL::tIED >
  IED (::std::istream& is,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::SCL::IED (isrc, f, p);
  }

  ::std::auto_ptr< ::SCL::tIED >
  IED (::std::istream& is,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::SCL::IED (isrc, h, f, p);
  }

  ::std::auto_ptr< ::SCL::tIED >
  IED (::std::istream& is,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::SCL::IED (isrc, h, f, p);
  }

  ::std::auto_ptr< ::SCL::tIED >
  IED (::std::istream& is,
       const ::std::string& sid,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::SCL::IED (isrc, f, p);
  }

  ::std::auto_ptr< ::SCL::tIED >
  IED (::std::istream& is,
       const ::std::string& sid,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::SCL::IED (isrc, h, f, p);
  }

  ::std::auto_ptr< ::SCL::tIED >
  IED (::std::istream& is,
       const ::std::string& sid,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::SCL::IED (isrc, h, f, p);
  }

  ::std::auto_ptr< ::SCL::tIED >
  IED (::xercesc::InputSource& i,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::SCL::tIED > (
      ::SCL::IED (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::SCL::tIED >
  IED (::xercesc::InputSource& i,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::SCL::tIED > (
      ::SCL::IED (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::SCL::tIED >
  IED (::xercesc::InputSource& i,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::SCL::tIED > (
      ::SCL::IED (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::SCL::tIED >
  IED (const ::xercesc::DOMDocument& doc,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::SCL::tIED > (
        ::SCL::IED (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "IED" &&
        n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
    {
      ::std::auto_ptr< ::SCL::tIED > r (
        ::xsd::cxx::tree::traits< ::SCL::tIED, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "IED",
      "http://www.iec.ch/61850/2006/SCL");
  }

  ::std::auto_ptr< ::SCL::tIED >
  IED (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
       ::xml_schema::flags f,
       const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "IED" &&
        n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
    {
      ::std::auto_ptr< ::SCL::tIED > r (
        ::xsd::cxx::tree::traits< ::SCL::tIED, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "IED",
      "http://www.iec.ch/61850/2006/SCL");
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

