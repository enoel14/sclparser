// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "SCL_Communication.hxx"

namespace SCL
{
  // tControlBlock
  // 

  const tControlBlock::Address_optional& tControlBlock::
  Address () const
  {
    return this->Address_;
  }

  tControlBlock::Address_optional& tControlBlock::
  Address ()
  {
    return this->Address_;
  }

  void tControlBlock::
  Address (const Address_type& x)
  {
    this->Address_.set (x);
  }

  void tControlBlock::
  Address (const Address_optional& x)
  {
    this->Address_ = x;
  }

  void tControlBlock::
  Address (::std::auto_ptr< Address_type > x)
  {
    this->Address_.set (x);
  }

  const tControlBlock::ldInst_type& tControlBlock::
  ldInst () const
  {
    return this->ldInst_.get ();
  }

  tControlBlock::ldInst_type& tControlBlock::
  ldInst ()
  {
    return this->ldInst_.get ();
  }

  void tControlBlock::
  ldInst (const ldInst_type& x)
  {
    this->ldInst_.set (x);
  }

  void tControlBlock::
  ldInst (::std::auto_ptr< ldInst_type > x)
  {
    this->ldInst_.set (x);
  }

  const tControlBlock::cbName_type& tControlBlock::
  cbName () const
  {
    return this->cbName_.get ();
  }

  tControlBlock::cbName_type& tControlBlock::
  cbName ()
  {
    return this->cbName_.get ();
  }

  void tControlBlock::
  cbName (const cbName_type& x)
  {
    this->cbName_.set (x);
  }

  void tControlBlock::
  cbName (::std::auto_ptr< cbName_type > x)
  {
    this->cbName_.set (x);
  }


  // tCommunication
  // 

  const tCommunication::SubNetwork_sequence& tCommunication::
  SubNetwork () const
  {
    return this->SubNetwork_;
  }

  tCommunication::SubNetwork_sequence& tCommunication::
  SubNetwork ()
  {
    return this->SubNetwork_;
  }

  void tCommunication::
  SubNetwork (const SubNetwork_sequence& s)
  {
    this->SubNetwork_ = s;
  }


  // tSubNetwork
  // 

  const tSubNetwork::BitRate_optional& tSubNetwork::
  BitRate () const
  {
    return this->BitRate_;
  }

  tSubNetwork::BitRate_optional& tSubNetwork::
  BitRate ()
  {
    return this->BitRate_;
  }

  void tSubNetwork::
  BitRate (const BitRate_type& x)
  {
    this->BitRate_.set (x);
  }

  void tSubNetwork::
  BitRate (const BitRate_optional& x)
  {
    this->BitRate_ = x;
  }

  void tSubNetwork::
  BitRate (::std::auto_ptr< BitRate_type > x)
  {
    this->BitRate_.set (x);
  }

  const tSubNetwork::ConnectedAP_sequence& tSubNetwork::
  ConnectedAP () const
  {
    return this->ConnectedAP_;
  }

  tSubNetwork::ConnectedAP_sequence& tSubNetwork::
  ConnectedAP ()
  {
    return this->ConnectedAP_;
  }

  void tSubNetwork::
  ConnectedAP (const ConnectedAP_sequence& s)
  {
    this->ConnectedAP_ = s;
  }

  const tSubNetwork::type_optional& tSubNetwork::
  type () const
  {
    return this->type_;
  }

  tSubNetwork::type_optional& tSubNetwork::
  type ()
  {
    return this->type_;
  }

  void tSubNetwork::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void tSubNetwork::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void tSubNetwork::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }


  // tConnectedAP
  // 

  const tConnectedAP::Address_optional& tConnectedAP::
  Address () const
  {
    return this->Address_;
  }

  tConnectedAP::Address_optional& tConnectedAP::
  Address ()
  {
    return this->Address_;
  }

  void tConnectedAP::
  Address (const Address_type& x)
  {
    this->Address_.set (x);
  }

  void tConnectedAP::
  Address (const Address_optional& x)
  {
    this->Address_ = x;
  }

  void tConnectedAP::
  Address (::std::auto_ptr< Address_type > x)
  {
    this->Address_.set (x);
  }

  const tConnectedAP::GSE_sequence& tConnectedAP::
  GSE () const
  {
    return this->GSE_;
  }

  tConnectedAP::GSE_sequence& tConnectedAP::
  GSE ()
  {
    return this->GSE_;
  }

  void tConnectedAP::
  GSE (const GSE_sequence& s)
  {
    this->GSE_ = s;
  }

  const tConnectedAP::SMV_sequence& tConnectedAP::
  SMV () const
  {
    return this->SMV_;
  }

  tConnectedAP::SMV_sequence& tConnectedAP::
  SMV ()
  {
    return this->SMV_;
  }

  void tConnectedAP::
  SMV (const SMV_sequence& s)
  {
    this->SMV_ = s;
  }

  const tConnectedAP::PhysConn_sequence& tConnectedAP::
  PhysConn () const
  {
    return this->PhysConn_;
  }

  tConnectedAP::PhysConn_sequence& tConnectedAP::
  PhysConn ()
  {
    return this->PhysConn_;
  }

  void tConnectedAP::
  PhysConn (const PhysConn_sequence& s)
  {
    this->PhysConn_ = s;
  }

  const tConnectedAP::iedName_type& tConnectedAP::
  iedName () const
  {
    return this->iedName_.get ();
  }

  tConnectedAP::iedName_type& tConnectedAP::
  iedName ()
  {
    return this->iedName_.get ();
  }

  void tConnectedAP::
  iedName (const iedName_type& x)
  {
    this->iedName_.set (x);
  }

  void tConnectedAP::
  iedName (::std::auto_ptr< iedName_type > x)
  {
    this->iedName_.set (x);
  }

  const tConnectedAP::apName_type& tConnectedAP::
  apName () const
  {
    return this->apName_.get ();
  }

  tConnectedAP::apName_type& tConnectedAP::
  apName ()
  {
    return this->apName_.get ();
  }

  void tConnectedAP::
  apName (const apName_type& x)
  {
    this->apName_.set (x);
  }

  void tConnectedAP::
  apName (::std::auto_ptr< apName_type > x)
  {
    this->apName_.set (x);
  }


  // tAddress
  // 

  const tAddress::P_sequence& tAddress::
  P () const
  {
    return this->P_;
  }

  tAddress::P_sequence& tAddress::
  P ()
  {
    return this->P_;
  }

  void tAddress::
  P (const P_sequence& s)
  {
    this->P_ = s;
  }


  // tGSE
  // 

  const tGSE::MinTime_optional& tGSE::
  MinTime () const
  {
    return this->MinTime_;
  }

  tGSE::MinTime_optional& tGSE::
  MinTime ()
  {
    return this->MinTime_;
  }

  void tGSE::
  MinTime (const MinTime_type& x)
  {
    this->MinTime_.set (x);
  }

  void tGSE::
  MinTime (const MinTime_optional& x)
  {
    this->MinTime_ = x;
  }

  void tGSE::
  MinTime (::std::auto_ptr< MinTime_type > x)
  {
    this->MinTime_.set (x);
  }

  const tGSE::MaxTime_optional& tGSE::
  MaxTime () const
  {
    return this->MaxTime_;
  }

  tGSE::MaxTime_optional& tGSE::
  MaxTime ()
  {
    return this->MaxTime_;
  }

  void tGSE::
  MaxTime (const MaxTime_type& x)
  {
    this->MaxTime_.set (x);
  }

  void tGSE::
  MaxTime (const MaxTime_optional& x)
  {
    this->MaxTime_ = x;
  }

  void tGSE::
  MaxTime (::std::auto_ptr< MaxTime_type > x)
  {
    this->MaxTime_.set (x);
  }


  // tSMV
  // 


  // tPhysConn
  // 

  const tPhysConn::P_sequence& tPhysConn::
  P () const
  {
    return this->P_;
  }

  tPhysConn::P_sequence& tPhysConn::
  P ()
  {
    return this->P_;
  }

  void tPhysConn::
  P (const P_sequence& s)
  {
    this->P_ = s;
  }

  const tPhysConn::type_type& tPhysConn::
  type () const
  {
    return this->type_.get ();
  }

  tPhysConn::type_type& tPhysConn::
  type ()
  {
    return this->type_.get ();
  }

  void tPhysConn::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void tPhysConn::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }


  // tP
  // 

  const tP::type_type& tP::
  type () const
  {
    return this->type_.get ();
  }

  tP::type_type& tP::
  type ()
  {
    return this->type_.get ();
  }

  void tP::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void tP::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }


  // tP_IP
  // 


  // tP_IP_SUBNET
  // 


  // tP_IP_GATEWAY
  // 


  // tP_OSI_NSAP
  // 


  // tP_OSI_TSEL
  // 


  // tP_OSI_SSEL
  // 


  // tP_OSI_PSEL
  // 


  // tP_OSI_AP_Title
  // 


  // tP_OSI_AP_Invoke
  // 


  // tP_OSI_AE_Qualifier
  // 


  // tP_OSI_AE_Invoke
  // 


  // tP_MAC_Address
  // 


  // tP_APPID
  // 


  // tP_VLAN_PRIORITY
  // 


  // tP_VLAN_ID
  // 
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace SCL
{
  // tControlBlock
  //

  tControlBlock::
  tControlBlock (const ldInst_type& ldInst,
                 const cbName_type& cbName)
  : ::SCL::tUnNaming (),
    Address_ (this),
    ldInst_ (ldInst, this),
    cbName_ (cbName, this)
  {
  }

  tControlBlock::
  tControlBlock (const tControlBlock& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::SCL::tUnNaming (x, f, c),
    Address_ (x.Address_, f, this),
    ldInst_ (x.ldInst_, f, this),
    cbName_ (x.cbName_, f, this)
  {
  }

  tControlBlock::
  tControlBlock (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::SCL::tUnNaming (e, f | ::xml_schema::flags::base, c),
    Address_ (this),
    ldInst_ (this),
    cbName_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tControlBlock::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tUnNaming::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Address
      //
      if (n.name () == "Address" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< Address_type > r (
          Address_traits::create (i, f, this));

        if (!this->Address_)
        {
          this->Address_.set (r);
          continue;
        }
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ldInst" && n.namespace_ ().empty ())
      {
        this->ldInst_.set (ldInst_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "cbName" && n.namespace_ ().empty ())
      {
        this->cbName_.set (cbName_traits::create (i, f, this));
        continue;
      }
    }

    if (!ldInst_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ldInst",
        "");
    }

    if (!cbName_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "cbName",
        "");
    }
  }

  tControlBlock* tControlBlock::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tControlBlock (*this, f, c);
  }

  tControlBlock& tControlBlock::
  operator= (const tControlBlock& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tUnNaming& > (*this) = x;
      this->Address_ = x.Address_;
      this->ldInst_ = x.ldInst_;
      this->cbName_ = x.cbName_;
    }

    return *this;
  }

  tControlBlock::
  ~tControlBlock ()
  {
  }

  // tCommunication
  //

  tCommunication::
  tCommunication ()
  : ::SCL::tUnNaming (),
    SubNetwork_ (this)
  {
  }

  tCommunication::
  tCommunication (const tCommunication& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::SCL::tUnNaming (x, f, c),
    SubNetwork_ (x.SubNetwork_, f, this)
  {
  }

  tCommunication::
  tCommunication (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::SCL::tUnNaming (e, f | ::xml_schema::flags::base, c),
    SubNetwork_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tCommunication::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tUnNaming::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // SubNetwork
      //
      if (n.name () == "SubNetwork" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< SubNetwork_type > r (
          SubNetwork_traits::create (i, f, this));

        this->SubNetwork_.push_back (r);
        continue;
      }

      break;
    }
  }

  tCommunication* tCommunication::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tCommunication (*this, f, c);
  }

  tCommunication& tCommunication::
  operator= (const tCommunication& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tUnNaming& > (*this) = x;
      this->SubNetwork_ = x.SubNetwork_;
    }

    return *this;
  }

  tCommunication::
  ~tCommunication ()
  {
  }

  // tSubNetwork
  //

  tSubNetwork::
  tSubNetwork (const name_type& name)
  : ::SCL::tNaming (name),
    BitRate_ (this),
    ConnectedAP_ (this),
    type_ (this)
  {
  }

  tSubNetwork::
  tSubNetwork (const tSubNetwork& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::SCL::tNaming (x, f, c),
    BitRate_ (x.BitRate_, f, this),
    ConnectedAP_ (x.ConnectedAP_, f, this),
    type_ (x.type_, f, this)
  {
  }

  tSubNetwork::
  tSubNetwork (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::SCL::tNaming (e, f | ::xml_schema::flags::base, c),
    BitRate_ (this),
    ConnectedAP_ (this),
    type_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tSubNetwork::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tNaming::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // BitRate
      //
      if (n.name () == "BitRate" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< BitRate_type > r (
          BitRate_traits::create (i, f, this));

        if (!this->BitRate_)
        {
          this->BitRate_.set (r);
          continue;
        }
      }

      // ConnectedAP
      //
      if (n.name () == "ConnectedAP" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< ConnectedAP_type > r (
          ConnectedAP_traits::create (i, f, this));

        this->ConnectedAP_.push_back (r);
        continue;
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }
    }
  }

  tSubNetwork* tSubNetwork::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tSubNetwork (*this, f, c);
  }

  tSubNetwork& tSubNetwork::
  operator= (const tSubNetwork& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tNaming& > (*this) = x;
      this->BitRate_ = x.BitRate_;
      this->ConnectedAP_ = x.ConnectedAP_;
      this->type_ = x.type_;
    }

    return *this;
  }

  tSubNetwork::
  ~tSubNetwork ()
  {
  }

  // tConnectedAP
  //

  tConnectedAP::
  tConnectedAP (const iedName_type& iedName,
                const apName_type& apName)
  : ::SCL::tUnNaming (),
    Address_ (this),
    GSE_ (this),
    SMV_ (this),
    PhysConn_ (this),
    iedName_ (iedName, this),
    apName_ (apName, this)
  {
  }

  tConnectedAP::
  tConnectedAP (const tConnectedAP& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::SCL::tUnNaming (x, f, c),
    Address_ (x.Address_, f, this),
    GSE_ (x.GSE_, f, this),
    SMV_ (x.SMV_, f, this),
    PhysConn_ (x.PhysConn_, f, this),
    iedName_ (x.iedName_, f, this),
    apName_ (x.apName_, f, this)
  {
  }

  tConnectedAP::
  tConnectedAP (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::SCL::tUnNaming (e, f | ::xml_schema::flags::base, c),
    Address_ (this),
    GSE_ (this),
    SMV_ (this),
    PhysConn_ (this),
    iedName_ (this),
    apName_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tConnectedAP::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tUnNaming::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Address
      //
      if (n.name () == "Address" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< Address_type > r (
          Address_traits::create (i, f, this));

        if (!this->Address_)
        {
          this->Address_.set (r);
          continue;
        }
      }

      // GSE
      //
      if (n.name () == "GSE" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< GSE_type > r (
          GSE_traits::create (i, f, this));

        this->GSE_.push_back (r);
        continue;
      }

      // SMV
      //
      if (n.name () == "SMV" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< SMV_type > r (
          SMV_traits::create (i, f, this));

        this->SMV_.push_back (r);
        continue;
      }

      // PhysConn
      //
      if (n.name () == "PhysConn" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< PhysConn_type > r (
          PhysConn_traits::create (i, f, this));

        this->PhysConn_.push_back (r);
        continue;
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "iedName" && n.namespace_ ().empty ())
      {
        this->iedName_.set (iedName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "apName" && n.namespace_ ().empty ())
      {
        this->apName_.set (apName_traits::create (i, f, this));
        continue;
      }
    }

    if (!iedName_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "iedName",
        "");
    }

    if (!apName_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "apName",
        "");
    }
  }

  tConnectedAP* tConnectedAP::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tConnectedAP (*this, f, c);
  }

  tConnectedAP& tConnectedAP::
  operator= (const tConnectedAP& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tUnNaming& > (*this) = x;
      this->Address_ = x.Address_;
      this->GSE_ = x.GSE_;
      this->SMV_ = x.SMV_;
      this->PhysConn_ = x.PhysConn_;
      this->iedName_ = x.iedName_;
      this->apName_ = x.apName_;
    }

    return *this;
  }

  tConnectedAP::
  ~tConnectedAP ()
  {
  }

  // tAddress
  //

  tAddress::
  tAddress ()
  : ::xml_schema::type (),
    P_ (this)
  {
  }

  tAddress::
  tAddress (const tAddress& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    P_ (x.P_, f, this)
  {
  }

  tAddress::
  tAddress (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    P_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void tAddress::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // P
      //
      if (n.name () == "P" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< P_type > r (
          P_traits::create (i, f, this));

        this->P_.push_back (r);
        continue;
      }

      break;
    }
  }

  tAddress* tAddress::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tAddress (*this, f, c);
  }

  tAddress& tAddress::
  operator= (const tAddress& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->P_ = x.P_;
    }

    return *this;
  }

  tAddress::
  ~tAddress ()
  {
  }

  // tGSE
  //

  tGSE::
  tGSE (const ldInst_type& ldInst,
        const cbName_type& cbName)
  : ::SCL::tControlBlock (ldInst,
                          cbName),
    MinTime_ (this),
    MaxTime_ (this)
  {
  }

  tGSE::
  tGSE (const tGSE& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::SCL::tControlBlock (x, f, c),
    MinTime_ (x.MinTime_, f, this),
    MaxTime_ (x.MaxTime_, f, this)
  {
  }

  tGSE::
  tGSE (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::SCL::tControlBlock (e, f | ::xml_schema::flags::base, c),
    MinTime_ (this),
    MaxTime_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tGSE::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tControlBlock::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // MinTime
      //
      if (n.name () == "MinTime" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< MinTime_type > r (
          MinTime_traits::create (i, f, this));

        if (!this->MinTime_)
        {
          this->MinTime_.set (r);
          continue;
        }
      }

      // MaxTime
      //
      if (n.name () == "MaxTime" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< MaxTime_type > r (
          MaxTime_traits::create (i, f, this));

        if (!this->MaxTime_)
        {
          this->MaxTime_.set (r);
          continue;
        }
      }

      break;
    }
  }

  tGSE* tGSE::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tGSE (*this, f, c);
  }

  tGSE& tGSE::
  operator= (const tGSE& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tControlBlock& > (*this) = x;
      this->MinTime_ = x.MinTime_;
      this->MaxTime_ = x.MaxTime_;
    }

    return *this;
  }

  tGSE::
  ~tGSE ()
  {
  }

  // tSMV
  //

  tSMV::
  tSMV (const ldInst_type& ldInst,
        const cbName_type& cbName)
  : ::SCL::tControlBlock (ldInst,
                          cbName)
  {
  }

  tSMV::
  tSMV (const tSMV& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::SCL::tControlBlock (x, f, c)
  {
  }

  tSMV::
  tSMV (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::SCL::tControlBlock (e, f, c)
  {
  }

  tSMV* tSMV::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tSMV (*this, f, c);
  }

  tSMV::
  ~tSMV ()
  {
  }

  // tPhysConn
  //

  tPhysConn::
  tPhysConn (const type_type& type)
  : ::xml_schema::type (),
    P_ (this),
    type_ (type, this)
  {
  }

  tPhysConn::
  tPhysConn (const tPhysConn& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    P_ (x.P_, f, this),
    type_ (x.type_, f, this)
  {
  }

  tPhysConn::
  tPhysConn (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    P_ (this),
    type_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tPhysConn::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // P
      //
      if (n.name () == "P" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< P_type > r (
          P_traits::create (i, f, this));

        this->P_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  tPhysConn* tPhysConn::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tPhysConn (*this, f, c);
  }

  tPhysConn& tPhysConn::
  operator= (const tPhysConn& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->P_ = x.P_;
      this->type_ = x.type_;
    }

    return *this;
  }

  tPhysConn::
  ~tPhysConn ()
  {
  }

  // tP
  //

  tP::
  tP (const type_type& type)
  : ::SCL::tPAddr (),
    type_ (type, this)
  {
  }

  tP::
  tP (const char* _xsd_normalized_string_base,
      const type_type& type)
  : ::SCL::tPAddr (_xsd_normalized_string_base),
    type_ (type, this)
  {
  }

  tP::
  tP (const ::std::string& _xsd_normalized_string_base,
      const type_type& type)
  : ::SCL::tPAddr (_xsd_normalized_string_base),
    type_ (type, this)
  {
  }

  tP::
  tP (const ::xml_schema::normalized_string& _xsd_normalized_string_base,
      const type_type& type)
  : ::SCL::tPAddr (_xsd_normalized_string_base),
    type_ (type, this)
  {
  }

  tP::
  tP (const tP& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
  : ::SCL::tPAddr (x, f, c),
    type_ (x.type_, f, this)
  {
  }

  tP::
  tP (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
  : ::SCL::tPAddr (e, f | ::xml_schema::flags::base, c),
    type_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void tP::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  tP* tP::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tP (*this, f, c);
  }

  tP& tP::
  operator= (const tP& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tPAddr& > (*this) = x;
      this->type_ = x.type_;
    }

    return *this;
  }

  tP::
  ~tP ()
  {
  }

  // tP_IP
  //

  tP_IP::
  tP_IP (const type_type& type)
  : ::SCL::tP (type)
  {
  }

  tP_IP::
  tP_IP (const char* _xsd_normalized_string_base,
         const type_type& type)
  : ::SCL::tP (_xsd_normalized_string_base,
               type)
  {
  }

  tP_IP::
  tP_IP (const ::std::string& _xsd_normalized_string_base,
         const type_type& type)
  : ::SCL::tP (_xsd_normalized_string_base,
               type)
  {
  }

  tP_IP::
  tP_IP (const ::xml_schema::normalized_string& _xsd_normalized_string_base,
         const type_type& type)
  : ::SCL::tP (_xsd_normalized_string_base,
               type)
  {
  }

  tP_IP::
  tP_IP (const tP_IP& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::SCL::tP (x, f, c)
  {
  }

  tP_IP::
  tP_IP (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::SCL::tP (e, f, c)
  {
  }

  tP_IP* tP_IP::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tP_IP (*this, f, c);
  }

  tP_IP::
  ~tP_IP ()
  {
  }

  // tP_IP_SUBNET
  //

  tP_IP_SUBNET::
  tP_IP_SUBNET (const type_type& type)
  : ::SCL::tP (type)
  {
  }

  tP_IP_SUBNET::
  tP_IP_SUBNET (const char* _xsd_normalized_string_base,
                const type_type& type)
  : ::SCL::tP (_xsd_normalized_string_base,
               type)
  {
  }

  tP_IP_SUBNET::
  tP_IP_SUBNET (const ::std::string& _xsd_normalized_string_base,
                const type_type& type)
  : ::SCL::tP (_xsd_normalized_string_base,
               type)
  {
  }

  tP_IP_SUBNET::
  tP_IP_SUBNET (const ::xml_schema::normalized_string& _xsd_normalized_string_base,
                const type_type& type)
  : ::SCL::tP (_xsd_normalized_string_base,
               type)
  {
  }

  tP_IP_SUBNET::
  tP_IP_SUBNET (const tP_IP_SUBNET& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::SCL::tP (x, f, c)
  {
  }

  tP_IP_SUBNET::
  tP_IP_SUBNET (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::SCL::tP (e, f, c)
  {
  }

  tP_IP_SUBNET* tP_IP_SUBNET::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tP_IP_SUBNET (*this, f, c);
  }

  tP_IP_SUBNET::
  ~tP_IP_SUBNET ()
  {
  }

  // tP_IP_GATEWAY
  //

  tP_IP_GATEWAY::
  tP_IP_GATEWAY (const type_type& type)
  : ::SCL::tP (type)
  {
  }

  tP_IP_GATEWAY::
  tP_IP_GATEWAY (const char* _xsd_normalized_string_base,
                 const type_type& type)
  : ::SCL::tP (_xsd_normalized_string_base,
               type)
  {
  }

  tP_IP_GATEWAY::
  tP_IP_GATEWAY (const ::std::string& _xsd_normalized_string_base,
                 const type_type& type)
  : ::SCL::tP (_xsd_normalized_string_base,
               type)
  {
  }

  tP_IP_GATEWAY::
  tP_IP_GATEWAY (const ::xml_schema::normalized_string& _xsd_normalized_string_base,
                 const type_type& type)
  : ::SCL::tP (_xsd_normalized_string_base,
               type)
  {
  }

  tP_IP_GATEWAY::
  tP_IP_GATEWAY (const tP_IP_GATEWAY& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::SCL::tP (x, f, c)
  {
  }

  tP_IP_GATEWAY::
  tP_IP_GATEWAY (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::SCL::tP (e, f, c)
  {
  }

  tP_IP_GATEWAY* tP_IP_GATEWAY::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tP_IP_GATEWAY (*this, f, c);
  }

  tP_IP_GATEWAY::
  ~tP_IP_GATEWAY ()
  {
  }

  // tP_OSI_NSAP
  //

  tP_OSI_NSAP::
  tP_OSI_NSAP (const type_type& type)
  : ::SCL::tP (type)
  {
  }

  tP_OSI_NSAP::
  tP_OSI_NSAP (const char* _xsd_normalized_string_base,
               const type_type& type)
  : ::SCL::tP (_xsd_normalized_string_base,
               type)
  {
  }

  tP_OSI_NSAP::
  tP_OSI_NSAP (const ::std::string& _xsd_normalized_string_base,
               const type_type& type)
  : ::SCL::tP (_xsd_normalized_string_base,
               type)
  {
  }

  tP_OSI_NSAP::
  tP_OSI_NSAP (const ::xml_schema::normalized_string& _xsd_normalized_string_base,
               const type_type& type)
  : ::SCL::tP (_xsd_normalized_string_base,
               type)
  {
  }

  tP_OSI_NSAP::
  tP_OSI_NSAP (const tP_OSI_NSAP& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::SCL::tP (x, f, c)
  {
  }

  tP_OSI_NSAP::
  tP_OSI_NSAP (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::SCL::tP (e, f, c)
  {
  }

  tP_OSI_NSAP* tP_OSI_NSAP::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tP_OSI_NSAP (*this, f, c);
  }

  tP_OSI_NSAP::
  ~tP_OSI_NSAP ()
  {
  }

  // tP_OSI_TSEL
  //

  tP_OSI_TSEL::
  tP_OSI_TSEL (const type_type& type)
  : ::SCL::tP (type)
  {
  }

  tP_OSI_TSEL::
  tP_OSI_TSEL (const char* _xsd_normalized_string_base,
               const type_type& type)
  : ::SCL::tP (_xsd_normalized_string_base,
               type)
  {
  }

  tP_OSI_TSEL::
  tP_OSI_TSEL (const ::std::string& _xsd_normalized_string_base,
               const type_type& type)
  : ::SCL::tP (_xsd_normalized_string_base,
               type)
  {
  }

  tP_OSI_TSEL::
  tP_OSI_TSEL (const ::xml_schema::normalized_string& _xsd_normalized_string_base,
               const type_type& type)
  : ::SCL::tP (_xsd_normalized_string_base,
               type)
  {
  }

  tP_OSI_TSEL::
  tP_OSI_TSEL (const tP_OSI_TSEL& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::SCL::tP (x, f, c)
  {
  }

  tP_OSI_TSEL::
  tP_OSI_TSEL (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::SCL::tP (e, f, c)
  {
  }

  tP_OSI_TSEL* tP_OSI_TSEL::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tP_OSI_TSEL (*this, f, c);
  }

  tP_OSI_TSEL::
  ~tP_OSI_TSEL ()
  {
  }

  // tP_OSI_SSEL
  //

  tP_OSI_SSEL::
  tP_OSI_SSEL (const type_type& type)
  : ::SCL::tP (type)
  {
  }

  tP_OSI_SSEL::
  tP_OSI_SSEL (const char* _xsd_normalized_string_base,
               const type_type& type)
  : ::SCL::tP (_xsd_normalized_string_base,
               type)
  {
  }

  tP_OSI_SSEL::
  tP_OSI_SSEL (const ::std::string& _xsd_normalized_string_base,
               const type_type& type)
  : ::SCL::tP (_xsd_normalized_string_base,
               type)
  {
  }

  tP_OSI_SSEL::
  tP_OSI_SSEL (const ::xml_schema::normalized_string& _xsd_normalized_string_base,
               const type_type& type)
  : ::SCL::tP (_xsd_normalized_string_base,
               type)
  {
  }

  tP_OSI_SSEL::
  tP_OSI_SSEL (const tP_OSI_SSEL& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::SCL::tP (x, f, c)
  {
  }

  tP_OSI_SSEL::
  tP_OSI_SSEL (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::SCL::tP (e, f, c)
  {
  }

  tP_OSI_SSEL* tP_OSI_SSEL::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tP_OSI_SSEL (*this, f, c);
  }

  tP_OSI_SSEL::
  ~tP_OSI_SSEL ()
  {
  }

  // tP_OSI_PSEL
  //

  tP_OSI_PSEL::
  tP_OSI_PSEL (const type_type& type)
  : ::SCL::tP (type)
  {
  }

  tP_OSI_PSEL::
  tP_OSI_PSEL (const char* _xsd_normalized_string_base,
               const type_type& type)
  : ::SCL::tP (_xsd_normalized_string_base,
               type)
  {
  }

  tP_OSI_PSEL::
  tP_OSI_PSEL (const ::std::string& _xsd_normalized_string_base,
               const type_type& type)
  : ::SCL::tP (_xsd_normalized_string_base,
               type)
  {
  }

  tP_OSI_PSEL::
  tP_OSI_PSEL (const ::xml_schema::normalized_string& _xsd_normalized_string_base,
               const type_type& type)
  : ::SCL::tP (_xsd_normalized_string_base,
               type)
  {
  }

  tP_OSI_PSEL::
  tP_OSI_PSEL (const tP_OSI_PSEL& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::SCL::tP (x, f, c)
  {
  }

  tP_OSI_PSEL::
  tP_OSI_PSEL (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::SCL::tP (e, f, c)
  {
  }

  tP_OSI_PSEL* tP_OSI_PSEL::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tP_OSI_PSEL (*this, f, c);
  }

  tP_OSI_PSEL::
  ~tP_OSI_PSEL ()
  {
  }

  // tP_OSI_AP_Title
  //

  tP_OSI_AP_Title::
  tP_OSI_AP_Title (const type_type& type)
  : ::SCL::tP (type)
  {
  }

  tP_OSI_AP_Title::
  tP_OSI_AP_Title (const char* _xsd_normalized_string_base,
                   const type_type& type)
  : ::SCL::tP (_xsd_normalized_string_base,
               type)
  {
  }

  tP_OSI_AP_Title::
  tP_OSI_AP_Title (const ::std::string& _xsd_normalized_string_base,
                   const type_type& type)
  : ::SCL::tP (_xsd_normalized_string_base,
               type)
  {
  }

  tP_OSI_AP_Title::
  tP_OSI_AP_Title (const ::xml_schema::normalized_string& _xsd_normalized_string_base,
                   const type_type& type)
  : ::SCL::tP (_xsd_normalized_string_base,
               type)
  {
  }

  tP_OSI_AP_Title::
  tP_OSI_AP_Title (const tP_OSI_AP_Title& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::SCL::tP (x, f, c)
  {
  }

  tP_OSI_AP_Title::
  tP_OSI_AP_Title (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::SCL::tP (e, f, c)
  {
  }

  tP_OSI_AP_Title* tP_OSI_AP_Title::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tP_OSI_AP_Title (*this, f, c);
  }

  tP_OSI_AP_Title::
  ~tP_OSI_AP_Title ()
  {
  }

  // tP_OSI_AP_Invoke
  //

  tP_OSI_AP_Invoke::
  tP_OSI_AP_Invoke (const type_type& type)
  : ::SCL::tP (type)
  {
  }

  tP_OSI_AP_Invoke::
  tP_OSI_AP_Invoke (const char* _xsd_normalized_string_base,
                    const type_type& type)
  : ::SCL::tP (_xsd_normalized_string_base,
               type)
  {
  }

  tP_OSI_AP_Invoke::
  tP_OSI_AP_Invoke (const ::std::string& _xsd_normalized_string_base,
                    const type_type& type)
  : ::SCL::tP (_xsd_normalized_string_base,
               type)
  {
  }

  tP_OSI_AP_Invoke::
  tP_OSI_AP_Invoke (const ::xml_schema::normalized_string& _xsd_normalized_string_base,
                    const type_type& type)
  : ::SCL::tP (_xsd_normalized_string_base,
               type)
  {
  }

  tP_OSI_AP_Invoke::
  tP_OSI_AP_Invoke (const tP_OSI_AP_Invoke& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::SCL::tP (x, f, c)
  {
  }

  tP_OSI_AP_Invoke::
  tP_OSI_AP_Invoke (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::SCL::tP (e, f, c)
  {
  }

  tP_OSI_AP_Invoke* tP_OSI_AP_Invoke::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tP_OSI_AP_Invoke (*this, f, c);
  }

  tP_OSI_AP_Invoke::
  ~tP_OSI_AP_Invoke ()
  {
  }

  // tP_OSI_AE_Qualifier
  //

  tP_OSI_AE_Qualifier::
  tP_OSI_AE_Qualifier (const type_type& type)
  : ::SCL::tP (type)
  {
  }

  tP_OSI_AE_Qualifier::
  tP_OSI_AE_Qualifier (const char* _xsd_normalized_string_base,
                       const type_type& type)
  : ::SCL::tP (_xsd_normalized_string_base,
               type)
  {
  }

  tP_OSI_AE_Qualifier::
  tP_OSI_AE_Qualifier (const ::std::string& _xsd_normalized_string_base,
                       const type_type& type)
  : ::SCL::tP (_xsd_normalized_string_base,
               type)
  {
  }

  tP_OSI_AE_Qualifier::
  tP_OSI_AE_Qualifier (const ::xml_schema::normalized_string& _xsd_normalized_string_base,
                       const type_type& type)
  : ::SCL::tP (_xsd_normalized_string_base,
               type)
  {
  }

  tP_OSI_AE_Qualifier::
  tP_OSI_AE_Qualifier (const tP_OSI_AE_Qualifier& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::SCL::tP (x, f, c)
  {
  }

  tP_OSI_AE_Qualifier::
  tP_OSI_AE_Qualifier (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::SCL::tP (e, f, c)
  {
  }

  tP_OSI_AE_Qualifier* tP_OSI_AE_Qualifier::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tP_OSI_AE_Qualifier (*this, f, c);
  }

  tP_OSI_AE_Qualifier::
  ~tP_OSI_AE_Qualifier ()
  {
  }

  // tP_OSI_AE_Invoke
  //

  tP_OSI_AE_Invoke::
  tP_OSI_AE_Invoke (const type_type& type)
  : ::SCL::tP (type)
  {
  }

  tP_OSI_AE_Invoke::
  tP_OSI_AE_Invoke (const char* _xsd_normalized_string_base,
                    const type_type& type)
  : ::SCL::tP (_xsd_normalized_string_base,
               type)
  {
  }

  tP_OSI_AE_Invoke::
  tP_OSI_AE_Invoke (const ::std::string& _xsd_normalized_string_base,
                    const type_type& type)
  : ::SCL::tP (_xsd_normalized_string_base,
               type)
  {
  }

  tP_OSI_AE_Invoke::
  tP_OSI_AE_Invoke (const ::xml_schema::normalized_string& _xsd_normalized_string_base,
                    const type_type& type)
  : ::SCL::tP (_xsd_normalized_string_base,
               type)
  {
  }

  tP_OSI_AE_Invoke::
  tP_OSI_AE_Invoke (const tP_OSI_AE_Invoke& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::SCL::tP (x, f, c)
  {
  }

  tP_OSI_AE_Invoke::
  tP_OSI_AE_Invoke (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::SCL::tP (e, f, c)
  {
  }

  tP_OSI_AE_Invoke* tP_OSI_AE_Invoke::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tP_OSI_AE_Invoke (*this, f, c);
  }

  tP_OSI_AE_Invoke::
  ~tP_OSI_AE_Invoke ()
  {
  }

  // tP_MAC_Address
  //

  tP_MAC_Address::
  tP_MAC_Address (const type_type& type)
  : ::SCL::tP (type)
  {
  }

  tP_MAC_Address::
  tP_MAC_Address (const char* _xsd_normalized_string_base,
                  const type_type& type)
  : ::SCL::tP (_xsd_normalized_string_base,
               type)
  {
  }

  tP_MAC_Address::
  tP_MAC_Address (const ::std::string& _xsd_normalized_string_base,
                  const type_type& type)
  : ::SCL::tP (_xsd_normalized_string_base,
               type)
  {
  }

  tP_MAC_Address::
  tP_MAC_Address (const ::xml_schema::normalized_string& _xsd_normalized_string_base,
                  const type_type& type)
  : ::SCL::tP (_xsd_normalized_string_base,
               type)
  {
  }

  tP_MAC_Address::
  tP_MAC_Address (const tP_MAC_Address& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::SCL::tP (x, f, c)
  {
  }

  tP_MAC_Address::
  tP_MAC_Address (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::SCL::tP (e, f, c)
  {
  }

  tP_MAC_Address* tP_MAC_Address::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tP_MAC_Address (*this, f, c);
  }

  tP_MAC_Address::
  ~tP_MAC_Address ()
  {
  }

  // tP_APPID
  //

  tP_APPID::
  tP_APPID (const type_type& type)
  : ::SCL::tP (type)
  {
  }

  tP_APPID::
  tP_APPID (const char* _xsd_normalized_string_base,
            const type_type& type)
  : ::SCL::tP (_xsd_normalized_string_base,
               type)
  {
  }

  tP_APPID::
  tP_APPID (const ::std::string& _xsd_normalized_string_base,
            const type_type& type)
  : ::SCL::tP (_xsd_normalized_string_base,
               type)
  {
  }

  tP_APPID::
  tP_APPID (const ::xml_schema::normalized_string& _xsd_normalized_string_base,
            const type_type& type)
  : ::SCL::tP (_xsd_normalized_string_base,
               type)
  {
  }

  tP_APPID::
  tP_APPID (const tP_APPID& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::SCL::tP (x, f, c)
  {
  }

  tP_APPID::
  tP_APPID (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::SCL::tP (e, f, c)
  {
  }

  tP_APPID* tP_APPID::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tP_APPID (*this, f, c);
  }

  tP_APPID::
  ~tP_APPID ()
  {
  }

  // tP_VLAN_PRIORITY
  //

  tP_VLAN_PRIORITY::
  tP_VLAN_PRIORITY (const type_type& type)
  : ::SCL::tP (type)
  {
  }

  tP_VLAN_PRIORITY::
  tP_VLAN_PRIORITY (const char* _xsd_normalized_string_base,
                    const type_type& type)
  : ::SCL::tP (_xsd_normalized_string_base,
               type)
  {
  }

  tP_VLAN_PRIORITY::
  tP_VLAN_PRIORITY (const ::std::string& _xsd_normalized_string_base,
                    const type_type& type)
  : ::SCL::tP (_xsd_normalized_string_base,
               type)
  {
  }

  tP_VLAN_PRIORITY::
  tP_VLAN_PRIORITY (const ::xml_schema::normalized_string& _xsd_normalized_string_base,
                    const type_type& type)
  : ::SCL::tP (_xsd_normalized_string_base,
               type)
  {
  }

  tP_VLAN_PRIORITY::
  tP_VLAN_PRIORITY (const tP_VLAN_PRIORITY& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::SCL::tP (x, f, c)
  {
  }

  tP_VLAN_PRIORITY::
  tP_VLAN_PRIORITY (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::SCL::tP (e, f, c)
  {
  }

  tP_VLAN_PRIORITY* tP_VLAN_PRIORITY::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tP_VLAN_PRIORITY (*this, f, c);
  }

  tP_VLAN_PRIORITY::
  ~tP_VLAN_PRIORITY ()
  {
  }

  // tP_VLAN_ID
  //

  tP_VLAN_ID::
  tP_VLAN_ID (const type_type& type)
  : ::SCL::tP (type)
  {
  }

  tP_VLAN_ID::
  tP_VLAN_ID (const char* _xsd_normalized_string_base,
              const type_type& type)
  : ::SCL::tP (_xsd_normalized_string_base,
               type)
  {
  }

  tP_VLAN_ID::
  tP_VLAN_ID (const ::std::string& _xsd_normalized_string_base,
              const type_type& type)
  : ::SCL::tP (_xsd_normalized_string_base,
               type)
  {
  }

  tP_VLAN_ID::
  tP_VLAN_ID (const ::xml_schema::normalized_string& _xsd_normalized_string_base,
              const type_type& type)
  : ::SCL::tP (_xsd_normalized_string_base,
               type)
  {
  }

  tP_VLAN_ID::
  tP_VLAN_ID (const tP_VLAN_ID& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::SCL::tP (x, f, c)
  {
  }

  tP_VLAN_ID::
  tP_VLAN_ID (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::SCL::tP (e, f, c)
  {
  }

  tP_VLAN_ID* tP_VLAN_ID::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tP_VLAN_ID (*this, f, c);
  }

  tP_VLAN_ID::
  ~tP_VLAN_ID ()
  {
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace SCL
{
  ::std::auto_ptr< ::SCL::tCommunication >
  Communication (const ::std::string& u,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::SCL::tCommunication > (
      ::SCL::Communication (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::SCL::tCommunication >
  Communication (const ::std::string& u,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::SCL::tCommunication > (
      ::SCL::Communication (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::SCL::tCommunication >
  Communication (const ::std::string& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::SCL::tCommunication > (
      ::SCL::Communication (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::SCL::tCommunication >
  Communication (::std::istream& is,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::SCL::Communication (isrc, f, p);
  }

  ::std::auto_ptr< ::SCL::tCommunication >
  Communication (::std::istream& is,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::SCL::Communication (isrc, h, f, p);
  }

  ::std::auto_ptr< ::SCL::tCommunication >
  Communication (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::SCL::Communication (isrc, h, f, p);
  }

  ::std::auto_ptr< ::SCL::tCommunication >
  Communication (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::SCL::Communication (isrc, f, p);
  }

  ::std::auto_ptr< ::SCL::tCommunication >
  Communication (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::SCL::Communication (isrc, h, f, p);
  }

  ::std::auto_ptr< ::SCL::tCommunication >
  Communication (::std::istream& is,
                 const ::std::string& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::SCL::Communication (isrc, h, f, p);
  }

  ::std::auto_ptr< ::SCL::tCommunication >
  Communication (::xercesc::InputSource& i,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::SCL::tCommunication > (
      ::SCL::Communication (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::SCL::tCommunication >
  Communication (::xercesc::InputSource& i,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::SCL::tCommunication > (
      ::SCL::Communication (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::SCL::tCommunication >
  Communication (::xercesc::InputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::SCL::tCommunication > (
      ::SCL::Communication (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::SCL::tCommunication >
  Communication (const ::xercesc::DOMDocument& doc,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::SCL::tCommunication > (
        ::SCL::Communication (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Communication" &&
        n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
    {
      ::std::auto_ptr< ::SCL::tCommunication > r (
        ::xsd::cxx::tree::traits< ::SCL::tCommunication, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Communication",
      "http://www.iec.ch/61850/2006/SCL");
  }

  ::std::auto_ptr< ::SCL::tCommunication >
  Communication (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Communication" &&
        n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
    {
      ::std::auto_ptr< ::SCL::tCommunication > r (
        ::xsd::cxx::tree::traits< ::SCL::tCommunication, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Communication",
      "http://www.iec.ch/61850/2006/SCL");
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

