// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "SCL_DataTypeTemplates.hxx"

namespace SCL
{
  // tAbstractDataAttribute
  // 

  const tAbstractDataAttribute::Val_sequence& tAbstractDataAttribute::
  Val () const
  {
    return this->Val_;
  }

  tAbstractDataAttribute::Val_sequence& tAbstractDataAttribute::
  Val ()
  {
    return this->Val_;
  }

  void tAbstractDataAttribute::
  Val (const Val_sequence& s)
  {
    this->Val_ = s;
  }

  const tAbstractDataAttribute::name_type& tAbstractDataAttribute::
  name () const
  {
    return this->name_.get ();
  }

  tAbstractDataAttribute::name_type& tAbstractDataAttribute::
  name ()
  {
    return this->name_.get ();
  }

  void tAbstractDataAttribute::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void tAbstractDataAttribute::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const tAbstractDataAttribute::sAddr_optional& tAbstractDataAttribute::
  sAddr () const
  {
    return this->sAddr_;
  }

  tAbstractDataAttribute::sAddr_optional& tAbstractDataAttribute::
  sAddr ()
  {
    return this->sAddr_;
  }

  void tAbstractDataAttribute::
  sAddr (const sAddr_type& x)
  {
    this->sAddr_.set (x);
  }

  void tAbstractDataAttribute::
  sAddr (const sAddr_optional& x)
  {
    this->sAddr_ = x;
  }

  void tAbstractDataAttribute::
  sAddr (::std::auto_ptr< sAddr_type > x)
  {
    this->sAddr_.set (x);
  }

  const tAbstractDataAttribute::bType_type& tAbstractDataAttribute::
  bType () const
  {
    return this->bType_.get ();
  }

  tAbstractDataAttribute::bType_type& tAbstractDataAttribute::
  bType ()
  {
    return this->bType_.get ();
  }

  void tAbstractDataAttribute::
  bType (const bType_type& x)
  {
    this->bType_.set (x);
  }

  void tAbstractDataAttribute::
  bType (::std::auto_ptr< bType_type > x)
  {
    this->bType_.set (x);
  }

  const tAbstractDataAttribute::valKind_type& tAbstractDataAttribute::
  valKind () const
  {
    return this->valKind_.get ();
  }

  tAbstractDataAttribute::valKind_type& tAbstractDataAttribute::
  valKind ()
  {
    return this->valKind_.get ();
  }

  void tAbstractDataAttribute::
  valKind (const valKind_type& x)
  {
    this->valKind_.set (x);
  }

  void tAbstractDataAttribute::
  valKind (::std::auto_ptr< valKind_type > x)
  {
    this->valKind_.set (x);
  }

  const tAbstractDataAttribute::valKind_type& tAbstractDataAttribute::
  valKind_default_value ()
  {
    return valKind_default_value_;
  }

  const tAbstractDataAttribute::type_optional& tAbstractDataAttribute::
  type () const
  {
    return this->type_;
  }

  tAbstractDataAttribute::type_optional& tAbstractDataAttribute::
  type ()
  {
    return this->type_;
  }

  void tAbstractDataAttribute::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void tAbstractDataAttribute::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void tAbstractDataAttribute::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const tAbstractDataAttribute::count_type& tAbstractDataAttribute::
  count () const
  {
    return this->count_.get ();
  }

  tAbstractDataAttribute::count_type& tAbstractDataAttribute::
  count ()
  {
    return this->count_.get ();
  }

  void tAbstractDataAttribute::
  count (const count_type& x)
  {
    this->count_.set (x);
  }

  tAbstractDataAttribute::count_type tAbstractDataAttribute::
  count_default_value ()
  {
    return count_type (0U);
  }


  // tLNodeType
  // 

  const tLNodeType::DO_sequence& tLNodeType::
  DO () const
  {
    return this->DO_;
  }

  tLNodeType::DO_sequence& tLNodeType::
  DO ()
  {
    return this->DO_;
  }

  void tLNodeType::
  DO (const DO_sequence& s)
  {
    this->DO_ = s;
  }

  const tLNodeType::iedType_type& tLNodeType::
  iedType () const
  {
    return this->iedType_.get ();
  }

  tLNodeType::iedType_type& tLNodeType::
  iedType ()
  {
    return this->iedType_.get ();
  }

  void tLNodeType::
  iedType (const iedType_type& x)
  {
    this->iedType_.set (x);
  }

  void tLNodeType::
  iedType (::std::auto_ptr< iedType_type > x)
  {
    this->iedType_.set (x);
  }

  const tLNodeType::iedType_type& tLNodeType::
  iedType_default_value ()
  {
    return iedType_default_value_;
  }

  const tLNodeType::lnClass_type& tLNodeType::
  lnClass () const
  {
    return this->lnClass_.get ();
  }

  tLNodeType::lnClass_type& tLNodeType::
  lnClass ()
  {
    return this->lnClass_.get ();
  }

  void tLNodeType::
  lnClass (const lnClass_type& x)
  {
    this->lnClass_.set (x);
  }

  void tLNodeType::
  lnClass (::std::auto_ptr< lnClass_type > x)
  {
    this->lnClass_.set (x);
  }


  // tDO
  // 

  const tDO::name_type& tDO::
  name () const
  {
    return this->name_.get ();
  }

  tDO::name_type& tDO::
  name ()
  {
    return this->name_.get ();
  }

  void tDO::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void tDO::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const tDO::type_type& tDO::
  type () const
  {
    return this->type_.get ();
  }

  tDO::type_type& tDO::
  type ()
  {
    return this->type_.get ();
  }

  void tDO::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void tDO::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const tDO::accessControl_optional& tDO::
  accessControl () const
  {
    return this->accessControl_;
  }

  tDO::accessControl_optional& tDO::
  accessControl ()
  {
    return this->accessControl_;
  }

  void tDO::
  accessControl (const accessControl_type& x)
  {
    this->accessControl_.set (x);
  }

  void tDO::
  accessControl (const accessControl_optional& x)
  {
    this->accessControl_ = x;
  }

  void tDO::
  accessControl (::std::auto_ptr< accessControl_type > x)
  {
    this->accessControl_.set (x);
  }

  const tDO::transient_type& tDO::
  transient () const
  {
    return this->transient_.get ();
  }

  tDO::transient_type& tDO::
  transient ()
  {
    return this->transient_.get ();
  }

  void tDO::
  transient (const transient_type& x)
  {
    this->transient_.set (x);
  }

  tDO::transient_type tDO::
  transient_default_value ()
  {
    return transient_type (false);
  }


  // tDOType
  // 

  const tDOType::SDO_sequence& tDOType::
  SDO () const
  {
    return this->SDO_;
  }

  tDOType::SDO_sequence& tDOType::
  SDO ()
  {
    return this->SDO_;
  }

  void tDOType::
  SDO (const SDO_sequence& s)
  {
    this->SDO_ = s;
  }

  const tDOType::DA_sequence& tDOType::
  DA () const
  {
    return this->DA_;
  }

  tDOType::DA_sequence& tDOType::
  DA ()
  {
    return this->DA_;
  }

  void tDOType::
  DA (const DA_sequence& s)
  {
    this->DA_ = s;
  }

  const tDOType::iedType_type& tDOType::
  iedType () const
  {
    return this->iedType_.get ();
  }

  tDOType::iedType_type& tDOType::
  iedType ()
  {
    return this->iedType_.get ();
  }

  void tDOType::
  iedType (const iedType_type& x)
  {
    this->iedType_.set (x);
  }

  void tDOType::
  iedType (::std::auto_ptr< iedType_type > x)
  {
    this->iedType_.set (x);
  }

  const tDOType::iedType_type& tDOType::
  iedType_default_value ()
  {
    return iedType_default_value_;
  }

  const tDOType::cdc_type& tDOType::
  cdc () const
  {
    return this->cdc_.get ();
  }

  tDOType::cdc_type& tDOType::
  cdc ()
  {
    return this->cdc_.get ();
  }

  void tDOType::
  cdc (const cdc_type& x)
  {
    this->cdc_.set (x);
  }

  void tDOType::
  cdc (::std::auto_ptr< cdc_type > x)
  {
    this->cdc_.set (x);
  }


  // tSDO
  // 

  const tSDO::type_type& tSDO::
  type () const
  {
    return this->type_.get ();
  }

  tSDO::type_type& tSDO::
  type ()
  {
    return this->type_.get ();
  }

  void tSDO::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void tSDO::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }


  // tDA
  // 

  const tDA::dchg_type& tDA::
  dchg () const
  {
    return this->dchg_.get ();
  }

  tDA::dchg_type& tDA::
  dchg ()
  {
    return this->dchg_.get ();
  }

  void tDA::
  dchg (const dchg_type& x)
  {
    this->dchg_.set (x);
  }

  tDA::dchg_type tDA::
  dchg_default_value ()
  {
    return dchg_type (false);
  }

  const tDA::qchg_type& tDA::
  qchg () const
  {
    return this->qchg_.get ();
  }

  tDA::qchg_type& tDA::
  qchg ()
  {
    return this->qchg_.get ();
  }

  void tDA::
  qchg (const qchg_type& x)
  {
    this->qchg_.set (x);
  }

  tDA::qchg_type tDA::
  qchg_default_value ()
  {
    return qchg_type (false);
  }

  const tDA::dupd_type& tDA::
  dupd () const
  {
    return this->dupd_.get ();
  }

  tDA::dupd_type& tDA::
  dupd ()
  {
    return this->dupd_.get ();
  }

  void tDA::
  dupd (const dupd_type& x)
  {
    this->dupd_.set (x);
  }

  tDA::dupd_type tDA::
  dupd_default_value ()
  {
    return dupd_type (false);
  }

  const tDA::fc_type& tDA::
  fc () const
  {
    return this->fc_.get ();
  }

  tDA::fc_type& tDA::
  fc ()
  {
    return this->fc_.get ();
  }

  void tDA::
  fc (const fc_type& x)
  {
    this->fc_.set (x);
  }

  void tDA::
  fc (::std::auto_ptr< fc_type > x)
  {
    this->fc_.set (x);
  }


  // tDAType
  // 

  const tDAType::BDA_sequence& tDAType::
  BDA () const
  {
    return this->BDA_;
  }

  tDAType::BDA_sequence& tDAType::
  BDA ()
  {
    return this->BDA_;
  }

  void tDAType::
  BDA (const BDA_sequence& s)
  {
    this->BDA_ = s;
  }

  const tDAType::iedType_type& tDAType::
  iedType () const
  {
    return this->iedType_.get ();
  }

  tDAType::iedType_type& tDAType::
  iedType ()
  {
    return this->iedType_.get ();
  }

  void tDAType::
  iedType (const iedType_type& x)
  {
    this->iedType_.set (x);
  }

  void tDAType::
  iedType (::std::auto_ptr< iedType_type > x)
  {
    this->iedType_.set (x);
  }

  const tDAType::iedType_type& tDAType::
  iedType_default_value ()
  {
    return iedType_default_value_;
  }


  // tBDA
  // 


  // tEnumType
  // 

  const tEnumType::EnumVal_sequence& tEnumType::
  EnumVal () const
  {
    return this->EnumVal_;
  }

  tEnumType::EnumVal_sequence& tEnumType::
  EnumVal ()
  {
    return this->EnumVal_;
  }

  void tEnumType::
  EnumVal (const EnumVal_sequence& s)
  {
    this->EnumVal_ = s;
  }


  // tEnumVal
  // 

  const tEnumVal::ord_type& tEnumVal::
  ord () const
  {
    return this->ord_.get ();
  }

  tEnumVal::ord_type& tEnumVal::
  ord ()
  {
    return this->ord_.get ();
  }

  void tEnumVal::
  ord (const ord_type& x)
  {
    this->ord_.set (x);
  }


  // tDataTypeTemplates
  // 

  const tDataTypeTemplates::LNodeType_sequence& tDataTypeTemplates::
  LNodeType () const
  {
    return this->LNodeType_;
  }

  tDataTypeTemplates::LNodeType_sequence& tDataTypeTemplates::
  LNodeType ()
  {
    return this->LNodeType_;
  }

  void tDataTypeTemplates::
  LNodeType (const LNodeType_sequence& s)
  {
    this->LNodeType_ = s;
  }

  const tDataTypeTemplates::DOType_sequence& tDataTypeTemplates::
  DOType () const
  {
    return this->DOType_;
  }

  tDataTypeTemplates::DOType_sequence& tDataTypeTemplates::
  DOType ()
  {
    return this->DOType_;
  }

  void tDataTypeTemplates::
  DOType (const DOType_sequence& s)
  {
    this->DOType_ = s;
  }

  const tDataTypeTemplates::DAType_sequence& tDataTypeTemplates::
  DAType () const
  {
    return this->DAType_;
  }

  tDataTypeTemplates::DAType_sequence& tDataTypeTemplates::
  DAType ()
  {
    return this->DAType_;
  }

  void tDataTypeTemplates::
  DAType (const DAType_sequence& s)
  {
    this->DAType_ = s;
  }

  const tDataTypeTemplates::EnumType_sequence& tDataTypeTemplates::
  EnumType () const
  {
    return this->EnumType_;
  }

  tDataTypeTemplates::EnumType_sequence& tDataTypeTemplates::
  EnumType ()
  {
    return this->EnumType_;
  }

  void tDataTypeTemplates::
  EnumType (const EnumType_sequence& s)
  {
    this->EnumType_ = s;
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace SCL
{
  // tAbstractDataAttribute
  //

  const tAbstractDataAttribute::valKind_type tAbstractDataAttribute::valKind_default_value_ (
    "Set");

  tAbstractDataAttribute::
  tAbstractDataAttribute (const name_type& name,
                          const bType_type& bType)
  : ::SCL::tUnNaming (),
    Val_ (this),
    name_ (name, this),
    sAddr_ (this),
    bType_ (bType, this),
    valKind_ (valKind_default_value (), this),
    type_ (this),
    count_ (count_default_value (), this)
  {
  }

  tAbstractDataAttribute::
  tAbstractDataAttribute (const tAbstractDataAttribute& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::SCL::tUnNaming (x, f, c),
    Val_ (x.Val_, f, this),
    name_ (x.name_, f, this),
    sAddr_ (x.sAddr_, f, this),
    bType_ (x.bType_, f, this),
    valKind_ (x.valKind_, f, this),
    type_ (x.type_, f, this),
    count_ (x.count_, f, this)
  {
  }

  tAbstractDataAttribute::
  tAbstractDataAttribute (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::SCL::tUnNaming (e, f | ::xml_schema::flags::base, c),
    Val_ (this),
    name_ (this),
    sAddr_ (this),
    bType_ (this),
    valKind_ (this),
    type_ (this),
    count_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tAbstractDataAttribute::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tUnNaming::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Val
      //
      if (n.name () == "Val" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< Val_type > r (
          Val_traits::create (i, f, this));

        this->Val_.push_back (r);
        continue;
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sAddr" && n.namespace_ ().empty ())
      {
        this->sAddr_.set (sAddr_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "bType" && n.namespace_ ().empty ())
      {
        this->bType_.set (bType_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "valKind" && n.namespace_ ().empty ())
      {
        this->valKind_.set (valKind_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "count" && n.namespace_ ().empty ())
      {
        this->count_.set (count_traits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!bType_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "bType",
        "");
    }

    if (!valKind_.present ())
    {
      this->valKind_.set (valKind_default_value ());
    }

    if (!count_.present ())
    {
      this->count_.set (count_default_value ());
    }
  }

  tAbstractDataAttribute* tAbstractDataAttribute::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tAbstractDataAttribute (*this, f, c);
  }

  tAbstractDataAttribute& tAbstractDataAttribute::
  operator= (const tAbstractDataAttribute& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tUnNaming& > (*this) = x;
      this->Val_ = x.Val_;
      this->name_ = x.name_;
      this->sAddr_ = x.sAddr_;
      this->bType_ = x.bType_;
      this->valKind_ = x.valKind_;
      this->type_ = x.type_;
      this->count_ = x.count_;
    }

    return *this;
  }

  tAbstractDataAttribute::
  ~tAbstractDataAttribute ()
  {
  }

  // tLNodeType
  //

  const tLNodeType::iedType_type tLNodeType::iedType_default_value_ (
    "");

  tLNodeType::
  tLNodeType (const id_type& id,
              const lnClass_type& lnClass)
  : ::SCL::tIDNaming (id),
    DO_ (this),
    iedType_ (iedType_default_value (), this),
    lnClass_ (lnClass, this)
  {
  }

  tLNodeType::
  tLNodeType (const tLNodeType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::SCL::tIDNaming (x, f, c),
    DO_ (x.DO_, f, this),
    iedType_ (x.iedType_, f, this),
    lnClass_ (x.lnClass_, f, this)
  {
  }

  tLNodeType::
  tLNodeType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::SCL::tIDNaming (e, f | ::xml_schema::flags::base, c),
    DO_ (this),
    iedType_ (this),
    lnClass_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tLNodeType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tIDNaming::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DO
      //
      if (n.name () == "DO" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< DO_type > r (
          DO_traits::create (i, f, this));

        this->DO_.push_back (r);
        continue;
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "iedType" && n.namespace_ ().empty ())
      {
        this->iedType_.set (iedType_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "lnClass" && n.namespace_ ().empty ())
      {
        this->lnClass_.set (lnClass_traits::create (i, f, this));
        continue;
      }
    }

    if (!iedType_.present ())
    {
      this->iedType_.set (iedType_default_value ());
    }

    if (!lnClass_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "lnClass",
        "");
    }
  }

  tLNodeType* tLNodeType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tLNodeType (*this, f, c);
  }

  tLNodeType& tLNodeType::
  operator= (const tLNodeType& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tIDNaming& > (*this) = x;
      this->DO_ = x.DO_;
      this->iedType_ = x.iedType_;
      this->lnClass_ = x.lnClass_;
    }

    return *this;
  }

  tLNodeType::
  ~tLNodeType ()
  {
  }

  // tDO
  //

  tDO::
  tDO (const name_type& name,
       const type_type& type)
  : ::SCL::tUnNaming (),
    name_ (name, this),
    type_ (type, this),
    accessControl_ (this),
    transient_ (transient_default_value (), this)
  {
  }

  tDO::
  tDO (const tDO& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::SCL::tUnNaming (x, f, c),
    name_ (x.name_, f, this),
    type_ (x.type_, f, this),
    accessControl_ (x.accessControl_, f, this),
    transient_ (x.transient_, f, this)
  {
  }

  tDO::
  tDO (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::SCL::tUnNaming (e, f | ::xml_schema::flags::base, c),
    name_ (this),
    type_ (this),
    accessControl_ (this),
    transient_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tDO::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tUnNaming::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "accessControl" && n.namespace_ ().empty ())
      {
        this->accessControl_.set (accessControl_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "transient" && n.namespace_ ().empty ())
      {
        this->transient_.set (transient_traits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }

    if (!transient_.present ())
    {
      this->transient_.set (transient_default_value ());
    }
  }

  tDO* tDO::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tDO (*this, f, c);
  }

  tDO& tDO::
  operator= (const tDO& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tUnNaming& > (*this) = x;
      this->name_ = x.name_;
      this->type_ = x.type_;
      this->accessControl_ = x.accessControl_;
      this->transient_ = x.transient_;
    }

    return *this;
  }

  tDO::
  ~tDO ()
  {
  }

  // tDOType
  //

  const tDOType::iedType_type tDOType::iedType_default_value_ (
    "");

  tDOType::
  tDOType (const id_type& id,
           const cdc_type& cdc)
  : ::SCL::tIDNaming (id),
    SDO_ (this),
    DA_ (this),
    iedType_ (iedType_default_value (), this),
    cdc_ (cdc, this)
  {
  }

  tDOType::
  tDOType (const tDOType& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::SCL::tIDNaming (x, f, c),
    SDO_ (x.SDO_, f, this),
    DA_ (x.DA_, f, this),
    iedType_ (x.iedType_, f, this),
    cdc_ (x.cdc_, f, this)
  {
  }

  tDOType::
  tDOType (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::SCL::tIDNaming (e, f | ::xml_schema::flags::base, c),
    SDO_ (this),
    DA_ (this),
    iedType_ (this),
    cdc_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tDOType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tIDNaming::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // SDO
      //
      if (n.name () == "SDO" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< SDO_type > r (
          SDO_traits::create (i, f, this));

        this->SDO_.push_back (r);
        continue;
      }

      // DA
      //
      if (n.name () == "DA" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< DA_type > r (
          DA_traits::create (i, f, this));

        this->DA_.push_back (r);
        continue;
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "iedType" && n.namespace_ ().empty ())
      {
        this->iedType_.set (iedType_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "cdc" && n.namespace_ ().empty ())
      {
        this->cdc_.set (cdc_traits::create (i, f, this));
        continue;
      }
    }

    if (!iedType_.present ())
    {
      this->iedType_.set (iedType_default_value ());
    }

    if (!cdc_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "cdc",
        "");
    }
  }

  tDOType* tDOType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tDOType (*this, f, c);
  }

  tDOType& tDOType::
  operator= (const tDOType& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tIDNaming& > (*this) = x;
      this->SDO_ = x.SDO_;
      this->DA_ = x.DA_;
      this->iedType_ = x.iedType_;
      this->cdc_ = x.cdc_;
    }

    return *this;
  }

  tDOType::
  ~tDOType ()
  {
  }

  // tSDO
  //

  tSDO::
  tSDO (const name_type& name,
        const type_type& type)
  : ::SCL::tNaming (name),
    type_ (type, this)
  {
  }

  tSDO::
  tSDO (const tSDO& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::SCL::tNaming (x, f, c),
    type_ (x.type_, f, this)
  {
  }

  tSDO::
  tSDO (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::SCL::tNaming (e, f | ::xml_schema::flags::base, c),
    type_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tSDO::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tNaming::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  tSDO* tSDO::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tSDO (*this, f, c);
  }

  tSDO& tSDO::
  operator= (const tSDO& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tNaming& > (*this) = x;
      this->type_ = x.type_;
    }

    return *this;
  }

  tSDO::
  ~tSDO ()
  {
  }

  // tDA
  //

  tDA::
  tDA (const name_type& name,
       const bType_type& bType,
       const fc_type& fc)
  : ::SCL::tAbstractDataAttribute (name,
                                   bType),
    dchg_ (dchg_default_value (), this),
    qchg_ (qchg_default_value (), this),
    dupd_ (dupd_default_value (), this),
    fc_ (fc, this)
  {
  }

  tDA::
  tDA (const tDA& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::SCL::tAbstractDataAttribute (x, f, c),
    dchg_ (x.dchg_, f, this),
    qchg_ (x.qchg_, f, this),
    dupd_ (x.dupd_, f, this),
    fc_ (x.fc_, f, this)
  {
  }

  tDA::
  tDA (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::SCL::tAbstractDataAttribute (e, f | ::xml_schema::flags::base, c),
    dchg_ (this),
    qchg_ (this),
    dupd_ (this),
    fc_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tDA::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tAbstractDataAttribute::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "dchg" && n.namespace_ ().empty ())
      {
        this->dchg_.set (dchg_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "qchg" && n.namespace_ ().empty ())
      {
        this->qchg_.set (qchg_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "dupd" && n.namespace_ ().empty ())
      {
        this->dupd_.set (dupd_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "fc" && n.namespace_ ().empty ())
      {
        this->fc_.set (fc_traits::create (i, f, this));
        continue;
      }
    }

    if (!dchg_.present ())
    {
      this->dchg_.set (dchg_default_value ());
    }

    if (!qchg_.present ())
    {
      this->qchg_.set (qchg_default_value ());
    }

    if (!dupd_.present ())
    {
      this->dupd_.set (dupd_default_value ());
    }

    if (!fc_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "fc",
        "");
    }
  }

  tDA* tDA::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tDA (*this, f, c);
  }

  tDA& tDA::
  operator= (const tDA& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tAbstractDataAttribute& > (*this) = x;
      this->dchg_ = x.dchg_;
      this->qchg_ = x.qchg_;
      this->dupd_ = x.dupd_;
      this->fc_ = x.fc_;
    }

    return *this;
  }

  tDA::
  ~tDA ()
  {
  }

  // tDAType
  //

  const tDAType::iedType_type tDAType::iedType_default_value_ (
    "");

  tDAType::
  tDAType (const id_type& id)
  : ::SCL::tIDNaming (id),
    BDA_ (this),
    iedType_ (iedType_default_value (), this)
  {
  }

  tDAType::
  tDAType (const tDAType& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::SCL::tIDNaming (x, f, c),
    BDA_ (x.BDA_, f, this),
    iedType_ (x.iedType_, f, this)
  {
  }

  tDAType::
  tDAType (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::SCL::tIDNaming (e, f | ::xml_schema::flags::base, c),
    BDA_ (this),
    iedType_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tDAType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tIDNaming::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // BDA
      //
      if (n.name () == "BDA" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< BDA_type > r (
          BDA_traits::create (i, f, this));

        this->BDA_.push_back (r);
        continue;
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "iedType" && n.namespace_ ().empty ())
      {
        this->iedType_.set (iedType_traits::create (i, f, this));
        continue;
      }
    }

    if (!iedType_.present ())
    {
      this->iedType_.set (iedType_default_value ());
    }
  }

  tDAType* tDAType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tDAType (*this, f, c);
  }

  tDAType& tDAType::
  operator= (const tDAType& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tIDNaming& > (*this) = x;
      this->BDA_ = x.BDA_;
      this->iedType_ = x.iedType_;
    }

    return *this;
  }

  tDAType::
  ~tDAType ()
  {
  }

  // tBDA
  //

  tBDA::
  tBDA (const name_type& name,
        const bType_type& bType)
  : ::SCL::tAbstractDataAttribute (name,
                                   bType)
  {
  }

  tBDA::
  tBDA (const tBDA& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::SCL::tAbstractDataAttribute (x, f, c)
  {
  }

  tBDA::
  tBDA (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::SCL::tAbstractDataAttribute (e, f, c)
  {
  }

  tBDA* tBDA::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tBDA (*this, f, c);
  }

  tBDA::
  ~tBDA ()
  {
  }

  // tEnumType
  //

  tEnumType::
  tEnumType (const id_type& id)
  : ::SCL::tIDNaming (id),
    EnumVal_ (this)
  {
  }

  tEnumType::
  tEnumType (const tEnumType& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::SCL::tIDNaming (x, f, c),
    EnumVal_ (x.EnumVal_, f, this)
  {
  }

  tEnumType::
  tEnumType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::SCL::tIDNaming (e, f | ::xml_schema::flags::base, c),
    EnumVal_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tEnumType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tIDNaming::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // EnumVal
      //
      if (n.name () == "EnumVal" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< EnumVal_type > r (
          EnumVal_traits::create (i, f, this));

        this->EnumVal_.push_back (r);
        continue;
      }

      break;
    }
  }

  tEnumType* tEnumType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tEnumType (*this, f, c);
  }

  tEnumType& tEnumType::
  operator= (const tEnumType& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tIDNaming& > (*this) = x;
      this->EnumVal_ = x.EnumVal_;
    }

    return *this;
  }

  tEnumType::
  ~tEnumType ()
  {
  }

  // tEnumVal
  //

  tEnumVal::
  tEnumVal (const ord_type& ord)
  : ::xml_schema::normalized_string (),
    ord_ (ord, this)
  {
  }

  tEnumVal::
  tEnumVal (const char* _xsd_normalized_string_base,
            const ord_type& ord)
  : ::xml_schema::normalized_string (_xsd_normalized_string_base),
    ord_ (ord, this)
  {
  }

  tEnumVal::
  tEnumVal (const ::std::string& _xsd_normalized_string_base,
            const ord_type& ord)
  : ::xml_schema::normalized_string (_xsd_normalized_string_base),
    ord_ (ord, this)
  {
  }

  tEnumVal::
  tEnumVal (const ::xml_schema::normalized_string& _xsd_normalized_string_base,
            const ord_type& ord)
  : ::xml_schema::normalized_string (_xsd_normalized_string_base),
    ord_ (ord, this)
  {
  }

  tEnumVal::
  tEnumVal (const tEnumVal& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::normalized_string (x, f, c),
    ord_ (x.ord_, f, this)
  {
  }

  tEnumVal::
  tEnumVal (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::normalized_string (e, f | ::xml_schema::flags::base, c),
    ord_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void tEnumVal::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ord" && n.namespace_ ().empty ())
      {
        this->ord_.set (ord_traits::create (i, f, this));
        continue;
      }
    }

    if (!ord_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ord",
        "");
    }
  }

  tEnumVal* tEnumVal::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tEnumVal (*this, f, c);
  }

  tEnumVal& tEnumVal::
  operator= (const tEnumVal& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::normalized_string& > (*this) = x;
      this->ord_ = x.ord_;
    }

    return *this;
  }

  tEnumVal::
  ~tEnumVal ()
  {
  }

  // tDataTypeTemplates
  //

  tDataTypeTemplates::
  tDataTypeTemplates ()
  : ::xml_schema::type (),
    LNodeType_ (this),
    DOType_ (this),
    DAType_ (this),
    EnumType_ (this)
  {
  }

  tDataTypeTemplates::
  tDataTypeTemplates (const tDataTypeTemplates& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    LNodeType_ (x.LNodeType_, f, this),
    DOType_ (x.DOType_, f, this),
    DAType_ (x.DAType_, f, this),
    EnumType_ (x.EnumType_, f, this)
  {
  }

  tDataTypeTemplates::
  tDataTypeTemplates (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    LNodeType_ (this),
    DOType_ (this),
    DAType_ (this),
    EnumType_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void tDataTypeTemplates::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // LNodeType
      //
      if (n.name () == "LNodeType" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< LNodeType_type > r (
          LNodeType_traits::create (i, f, this));

        this->LNodeType_.push_back (r);
        continue;
      }

      // DOType
      //
      if (n.name () == "DOType" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< DOType_type > r (
          DOType_traits::create (i, f, this));

        this->DOType_.push_back (r);
        continue;
      }

      // DAType
      //
      if (n.name () == "DAType" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< DAType_type > r (
          DAType_traits::create (i, f, this));

        this->DAType_.push_back (r);
        continue;
      }

      // EnumType
      //
      if (n.name () == "EnumType" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< EnumType_type > r (
          EnumType_traits::create (i, f, this));

        this->EnumType_.push_back (r);
        continue;
      }

      break;
    }
  }

  tDataTypeTemplates* tDataTypeTemplates::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tDataTypeTemplates (*this, f, c);
  }

  tDataTypeTemplates& tDataTypeTemplates::
  operator= (const tDataTypeTemplates& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->LNodeType_ = x.LNodeType_;
      this->DOType_ = x.DOType_;
      this->DAType_ = x.DAType_;
      this->EnumType_ = x.EnumType_;
    }

    return *this;
  }

  tDataTypeTemplates::
  ~tDataTypeTemplates ()
  {
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace SCL
{
  ::std::auto_ptr< ::SCL::tDataTypeTemplates >
  DataTypeTemplates (const ::std::string& u,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::SCL::tDataTypeTemplates > (
      ::SCL::DataTypeTemplates (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::SCL::tDataTypeTemplates >
  DataTypeTemplates (const ::std::string& u,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::SCL::tDataTypeTemplates > (
      ::SCL::DataTypeTemplates (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::SCL::tDataTypeTemplates >
  DataTypeTemplates (const ::std::string& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::SCL::tDataTypeTemplates > (
      ::SCL::DataTypeTemplates (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::SCL::tDataTypeTemplates >
  DataTypeTemplates (::std::istream& is,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::SCL::DataTypeTemplates (isrc, f, p);
  }

  ::std::auto_ptr< ::SCL::tDataTypeTemplates >
  DataTypeTemplates (::std::istream& is,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::SCL::DataTypeTemplates (isrc, h, f, p);
  }

  ::std::auto_ptr< ::SCL::tDataTypeTemplates >
  DataTypeTemplates (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::SCL::DataTypeTemplates (isrc, h, f, p);
  }

  ::std::auto_ptr< ::SCL::tDataTypeTemplates >
  DataTypeTemplates (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::SCL::DataTypeTemplates (isrc, f, p);
  }

  ::std::auto_ptr< ::SCL::tDataTypeTemplates >
  DataTypeTemplates (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::SCL::DataTypeTemplates (isrc, h, f, p);
  }

  ::std::auto_ptr< ::SCL::tDataTypeTemplates >
  DataTypeTemplates (::std::istream& is,
                     const ::std::string& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::SCL::DataTypeTemplates (isrc, h, f, p);
  }

  ::std::auto_ptr< ::SCL::tDataTypeTemplates >
  DataTypeTemplates (::xercesc::InputSource& i,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::SCL::tDataTypeTemplates > (
      ::SCL::DataTypeTemplates (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::SCL::tDataTypeTemplates >
  DataTypeTemplates (::xercesc::InputSource& i,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::SCL::tDataTypeTemplates > (
      ::SCL::DataTypeTemplates (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::SCL::tDataTypeTemplates >
  DataTypeTemplates (::xercesc::InputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::SCL::tDataTypeTemplates > (
      ::SCL::DataTypeTemplates (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::SCL::tDataTypeTemplates >
  DataTypeTemplates (const ::xercesc::DOMDocument& doc,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::SCL::tDataTypeTemplates > (
        ::SCL::DataTypeTemplates (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "DataTypeTemplates" &&
        n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
    {
      ::std::auto_ptr< ::SCL::tDataTypeTemplates > r (
        ::xsd::cxx::tree::traits< ::SCL::tDataTypeTemplates, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "DataTypeTemplates",
      "http://www.iec.ch/61850/2006/SCL");
  }

  ::std::auto_ptr< ::SCL::tDataTypeTemplates >
  DataTypeTemplates (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "DataTypeTemplates" &&
        n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
    {
      ::std::auto_ptr< ::SCL::tDataTypeTemplates > r (
        ::xsd::cxx::tree::traits< ::SCL::tDataTypeTemplates, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "DataTypeTemplates",
      "http://www.iec.ch/61850/2006/SCL");
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

