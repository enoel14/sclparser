// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "SCL_Substation.hxx"

namespace SCL
{
  // tLNodeContainer
  // 

  const tLNodeContainer::LNode_sequence& tLNodeContainer::
  LNode () const
  {
    return this->LNode_;
  }

  tLNodeContainer::LNode_sequence& tLNodeContainer::
  LNode ()
  {
    return this->LNode_;
  }

  void tLNodeContainer::
  LNode (const LNode_sequence& s)
  {
    this->LNode_ = s;
  }


  // tPowerSystemResource
  // 


  // tEquipmentContainer
  // 

  const tEquipmentContainer::PowerTransformer_sequence& tEquipmentContainer::
  PowerTransformer () const
  {
    return this->PowerTransformer_;
  }

  tEquipmentContainer::PowerTransformer_sequence& tEquipmentContainer::
  PowerTransformer ()
  {
    return this->PowerTransformer_;
  }

  void tEquipmentContainer::
  PowerTransformer (const PowerTransformer_sequence& s)
  {
    this->PowerTransformer_ = s;
  }

  const tEquipmentContainer::GeneralEquipment_sequence& tEquipmentContainer::
  GeneralEquipment () const
  {
    return this->GeneralEquipment_;
  }

  tEquipmentContainer::GeneralEquipment_sequence& tEquipmentContainer::
  GeneralEquipment ()
  {
    return this->GeneralEquipment_;
  }

  void tEquipmentContainer::
  GeneralEquipment (const GeneralEquipment_sequence& s)
  {
    this->GeneralEquipment_ = s;
  }


  // tEquipment
  // 

  const tEquipment::virtual_type& tEquipment::
  virtual_ () const
  {
    return this->virtual__.get ();
  }

  tEquipment::virtual_type& tEquipment::
  virtual_ ()
  {
    return this->virtual__.get ();
  }

  void tEquipment::
  virtual_ (const virtual_type& x)
  {
    this->virtual__.set (x);
  }

  tEquipment::virtual_type tEquipment::
  virtual_default_value ()
  {
    return virtual_type (false);
  }


  // tAbstractConductingEquipment
  // 

  const tAbstractConductingEquipment::Terminal_sequence& tAbstractConductingEquipment::
  Terminal () const
  {
    return this->Terminal_;
  }

  tAbstractConductingEquipment::Terminal_sequence& tAbstractConductingEquipment::
  Terminal ()
  {
    return this->Terminal_;
  }

  void tAbstractConductingEquipment::
  Terminal (const Terminal_sequence& s)
  {
    this->Terminal_ = s;
  }

  const tAbstractConductingEquipment::SubEquipment_sequence& tAbstractConductingEquipment::
  SubEquipment () const
  {
    return this->SubEquipment_;
  }

  tAbstractConductingEquipment::SubEquipment_sequence& tAbstractConductingEquipment::
  SubEquipment ()
  {
    return this->SubEquipment_;
  }

  void tAbstractConductingEquipment::
  SubEquipment (const SubEquipment_sequence& s)
  {
    this->SubEquipment_ = s;
  }


  // tConductingEquipment
  // 

  const tConductingEquipment::type_type& tConductingEquipment::
  type () const
  {
    return this->type_.get ();
  }

  tConductingEquipment::type_type& tConductingEquipment::
  type ()
  {
    return this->type_.get ();
  }

  void tConductingEquipment::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void tConductingEquipment::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }


  // tSubEquipment
  // 

  const tSubEquipment::phase_type& tSubEquipment::
  phase () const
  {
    return this->phase_.get ();
  }

  tSubEquipment::phase_type& tSubEquipment::
  phase ()
  {
    return this->phase_.get ();
  }

  void tSubEquipment::
  phase (const phase_type& x)
  {
    this->phase_.set (x);
  }

  void tSubEquipment::
  phase (::std::auto_ptr< phase_type > x)
  {
    this->phase_.set (x);
  }

  const tSubEquipment::phase_type& tSubEquipment::
  phase_default_value ()
  {
    return phase_default_value_;
  }

  const tSubEquipment::virtual_type& tSubEquipment::
  virtual_ () const
  {
    return this->virtual__.get ();
  }

  tSubEquipment::virtual_type& tSubEquipment::
  virtual_ ()
  {
    return this->virtual__.get ();
  }

  void tSubEquipment::
  virtual_ (const virtual_type& x)
  {
    this->virtual__.set (x);
  }

  tSubEquipment::virtual_type tSubEquipment::
  virtual_default_value ()
  {
    return virtual_type (false);
  }


  // tPowerTransformer
  // 

  const tPowerTransformer::TransformerWinding_sequence& tPowerTransformer::
  TransformerWinding () const
  {
    return this->TransformerWinding_;
  }

  tPowerTransformer::TransformerWinding_sequence& tPowerTransformer::
  TransformerWinding ()
  {
    return this->TransformerWinding_;
  }

  void tPowerTransformer::
  TransformerWinding (const TransformerWinding_sequence& s)
  {
    this->TransformerWinding_ = s;
  }

  const tPowerTransformer::type_type& tPowerTransformer::
  type () const
  {
    return this->type_.get ();
  }

  const tPowerTransformer::type_type& tPowerTransformer::
  type_default_value ()
  {
    return type_default_value_;
  }


  // tTransformerWinding
  // 

  const tTransformerWinding::TapChanger_optional& tTransformerWinding::
  TapChanger () const
  {
    return this->TapChanger_;
  }

  tTransformerWinding::TapChanger_optional& tTransformerWinding::
  TapChanger ()
  {
    return this->TapChanger_;
  }

  void tTransformerWinding::
  TapChanger (const TapChanger_type& x)
  {
    this->TapChanger_.set (x);
  }

  void tTransformerWinding::
  TapChanger (const TapChanger_optional& x)
  {
    this->TapChanger_ = x;
  }

  void tTransformerWinding::
  TapChanger (::std::auto_ptr< TapChanger_type > x)
  {
    this->TapChanger_.set (x);
  }

  const tTransformerWinding::type_type& tTransformerWinding::
  type () const
  {
    return this->type_.get ();
  }

  const tTransformerWinding::type_type& tTransformerWinding::
  type_default_value ()
  {
    return type_default_value_;
  }


  // tTapChanger
  // 

  const tTapChanger::type_type& tTapChanger::
  type () const
  {
    return this->type_.get ();
  }

  const tTapChanger::type_type& tTapChanger::
  type_default_value ()
  {
    return type_default_value_;
  }

  const tTapChanger::virtual_type& tTapChanger::
  virtual_ () const
  {
    return this->virtual__.get ();
  }

  tTapChanger::virtual_type& tTapChanger::
  virtual_ ()
  {
    return this->virtual__.get ();
  }

  void tTapChanger::
  virtual_ (const virtual_type& x)
  {
    this->virtual__.set (x);
  }

  tTapChanger::virtual_type tTapChanger::
  virtual_default_value ()
  {
    return virtual_type (false);
  }


  // tGeneralEquipment
  // 

  const tGeneralEquipment::type_type& tGeneralEquipment::
  type () const
  {
    return this->type_.get ();
  }

  tGeneralEquipment::type_type& tGeneralEquipment::
  type ()
  {
    return this->type_.get ();
  }

  void tGeneralEquipment::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void tGeneralEquipment::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }


  // tSubstation
  // 

  const tSubstation::VoltageLevel_sequence& tSubstation::
  VoltageLevel () const
  {
    return this->VoltageLevel_;
  }

  tSubstation::VoltageLevel_sequence& tSubstation::
  VoltageLevel ()
  {
    return this->VoltageLevel_;
  }

  void tSubstation::
  VoltageLevel (const VoltageLevel_sequence& s)
  {
    this->VoltageLevel_ = s;
  }

  const tSubstation::Function_sequence& tSubstation::
  Function () const
  {
    return this->Function_;
  }

  tSubstation::Function_sequence& tSubstation::
  Function ()
  {
    return this->Function_;
  }

  void tSubstation::
  Function (const Function_sequence& s)
  {
    this->Function_ = s;
  }


  // tVoltageLevel
  // 

  const tVoltageLevel::Voltage_optional& tVoltageLevel::
  Voltage () const
  {
    return this->Voltage_;
  }

  tVoltageLevel::Voltage_optional& tVoltageLevel::
  Voltage ()
  {
    return this->Voltage_;
  }

  void tVoltageLevel::
  Voltage (const Voltage_type& x)
  {
    this->Voltage_.set (x);
  }

  void tVoltageLevel::
  Voltage (const Voltage_optional& x)
  {
    this->Voltage_ = x;
  }

  void tVoltageLevel::
  Voltage (::std::auto_ptr< Voltage_type > x)
  {
    this->Voltage_.set (x);
  }

  const tVoltageLevel::Bay_sequence& tVoltageLevel::
  Bay () const
  {
    return this->Bay_;
  }

  tVoltageLevel::Bay_sequence& tVoltageLevel::
  Bay ()
  {
    return this->Bay_;
  }

  void tVoltageLevel::
  Bay (const Bay_sequence& s)
  {
    this->Bay_ = s;
  }


  // tBay
  // 

  const tBay::ConductingEquipment_sequence& tBay::
  ConductingEquipment () const
  {
    return this->ConductingEquipment_;
  }

  tBay::ConductingEquipment_sequence& tBay::
  ConductingEquipment ()
  {
    return this->ConductingEquipment_;
  }

  void tBay::
  ConductingEquipment (const ConductingEquipment_sequence& s)
  {
    this->ConductingEquipment_ = s;
  }

  const tBay::ConnectivityNode_sequence& tBay::
  ConnectivityNode () const
  {
    return this->ConnectivityNode_;
  }

  tBay::ConnectivityNode_sequence& tBay::
  ConnectivityNode ()
  {
    return this->ConnectivityNode_;
  }

  void tBay::
  ConnectivityNode (const ConnectivityNode_sequence& s)
  {
    this->ConnectivityNode_ = s;
  }


  // tLNode
  // 

  const tLNode::lnInst_type& tLNode::
  lnInst () const
  {
    return this->lnInst_.get ();
  }

  tLNode::lnInst_type& tLNode::
  lnInst ()
  {
    return this->lnInst_.get ();
  }

  void tLNode::
  lnInst (const lnInst_type& x)
  {
    this->lnInst_.set (x);
  }

  void tLNode::
  lnInst (::std::auto_ptr< lnInst_type > x)
  {
    this->lnInst_.set (x);
  }

  const tLNode::lnInst_type& tLNode::
  lnInst_default_value ()
  {
    return lnInst_default_value_;
  }

  const tLNode::lnClass_type& tLNode::
  lnClass () const
  {
    return this->lnClass_.get ();
  }

  tLNode::lnClass_type& tLNode::
  lnClass ()
  {
    return this->lnClass_.get ();
  }

  void tLNode::
  lnClass (const lnClass_type& x)
  {
    this->lnClass_.set (x);
  }

  void tLNode::
  lnClass (::std::auto_ptr< lnClass_type > x)
  {
    this->lnClass_.set (x);
  }

  const tLNode::iedName_type& tLNode::
  iedName () const
  {
    return this->iedName_.get ();
  }

  tLNode::iedName_type& tLNode::
  iedName ()
  {
    return this->iedName_.get ();
  }

  void tLNode::
  iedName (const iedName_type& x)
  {
    this->iedName_.set (x);
  }

  void tLNode::
  iedName (::std::auto_ptr< iedName_type > x)
  {
    this->iedName_.set (x);
  }

  const tLNode::iedName_type& tLNode::
  iedName_default_value ()
  {
    return iedName_default_value_;
  }

  const tLNode::ldInst_type& tLNode::
  ldInst () const
  {
    return this->ldInst_.get ();
  }

  tLNode::ldInst_type& tLNode::
  ldInst ()
  {
    return this->ldInst_.get ();
  }

  void tLNode::
  ldInst (const ldInst_type& x)
  {
    this->ldInst_.set (x);
  }

  void tLNode::
  ldInst (::std::auto_ptr< ldInst_type > x)
  {
    this->ldInst_.set (x);
  }

  const tLNode::ldInst_type& tLNode::
  ldInst_default_value ()
  {
    return ldInst_default_value_;
  }

  const tLNode::prefix_type& tLNode::
  prefix () const
  {
    return this->prefix_.get ();
  }

  tLNode::prefix_type& tLNode::
  prefix ()
  {
    return this->prefix_.get ();
  }

  void tLNode::
  prefix (const prefix_type& x)
  {
    this->prefix_.set (x);
  }

  void tLNode::
  prefix (::std::auto_ptr< prefix_type > x)
  {
    this->prefix_.set (x);
  }

  const tLNode::prefix_type& tLNode::
  prefix_default_value ()
  {
    return prefix_default_value_;
  }

  const tLNode::lnType_optional& tLNode::
  lnType () const
  {
    return this->lnType_;
  }

  tLNode::lnType_optional& tLNode::
  lnType ()
  {
    return this->lnType_;
  }

  void tLNode::
  lnType (const lnType_type& x)
  {
    this->lnType_.set (x);
  }

  void tLNode::
  lnType (const lnType_optional& x)
  {
    this->lnType_ = x;
  }

  void tLNode::
  lnType (::std::auto_ptr< lnType_type > x)
  {
    this->lnType_.set (x);
  }


  // tFunction
  // 

  const tFunction::SubFunction_sequence& tFunction::
  SubFunction () const
  {
    return this->SubFunction_;
  }

  tFunction::SubFunction_sequence& tFunction::
  SubFunction ()
  {
    return this->SubFunction_;
  }

  void tFunction::
  SubFunction (const SubFunction_sequence& s)
  {
    this->SubFunction_ = s;
  }

  const tFunction::GeneralEquipment_sequence& tFunction::
  GeneralEquipment () const
  {
    return this->GeneralEquipment_;
  }

  tFunction::GeneralEquipment_sequence& tFunction::
  GeneralEquipment ()
  {
    return this->GeneralEquipment_;
  }

  void tFunction::
  GeneralEquipment (const GeneralEquipment_sequence& s)
  {
    this->GeneralEquipment_ = s;
  }


  // tSubFunction
  // 

  const tSubFunction::GeneralEquipment_sequence& tSubFunction::
  GeneralEquipment () const
  {
    return this->GeneralEquipment_;
  }

  tSubFunction::GeneralEquipment_sequence& tSubFunction::
  GeneralEquipment ()
  {
    return this->GeneralEquipment_;
  }

  void tSubFunction::
  GeneralEquipment (const GeneralEquipment_sequence& s)
  {
    this->GeneralEquipment_ = s;
  }


  // tConnectivityNode
  // 

  const tConnectivityNode::pathName_type& tConnectivityNode::
  pathName () const
  {
    return this->pathName_.get ();
  }

  tConnectivityNode::pathName_type& tConnectivityNode::
  pathName ()
  {
    return this->pathName_.get ();
  }

  void tConnectivityNode::
  pathName (const pathName_type& x)
  {
    this->pathName_.set (x);
  }

  void tConnectivityNode::
  pathName (::std::auto_ptr< pathName_type > x)
  {
    this->pathName_.set (x);
  }


  // tTerminal
  // 

  const tTerminal::name_type& tTerminal::
  name () const
  {
    return this->name_.get ();
  }

  tTerminal::name_type& tTerminal::
  name ()
  {
    return this->name_.get ();
  }

  void tTerminal::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void tTerminal::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const tTerminal::name_type& tTerminal::
  name_default_value ()
  {
    return name_default_value_;
  }

  const tTerminal::connectivityNode_type& tTerminal::
  connectivityNode () const
  {
    return this->connectivityNode_.get ();
  }

  tTerminal::connectivityNode_type& tTerminal::
  connectivityNode ()
  {
    return this->connectivityNode_.get ();
  }

  void tTerminal::
  connectivityNode (const connectivityNode_type& x)
  {
    this->connectivityNode_.set (x);
  }

  void tTerminal::
  connectivityNode (::std::auto_ptr< connectivityNode_type > x)
  {
    this->connectivityNode_.set (x);
  }

  const tTerminal::substationName_type& tTerminal::
  substationName () const
  {
    return this->substationName_.get ();
  }

  tTerminal::substationName_type& tTerminal::
  substationName ()
  {
    return this->substationName_.get ();
  }

  void tTerminal::
  substationName (const substationName_type& x)
  {
    this->substationName_.set (x);
  }

  void tTerminal::
  substationName (::std::auto_ptr< substationName_type > x)
  {
    this->substationName_.set (x);
  }

  const tTerminal::voltageLevelName_type& tTerminal::
  voltageLevelName () const
  {
    return this->voltageLevelName_.get ();
  }

  tTerminal::voltageLevelName_type& tTerminal::
  voltageLevelName ()
  {
    return this->voltageLevelName_.get ();
  }

  void tTerminal::
  voltageLevelName (const voltageLevelName_type& x)
  {
    this->voltageLevelName_.set (x);
  }

  void tTerminal::
  voltageLevelName (::std::auto_ptr< voltageLevelName_type > x)
  {
    this->voltageLevelName_.set (x);
  }

  const tTerminal::bayName_type& tTerminal::
  bayName () const
  {
    return this->bayName_.get ();
  }

  tTerminal::bayName_type& tTerminal::
  bayName ()
  {
    return this->bayName_.get ();
  }

  void tTerminal::
  bayName (const bayName_type& x)
  {
    this->bayName_.set (x);
  }

  void tTerminal::
  bayName (::std::auto_ptr< bayName_type > x)
  {
    this->bayName_.set (x);
  }

  const tTerminal::cNodeName_type& tTerminal::
  cNodeName () const
  {
    return this->cNodeName_.get ();
  }

  tTerminal::cNodeName_type& tTerminal::
  cNodeName ()
  {
    return this->cNodeName_.get ();
  }

  void tTerminal::
  cNodeName (const cNodeName_type& x)
  {
    this->cNodeName_.set (x);
  }

  void tTerminal::
  cNodeName (::std::auto_ptr< cNodeName_type > x)
  {
    this->cNodeName_.set (x);
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace SCL
{
  // tLNodeContainer
  //

  tLNodeContainer::
  tLNodeContainer (const name_type& name)
  : ::SCL::tNaming (name),
    LNode_ (this)
  {
  }

  tLNodeContainer::
  tLNodeContainer (const tLNodeContainer& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::SCL::tNaming (x, f, c),
    LNode_ (x.LNode_, f, this)
  {
  }

  tLNodeContainer::
  tLNodeContainer (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::SCL::tNaming (e, f | ::xml_schema::flags::base, c),
    LNode_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tLNodeContainer::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tNaming::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // LNode
      //
      if (n.name () == "LNode" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< LNode_type > r (
          LNode_traits::create (i, f, this));

        this->LNode_.push_back (r);
        continue;
      }

      break;
    }
  }

  tLNodeContainer* tLNodeContainer::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tLNodeContainer (*this, f, c);
  }

  tLNodeContainer& tLNodeContainer::
  operator= (const tLNodeContainer& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tNaming& > (*this) = x;
      this->LNode_ = x.LNode_;
    }

    return *this;
  }

  tLNodeContainer::
  ~tLNodeContainer ()
  {
  }

  // tPowerSystemResource
  //

  tPowerSystemResource::
  tPowerSystemResource (const name_type& name)
  : ::SCL::tLNodeContainer (name)
  {
  }

  tPowerSystemResource::
  tPowerSystemResource (const tPowerSystemResource& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::SCL::tLNodeContainer (x, f, c)
  {
  }

  tPowerSystemResource::
  tPowerSystemResource (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::SCL::tLNodeContainer (e, f, c)
  {
  }

  tPowerSystemResource* tPowerSystemResource::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tPowerSystemResource (*this, f, c);
  }

  tPowerSystemResource::
  ~tPowerSystemResource ()
  {
  }

  // tEquipmentContainer
  //

  tEquipmentContainer::
  tEquipmentContainer (const name_type& name)
  : ::SCL::tPowerSystemResource (name),
    PowerTransformer_ (this),
    GeneralEquipment_ (this)
  {
  }

  tEquipmentContainer::
  tEquipmentContainer (const tEquipmentContainer& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::SCL::tPowerSystemResource (x, f, c),
    PowerTransformer_ (x.PowerTransformer_, f, this),
    GeneralEquipment_ (x.GeneralEquipment_, f, this)
  {
  }

  tEquipmentContainer::
  tEquipmentContainer (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::SCL::tPowerSystemResource (e, f | ::xml_schema::flags::base, c),
    PowerTransformer_ (this),
    GeneralEquipment_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tEquipmentContainer::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tPowerSystemResource::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // PowerTransformer
      //
      if (n.name () == "PowerTransformer" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< PowerTransformer_type > r (
          PowerTransformer_traits::create (i, f, this));

        this->PowerTransformer_.push_back (r);
        continue;
      }

      // GeneralEquipment
      //
      if (n.name () == "GeneralEquipment" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< GeneralEquipment_type > r (
          GeneralEquipment_traits::create (i, f, this));

        this->GeneralEquipment_.push_back (r);
        continue;
      }

      break;
    }
  }

  tEquipmentContainer* tEquipmentContainer::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tEquipmentContainer (*this, f, c);
  }

  tEquipmentContainer& tEquipmentContainer::
  operator= (const tEquipmentContainer& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tPowerSystemResource& > (*this) = x;
      this->PowerTransformer_ = x.PowerTransformer_;
      this->GeneralEquipment_ = x.GeneralEquipment_;
    }

    return *this;
  }

  tEquipmentContainer::
  ~tEquipmentContainer ()
  {
  }

  // tEquipment
  //

  tEquipment::
  tEquipment (const name_type& name)
  : ::SCL::tPowerSystemResource (name),
    virtual__ (virtual_default_value (), this)
  {
  }

  tEquipment::
  tEquipment (const tEquipment& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::SCL::tPowerSystemResource (x, f, c),
    virtual__ (x.virtual__, f, this)
  {
  }

  tEquipment::
  tEquipment (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::SCL::tPowerSystemResource (e, f | ::xml_schema::flags::base, c),
    virtual__ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tEquipment::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tPowerSystemResource::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "virtual" && n.namespace_ ().empty ())
      {
        this->virtual__.set (virtual_traits::create (i, f, this));
        continue;
      }
    }

    if (!virtual__.present ())
    {
      this->virtual__.set (virtual_default_value ());
    }
  }

  tEquipment* tEquipment::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tEquipment (*this, f, c);
  }

  tEquipment& tEquipment::
  operator= (const tEquipment& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tPowerSystemResource& > (*this) = x;
      this->virtual__ = x.virtual__;
    }

    return *this;
  }

  tEquipment::
  ~tEquipment ()
  {
  }

  // tAbstractConductingEquipment
  //

  tAbstractConductingEquipment::
  tAbstractConductingEquipment (const name_type& name)
  : ::SCL::tEquipment (name),
    Terminal_ (this),
    SubEquipment_ (this)
  {
  }

  tAbstractConductingEquipment::
  tAbstractConductingEquipment (const tAbstractConductingEquipment& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::SCL::tEquipment (x, f, c),
    Terminal_ (x.Terminal_, f, this),
    SubEquipment_ (x.SubEquipment_, f, this)
  {
  }

  tAbstractConductingEquipment::
  tAbstractConductingEquipment (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::SCL::tEquipment (e, f | ::xml_schema::flags::base, c),
    Terminal_ (this),
    SubEquipment_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tAbstractConductingEquipment::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tEquipment::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Terminal
      //
      if (n.name () == "Terminal" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< Terminal_type > r (
          Terminal_traits::create (i, f, this));

        this->Terminal_.push_back (r);
        continue;
      }

      // SubEquipment
      //
      if (n.name () == "SubEquipment" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< SubEquipment_type > r (
          SubEquipment_traits::create (i, f, this));

        this->SubEquipment_.push_back (r);
        continue;
      }

      break;
    }
  }

  tAbstractConductingEquipment* tAbstractConductingEquipment::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tAbstractConductingEquipment (*this, f, c);
  }

  tAbstractConductingEquipment& tAbstractConductingEquipment::
  operator= (const tAbstractConductingEquipment& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tEquipment& > (*this) = x;
      this->Terminal_ = x.Terminal_;
      this->SubEquipment_ = x.SubEquipment_;
    }

    return *this;
  }

  tAbstractConductingEquipment::
  ~tAbstractConductingEquipment ()
  {
  }

  // tConductingEquipment
  //

  tConductingEquipment::
  tConductingEquipment (const name_type& name,
                        const type_type& type)
  : ::SCL::tAbstractConductingEquipment (name),
    type_ (type, this)
  {
  }

  tConductingEquipment::
  tConductingEquipment (const tConductingEquipment& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::SCL::tAbstractConductingEquipment (x, f, c),
    type_ (x.type_, f, this)
  {
  }

  tConductingEquipment::
  tConductingEquipment (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::SCL::tAbstractConductingEquipment (e, f | ::xml_schema::flags::base, c),
    type_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tConductingEquipment::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tAbstractConductingEquipment::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  tConductingEquipment* tConductingEquipment::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tConductingEquipment (*this, f, c);
  }

  tConductingEquipment& tConductingEquipment::
  operator= (const tConductingEquipment& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tAbstractConductingEquipment& > (*this) = x;
      this->type_ = x.type_;
    }

    return *this;
  }

  tConductingEquipment::
  ~tConductingEquipment ()
  {
  }

  // tSubEquipment
  //

  const tSubEquipment::phase_type tSubEquipment::phase_default_value_ (
    "none");

  tSubEquipment::
  tSubEquipment (const name_type& name)
  : ::SCL::tPowerSystemResource (name),
    phase_ (phase_default_value (), this),
    virtual__ (virtual_default_value (), this)
  {
  }

  tSubEquipment::
  tSubEquipment (const tSubEquipment& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::SCL::tPowerSystemResource (x, f, c),
    phase_ (x.phase_, f, this),
    virtual__ (x.virtual__, f, this)
  {
  }

  tSubEquipment::
  tSubEquipment (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::SCL::tPowerSystemResource (e, f | ::xml_schema::flags::base, c),
    phase_ (this),
    virtual__ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tSubEquipment::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tPowerSystemResource::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "phase" && n.namespace_ ().empty ())
      {
        this->phase_.set (phase_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "virtual" && n.namespace_ ().empty ())
      {
        this->virtual__.set (virtual_traits::create (i, f, this));
        continue;
      }
    }

    if (!phase_.present ())
    {
      this->phase_.set (phase_default_value ());
    }

    if (!virtual__.present ())
    {
      this->virtual__.set (virtual_default_value ());
    }
  }

  tSubEquipment* tSubEquipment::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tSubEquipment (*this, f, c);
  }

  tSubEquipment& tSubEquipment::
  operator= (const tSubEquipment& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tPowerSystemResource& > (*this) = x;
      this->phase_ = x.phase_;
      this->virtual__ = x.virtual__;
    }

    return *this;
  }

  tSubEquipment::
  ~tSubEquipment ()
  {
  }

  // tPowerTransformer
  //

  const tPowerTransformer::type_type tPowerTransformer::type_default_value_ (
    "PTR");

  tPowerTransformer::
  tPowerTransformer (const name_type& name)
  : ::SCL::tEquipment (name),
    TransformerWinding_ (this),
    type_ (type_default_value (), this)
  {
  }

  tPowerTransformer::
  tPowerTransformer (const tPowerTransformer& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::SCL::tEquipment (x, f, c),
    TransformerWinding_ (x.TransformerWinding_, f, this),
    type_ (x.type_, f, this)
  {
  }

  tPowerTransformer::
  tPowerTransformer (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::SCL::tEquipment (e, f | ::xml_schema::flags::base, c),
    TransformerWinding_ (this),
    type_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tPowerTransformer::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tEquipment::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // TransformerWinding
      //
      if (n.name () == "TransformerWinding" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< TransformerWinding_type > r (
          TransformerWinding_traits::create (i, f, this));

        this->TransformerWinding_.push_back (r);
        continue;
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      this->type_.set (type_default_value ());
    }
  }

  tPowerTransformer* tPowerTransformer::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tPowerTransformer (*this, f, c);
  }

  tPowerTransformer& tPowerTransformer::
  operator= (const tPowerTransformer& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tEquipment& > (*this) = x;
      this->TransformerWinding_ = x.TransformerWinding_;
      this->type_ = x.type_;
    }

    return *this;
  }

  tPowerTransformer::
  ~tPowerTransformer ()
  {
  }

  // tTransformerWinding
  //

  const tTransformerWinding::type_type tTransformerWinding::type_default_value_ (
    "PTW");

  tTransformerWinding::
  tTransformerWinding (const name_type& name)
  : ::SCL::tAbstractConductingEquipment (name),
    TapChanger_ (this),
    type_ (type_default_value (), this)
  {
  }

  tTransformerWinding::
  tTransformerWinding (const tTransformerWinding& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::SCL::tAbstractConductingEquipment (x, f, c),
    TapChanger_ (x.TapChanger_, f, this),
    type_ (x.type_, f, this)
  {
  }

  tTransformerWinding::
  tTransformerWinding (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::SCL::tAbstractConductingEquipment (e, f | ::xml_schema::flags::base, c),
    TapChanger_ (this),
    type_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tTransformerWinding::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tAbstractConductingEquipment::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // TapChanger
      //
      if (n.name () == "TapChanger" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< TapChanger_type > r (
          TapChanger_traits::create (i, f, this));

        if (!this->TapChanger_)
        {
          this->TapChanger_.set (r);
          continue;
        }
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      this->type_.set (type_default_value ());
    }
  }

  tTransformerWinding* tTransformerWinding::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tTransformerWinding (*this, f, c);
  }

  tTransformerWinding& tTransformerWinding::
  operator= (const tTransformerWinding& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tAbstractConductingEquipment& > (*this) = x;
      this->TapChanger_ = x.TapChanger_;
      this->type_ = x.type_;
    }

    return *this;
  }

  tTransformerWinding::
  ~tTransformerWinding ()
  {
  }

  // tTapChanger
  //

  const tTapChanger::type_type tTapChanger::type_default_value_ (
    "LTC");

  tTapChanger::
  tTapChanger (const name_type& name)
  : ::SCL::tPowerSystemResource (name),
    type_ (type_default_value (), this),
    virtual__ (virtual_default_value (), this)
  {
  }

  tTapChanger::
  tTapChanger (const tTapChanger& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::SCL::tPowerSystemResource (x, f, c),
    type_ (x.type_, f, this),
    virtual__ (x.virtual__, f, this)
  {
  }

  tTapChanger::
  tTapChanger (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::SCL::tPowerSystemResource (e, f | ::xml_schema::flags::base, c),
    type_ (this),
    virtual__ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tTapChanger::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tPowerSystemResource::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "virtual" && n.namespace_ ().empty ())
      {
        this->virtual__.set (virtual_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      this->type_.set (type_default_value ());
    }

    if (!virtual__.present ())
    {
      this->virtual__.set (virtual_default_value ());
    }
  }

  tTapChanger* tTapChanger::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tTapChanger (*this, f, c);
  }

  tTapChanger& tTapChanger::
  operator= (const tTapChanger& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tPowerSystemResource& > (*this) = x;
      this->type_ = x.type_;
      this->virtual__ = x.virtual__;
    }

    return *this;
  }

  tTapChanger::
  ~tTapChanger ()
  {
  }

  // tGeneralEquipment
  //

  tGeneralEquipment::
  tGeneralEquipment (const name_type& name,
                     const type_type& type)
  : ::SCL::tEquipment (name),
    type_ (type, this)
  {
  }

  tGeneralEquipment::
  tGeneralEquipment (const tGeneralEquipment& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::SCL::tEquipment (x, f, c),
    type_ (x.type_, f, this)
  {
  }

  tGeneralEquipment::
  tGeneralEquipment (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::SCL::tEquipment (e, f | ::xml_schema::flags::base, c),
    type_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tGeneralEquipment::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tEquipment::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  tGeneralEquipment* tGeneralEquipment::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tGeneralEquipment (*this, f, c);
  }

  tGeneralEquipment& tGeneralEquipment::
  operator= (const tGeneralEquipment& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tEquipment& > (*this) = x;
      this->type_ = x.type_;
    }

    return *this;
  }

  tGeneralEquipment::
  ~tGeneralEquipment ()
  {
  }

  // tSubstation
  //

  tSubstation::
  tSubstation (const name_type& name)
  : ::SCL::tEquipmentContainer (name),
    VoltageLevel_ (this),
    Function_ (this)
  {
  }

  tSubstation::
  tSubstation (const tSubstation& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::SCL::tEquipmentContainer (x, f, c),
    VoltageLevel_ (x.VoltageLevel_, f, this),
    Function_ (x.Function_, f, this)
  {
  }

  tSubstation::
  tSubstation (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::SCL::tEquipmentContainer (e, f | ::xml_schema::flags::base, c),
    VoltageLevel_ (this),
    Function_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tSubstation::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tEquipmentContainer::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // VoltageLevel
      //
      if (n.name () == "VoltageLevel" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< VoltageLevel_type > r (
          VoltageLevel_traits::create (i, f, this));

        this->VoltageLevel_.push_back (r);
        continue;
      }

      // Function
      //
      if (n.name () == "Function" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< Function_type > r (
          Function_traits::create (i, f, this));

        this->Function_.push_back (r);
        continue;
      }

      break;
    }
  }

  tSubstation* tSubstation::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tSubstation (*this, f, c);
  }

  tSubstation& tSubstation::
  operator= (const tSubstation& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tEquipmentContainer& > (*this) = x;
      this->VoltageLevel_ = x.VoltageLevel_;
      this->Function_ = x.Function_;
    }

    return *this;
  }

  tSubstation::
  ~tSubstation ()
  {
  }

  // tVoltageLevel
  //

  tVoltageLevel::
  tVoltageLevel (const name_type& name)
  : ::SCL::tEquipmentContainer (name),
    Voltage_ (this),
    Bay_ (this)
  {
  }

  tVoltageLevel::
  tVoltageLevel (const tVoltageLevel& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::SCL::tEquipmentContainer (x, f, c),
    Voltage_ (x.Voltage_, f, this),
    Bay_ (x.Bay_, f, this)
  {
  }

  tVoltageLevel::
  tVoltageLevel (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::SCL::tEquipmentContainer (e, f | ::xml_schema::flags::base, c),
    Voltage_ (this),
    Bay_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tVoltageLevel::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tEquipmentContainer::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Voltage
      //
      if (n.name () == "Voltage" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< Voltage_type > r (
          Voltage_traits::create (i, f, this));

        if (!this->Voltage_)
        {
          this->Voltage_.set (r);
          continue;
        }
      }

      // Bay
      //
      if (n.name () == "Bay" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< Bay_type > r (
          Bay_traits::create (i, f, this));

        this->Bay_.push_back (r);
        continue;
      }

      break;
    }
  }

  tVoltageLevel* tVoltageLevel::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tVoltageLevel (*this, f, c);
  }

  tVoltageLevel& tVoltageLevel::
  operator= (const tVoltageLevel& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tEquipmentContainer& > (*this) = x;
      this->Voltage_ = x.Voltage_;
      this->Bay_ = x.Bay_;
    }

    return *this;
  }

  tVoltageLevel::
  ~tVoltageLevel ()
  {
  }

  // tBay
  //

  tBay::
  tBay (const name_type& name)
  : ::SCL::tEquipmentContainer (name),
    ConductingEquipment_ (this),
    ConnectivityNode_ (this)
  {
  }

  tBay::
  tBay (const tBay& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::SCL::tEquipmentContainer (x, f, c),
    ConductingEquipment_ (x.ConductingEquipment_, f, this),
    ConnectivityNode_ (x.ConnectivityNode_, f, this)
  {
  }

  tBay::
  tBay (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::SCL::tEquipmentContainer (e, f | ::xml_schema::flags::base, c),
    ConductingEquipment_ (this),
    ConnectivityNode_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tBay::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tEquipmentContainer::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ConductingEquipment
      //
      if (n.name () == "ConductingEquipment" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< ConductingEquipment_type > r (
          ConductingEquipment_traits::create (i, f, this));

        this->ConductingEquipment_.push_back (r);
        continue;
      }

      // ConnectivityNode
      //
      if (n.name () == "ConnectivityNode" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< ConnectivityNode_type > r (
          ConnectivityNode_traits::create (i, f, this));

        this->ConnectivityNode_.push_back (r);
        continue;
      }

      break;
    }
  }

  tBay* tBay::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tBay (*this, f, c);
  }

  tBay& tBay::
  operator= (const tBay& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tEquipmentContainer& > (*this) = x;
      this->ConductingEquipment_ = x.ConductingEquipment_;
      this->ConnectivityNode_ = x.ConnectivityNode_;
    }

    return *this;
  }

  tBay::
  ~tBay ()
  {
  }

  // tLNode
  //

  const tLNode::lnInst_type tLNode::lnInst_default_value_ (
    "");

  const tLNode::iedName_type tLNode::iedName_default_value_ (
    "None");

  const tLNode::ldInst_type tLNode::ldInst_default_value_ (
    "");

  const tLNode::prefix_type tLNode::prefix_default_value_ (
    "");

  tLNode::
  tLNode (const lnClass_type& lnClass)
  : ::SCL::tUnNaming (),
    lnInst_ (lnInst_default_value (), this),
    lnClass_ (lnClass, this),
    iedName_ (iedName_default_value (), this),
    ldInst_ (ldInst_default_value (), this),
    prefix_ (prefix_default_value (), this),
    lnType_ (this)
  {
  }

  tLNode::
  tLNode (const tLNode& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::SCL::tUnNaming (x, f, c),
    lnInst_ (x.lnInst_, f, this),
    lnClass_ (x.lnClass_, f, this),
    iedName_ (x.iedName_, f, this),
    ldInst_ (x.ldInst_, f, this),
    prefix_ (x.prefix_, f, this),
    lnType_ (x.lnType_, f, this)
  {
  }

  tLNode::
  tLNode (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::SCL::tUnNaming (e, f | ::xml_schema::flags::base, c),
    lnInst_ (this),
    lnClass_ (this),
    iedName_ (this),
    ldInst_ (this),
    prefix_ (this),
    lnType_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tLNode::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tUnNaming::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "lnInst" && n.namespace_ ().empty ())
      {
        this->lnInst_.set (lnInst_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "lnClass" && n.namespace_ ().empty ())
      {
        this->lnClass_.set (lnClass_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "iedName" && n.namespace_ ().empty ())
      {
        this->iedName_.set (iedName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "ldInst" && n.namespace_ ().empty ())
      {
        this->ldInst_.set (ldInst_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "prefix" && n.namespace_ ().empty ())
      {
        this->prefix_.set (prefix_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "lnType" && n.namespace_ ().empty ())
      {
        this->lnType_.set (lnType_traits::create (i, f, this));
        continue;
      }
    }

    if (!lnInst_.present ())
    {
      this->lnInst_.set (lnInst_default_value ());
    }

    if (!lnClass_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "lnClass",
        "");
    }

    if (!iedName_.present ())
    {
      this->iedName_.set (iedName_default_value ());
    }

    if (!ldInst_.present ())
    {
      this->ldInst_.set (ldInst_default_value ());
    }

    if (!prefix_.present ())
    {
      this->prefix_.set (prefix_default_value ());
    }
  }

  tLNode* tLNode::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tLNode (*this, f, c);
  }

  tLNode& tLNode::
  operator= (const tLNode& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tUnNaming& > (*this) = x;
      this->lnInst_ = x.lnInst_;
      this->lnClass_ = x.lnClass_;
      this->iedName_ = x.iedName_;
      this->ldInst_ = x.ldInst_;
      this->prefix_ = x.prefix_;
      this->lnType_ = x.lnType_;
    }

    return *this;
  }

  tLNode::
  ~tLNode ()
  {
  }

  // tFunction
  //

  tFunction::
  tFunction (const name_type& name)
  : ::SCL::tPowerSystemResource (name),
    SubFunction_ (this),
    GeneralEquipment_ (this)
  {
  }

  tFunction::
  tFunction (const tFunction& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::SCL::tPowerSystemResource (x, f, c),
    SubFunction_ (x.SubFunction_, f, this),
    GeneralEquipment_ (x.GeneralEquipment_, f, this)
  {
  }

  tFunction::
  tFunction (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::SCL::tPowerSystemResource (e, f | ::xml_schema::flags::base, c),
    SubFunction_ (this),
    GeneralEquipment_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tFunction::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tPowerSystemResource::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // SubFunction
      //
      if (n.name () == "SubFunction" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< SubFunction_type > r (
          SubFunction_traits::create (i, f, this));

        this->SubFunction_.push_back (r);
        continue;
      }

      // GeneralEquipment
      //
      if (n.name () == "GeneralEquipment" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< GeneralEquipment_type > r (
          GeneralEquipment_traits::create (i, f, this));

        this->GeneralEquipment_.push_back (r);
        continue;
      }

      break;
    }
  }

  tFunction* tFunction::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tFunction (*this, f, c);
  }

  tFunction& tFunction::
  operator= (const tFunction& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tPowerSystemResource& > (*this) = x;
      this->SubFunction_ = x.SubFunction_;
      this->GeneralEquipment_ = x.GeneralEquipment_;
    }

    return *this;
  }

  tFunction::
  ~tFunction ()
  {
  }

  // tSubFunction
  //

  tSubFunction::
  tSubFunction (const name_type& name)
  : ::SCL::tPowerSystemResource (name),
    GeneralEquipment_ (this)
  {
  }

  tSubFunction::
  tSubFunction (const tSubFunction& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::SCL::tPowerSystemResource (x, f, c),
    GeneralEquipment_ (x.GeneralEquipment_, f, this)
  {
  }

  tSubFunction::
  tSubFunction (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::SCL::tPowerSystemResource (e, f | ::xml_schema::flags::base, c),
    GeneralEquipment_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tSubFunction::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tPowerSystemResource::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // GeneralEquipment
      //
      if (n.name () == "GeneralEquipment" && n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
      {
        ::std::auto_ptr< GeneralEquipment_type > r (
          GeneralEquipment_traits::create (i, f, this));

        this->GeneralEquipment_.push_back (r);
        continue;
      }

      break;
    }
  }

  tSubFunction* tSubFunction::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tSubFunction (*this, f, c);
  }

  tSubFunction& tSubFunction::
  operator= (const tSubFunction& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tPowerSystemResource& > (*this) = x;
      this->GeneralEquipment_ = x.GeneralEquipment_;
    }

    return *this;
  }

  tSubFunction::
  ~tSubFunction ()
  {
  }

  // tConnectivityNode
  //

  tConnectivityNode::
  tConnectivityNode (const name_type& name,
                     const pathName_type& pathName)
  : ::SCL::tLNodeContainer (name),
    pathName_ (pathName, this)
  {
  }

  tConnectivityNode::
  tConnectivityNode (const tConnectivityNode& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::SCL::tLNodeContainer (x, f, c),
    pathName_ (x.pathName_, f, this)
  {
  }

  tConnectivityNode::
  tConnectivityNode (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::SCL::tLNodeContainer (e, f | ::xml_schema::flags::base, c),
    pathName_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tConnectivityNode::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tLNodeContainer::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "pathName" && n.namespace_ ().empty ())
      {
        this->pathName_.set (pathName_traits::create (i, f, this));
        continue;
      }
    }

    if (!pathName_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "pathName",
        "");
    }
  }

  tConnectivityNode* tConnectivityNode::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tConnectivityNode (*this, f, c);
  }

  tConnectivityNode& tConnectivityNode::
  operator= (const tConnectivityNode& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tLNodeContainer& > (*this) = x;
      this->pathName_ = x.pathName_;
    }

    return *this;
  }

  tConnectivityNode::
  ~tConnectivityNode ()
  {
  }

  // tTerminal
  //

  const tTerminal::name_type tTerminal::name_default_value_ (
    "");

  tTerminal::
  tTerminal (const connectivityNode_type& connectivityNode,
             const substationName_type& substationName,
             const voltageLevelName_type& voltageLevelName,
             const bayName_type& bayName,
             const cNodeName_type& cNodeName)
  : ::SCL::tUnNaming (),
    name_ (name_default_value (), this),
    connectivityNode_ (connectivityNode, this),
    substationName_ (substationName, this),
    voltageLevelName_ (voltageLevelName, this),
    bayName_ (bayName, this),
    cNodeName_ (cNodeName, this)
  {
  }

  tTerminal::
  tTerminal (const tTerminal& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::SCL::tUnNaming (x, f, c),
    name_ (x.name_, f, this),
    connectivityNode_ (x.connectivityNode_, f, this),
    substationName_ (x.substationName_, f, this),
    voltageLevelName_ (x.voltageLevelName_, f, this),
    bayName_ (x.bayName_, f, this),
    cNodeName_ (x.cNodeName_, f, this)
  {
  }

  tTerminal::
  tTerminal (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::SCL::tUnNaming (e, f | ::xml_schema::flags::base, c),
    name_ (this),
    connectivityNode_ (this),
    substationName_ (this),
    voltageLevelName_ (this),
    bayName_ (this),
    cNodeName_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tTerminal::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::SCL::tUnNaming::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "connectivityNode" && n.namespace_ ().empty ())
      {
        this->connectivityNode_.set (connectivityNode_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "substationName" && n.namespace_ ().empty ())
      {
        this->substationName_.set (substationName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "voltageLevelName" && n.namespace_ ().empty ())
      {
        this->voltageLevelName_.set (voltageLevelName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "bayName" && n.namespace_ ().empty ())
      {
        this->bayName_.set (bayName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "cNodeName" && n.namespace_ ().empty ())
      {
        this->cNodeName_.set (cNodeName_traits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      this->name_.set (name_default_value ());
    }

    if (!connectivityNode_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "connectivityNode",
        "");
    }

    if (!substationName_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "substationName",
        "");
    }

    if (!voltageLevelName_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "voltageLevelName",
        "");
    }

    if (!bayName_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "bayName",
        "");
    }

    if (!cNodeName_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "cNodeName",
        "");
    }
  }

  tTerminal* tTerminal::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tTerminal (*this, f, c);
  }

  tTerminal& tTerminal::
  operator= (const tTerminal& x)
  {
    if (this != &x)
    {
      static_cast< ::SCL::tUnNaming& > (*this) = x;
      this->name_ = x.name_;
      this->connectivityNode_ = x.connectivityNode_;
      this->substationName_ = x.substationName_;
      this->voltageLevelName_ = x.voltageLevelName_;
      this->bayName_ = x.bayName_;
      this->cNodeName_ = x.cNodeName_;
    }

    return *this;
  }

  tTerminal::
  ~tTerminal ()
  {
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace SCL
{
  ::std::auto_ptr< ::SCL::tSubstation >
  Substation (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::SCL::tSubstation > (
      ::SCL::Substation (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::SCL::tSubstation >
  Substation (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::SCL::tSubstation > (
      ::SCL::Substation (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::SCL::tSubstation >
  Substation (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::SCL::tSubstation > (
      ::SCL::Substation (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::SCL::tSubstation >
  Substation (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::SCL::Substation (isrc, f, p);
  }

  ::std::auto_ptr< ::SCL::tSubstation >
  Substation (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::SCL::Substation (isrc, h, f, p);
  }

  ::std::auto_ptr< ::SCL::tSubstation >
  Substation (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::SCL::Substation (isrc, h, f, p);
  }

  ::std::auto_ptr< ::SCL::tSubstation >
  Substation (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::SCL::Substation (isrc, f, p);
  }

  ::std::auto_ptr< ::SCL::tSubstation >
  Substation (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::SCL::Substation (isrc, h, f, p);
  }

  ::std::auto_ptr< ::SCL::tSubstation >
  Substation (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::SCL::Substation (isrc, h, f, p);
  }

  ::std::auto_ptr< ::SCL::tSubstation >
  Substation (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::SCL::tSubstation > (
      ::SCL::Substation (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::SCL::tSubstation >
  Substation (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::SCL::tSubstation > (
      ::SCL::Substation (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::SCL::tSubstation >
  Substation (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::SCL::tSubstation > (
      ::SCL::Substation (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::SCL::tSubstation >
  Substation (const ::xercesc::DOMDocument& doc,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::SCL::tSubstation > (
        ::SCL::Substation (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Substation" &&
        n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
    {
      ::std::auto_ptr< ::SCL::tSubstation > r (
        ::xsd::cxx::tree::traits< ::SCL::tSubstation, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Substation",
      "http://www.iec.ch/61850/2006/SCL");
  }

  ::std::auto_ptr< ::SCL::tSubstation >
  Substation (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Substation" &&
        n.namespace_ () == "http://www.iec.ch/61850/2006/SCL")
    {
      ::std::auto_ptr< ::SCL::tSubstation > r (
        ::xsd::cxx::tree::traits< ::SCL::tSubstation, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Substation",
      "http://www.iec.ch/61850/2006/SCL");
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

